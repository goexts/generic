// Code generated by adptool. DO NOT EDIT.
//
// This file is generated from slices.go.

// Package slices contains generated code by adptool.
package slices

import (
	"golang.org/x/exp/constraints"
	slices "golang.org/x/exp/slices"
)

func BinarySearch[S ~[]E, E constraints.Ordered](x S, target E) (int, bool) {
	return slices.BinarySearch[S, E](x, target)
}

func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool) {
	return slices.BinarySearchFunc[S, E, T](x, target, cmp)
}

func Clip[S ~[]E, E any](s S) S {
	return slices.Clip[S, E](s)
}

func Clone[S ~[]E, E any](s S) S {
	return slices.Clone[S, E](s)
}

func Compact[S ~[]E, E comparable](s S) S {
	return slices.Compact[S, E](s)
}

func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S {
	return slices.CompactFunc[S, E](s, eq)
}

func Compare[S ~[]E, E constraints.Ordered](s1, s2 S) int {
	return slices.Compare[S, E](s1, s2)
}

func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int {
	return slices.CompareFunc[S1, S2, E1, E2](s1, s2, cmp)
}

func Contains[S ~[]E, E comparable](s S, v E) bool {
	return slices.Contains[S, E](s, v)
}

func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool {
	return slices.ContainsFunc[S, E](s, f)
}

func Delete[S ~[]E, E any](s S, i, j int) S {
	return slices.Delete[S, E](s, i, j)
}

func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S {
	return slices.DeleteFunc[S, E](s, del)
}

func Equal[S ~[]E, E comparable](s1, s2 S) bool {
	return slices.Equal[S, E](s1, s2)
}

func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool {
	return slices.EqualFunc[S1, S2, E1, E2](s1, s2, eq)
}

func Grow[S ~[]E, E any](s S, n int) S {
	return slices.Grow[S, E](s, n)
}

func Index[S ~[]E, E comparable](s S, v E) int {
	return slices.Index[S, E](s, v)
}

func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int {
	return slices.IndexFunc[S, E](s, f)
}

func Insert[S ~[]E, E any](s S, i int, v ...E) S {
	return slices.Insert[S, E](s, i, v...)
}

func IsSorted[S ~[]E, E constraints.Ordered](x S) bool {
	return slices.IsSorted[S, E](x)
}

func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool {
	return slices.IsSortedFunc[S, E](x, cmp)
}

func Max[S ~[]E, E constraints.Ordered](x S) E {
	return slices.Max[S, E](x)
}

func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E {
	return slices.MaxFunc[S, E](x, cmp)
}

func Min[S ~[]E, E constraints.Ordered](x S) E {
	return slices.Min[S, E](x)
}

func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E {
	return slices.MinFunc[S, E](x, cmp)
}

func Replace[S ~[]E, E any](s S, i, j int, v ...E) S {
	return slices.Replace[S, E](s, i, j, v...)
}

func Reverse[S ~[]E, E any](s S) {
	slices.Reverse[S, E](s)
}

func Sort[S ~[]E, E constraints.Ordered](x S) {
	slices.Sort[S, E](x)
}

func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int) {
	slices.SortFunc[S, E](x, cmp)
}

func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int) {
	slices.SortStableFunc[S, E](x, cmp)
}
