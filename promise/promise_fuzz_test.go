package promise

import (
	"fmt"
	"strings"
	"testing"
)

// FuzzPromisePanic tests that the promise correctly handles panics
// within the executor function.
func FuzzPromisePanic(f *testing.F) {
	// 1. Add a seed corpus.
	//    These are initial, valid inputs that the fuzz engine will mutate.
	f.Add("a normal panic message")
	f.Add("")           // Test with an empty string.
	f.Add("!@#$%^&*()") // Test with special characters.

	// 2. Define the fuzz target function.
	//    This function receives a *testing.T and the parameters generated by the fuzz engine.
	//    The parameter types must match those provided in f.Add().
	f.Fuzz(func(t *testing.T, panicMsg string) {
		// Create a new Promise whose executor immediately panics with the fuzzed message.
		p := New[int](func(_ func(int), _ func(error)) {
			panic(panicMsg)
		})

		// Wait for the Promise to settle.
		_, err := p.Await()

		// 3. Write assertions.
		//    These assertions should always hold true, regardless of the input.
		if err == nil {
			t.Fatalf("Promise should have been rejected after a panic, but it was not. Panic message: %q", panicMsg)
		}

		// Check if the error message contains the content of the panic.
		expectedErrPart := fmt.Sprintf("promise executor panicked: %v", panicMsg)
		if !strings.Contains(err.Error(), expectedErrPart) {
			t.Errorf("Error message %q does not contain the expected panic message part %q", err.Error(), expectedErrPart)
		}
	})
}
