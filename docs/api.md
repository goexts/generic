<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cast

```go
import "github.com/goexts/generic/cast"
```

Package cast provides safe, generic alternatives to Go's standard type assertion.

This package simplifies type assertions by providing convenient, single\-expression functions that handle the \`value, ok\` idiom in different ways, such as returning a default value or a zero value upon failure.

Example:

```
var myVal any = "hello"

// Standard Go type assertion
str, ok := myVal.(string)
if !ok {
	str = "default"
}

// With cast package - cleaner and more concise
str = cast.Or(myVal, "default")
```

## Index

- [func Or\[T any\]\(v any, def T\) T](<#Or>)
- [func OrZero\[T any\]\(v any\) T](<#OrZero>)
- [func Try\[T any\]\(v any\) \(T, bool\)](<#Try>)


<a name="Or"></a>
## func [Or](<https://github.com/goexts/generic/blob/main/cast/cast.go#L15>)

```go
func Or[T any](v any, def T) T
```

Or attempts to perform a type assertion of v to type T. If the assertion is successful, it returns the converted value. If the assertion fails, it returns the provided default value \`def\`.

<a name="OrZero"></a>
## func [OrZero](<https://github.com/goexts/generic/blob/main/cast/cast.go#L25>)

```go
func OrZero[T any](v any) T
```

OrZero attempts to perform a type assertion of v to type T. If the assertion is successful, it returns the converted value. If the assertion fails, it returns the zero value of type T.

<a name="Try"></a>
## func [Try](<https://github.com/goexts/generic/blob/main/cast/cast.go#L7>)

```go
func Try[T any](v any) (T, bool)
```

Try attempts to perform a type assertion of v to type T. It is a direct, generic wrapper around Go's \`value, ok\` idiom. If the assertion is successful, it returns the converted value and true. If the assertion fails, it returns the zero value of T and false.

# cmp

```go
import "github.com/goexts/generic/cmp"
```

Package cmp provides generic, type\-safe functions for comparing ordered types.

This package offers fundamental comparison utilities like Min, Max, and Clamp. Its central function, Compare, is designed to be fully compatible with the \`slices.SortFunc\`, making it easy to sort slices of any ordered type.

Example \(Sorting a custom type\):

```
type Product struct {
	ID    int
	Price float64
}

products := []Product{
	{ID: 1, Price: 99.99},
	{ID: 2, Price: 49.99},
	{ID: 3, Price: 74.99},
}

// Sort products by price using cmp.Compare
slices.SortFunc(products, func(a, b Product) int {
	return cmp.Compare(a.Price, b.Price)
})

// products is now sorted by Price: [{2 49.99} {3 74.99} {1 99.99}]
```

## Index

- [func Clamp\[T constraints.Ordered\]\(v, lo, hi T\) T](<#Clamp>)
- [func Compare\[T constraints.Ordered\]\(a, b T\) int](<#Compare>)
- [func IsZero\[T comparable\]\(v T\) bool](<#IsZero>)
- [func Max\[T constraints.Ordered\]\(a, b T\) T](<#Max>)
- [func Min\[T constraints.Ordered\]\(a, b T\) T](<#Min>)


<a name="Clamp"></a>
## func [Clamp](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L41>)

```go
func Clamp[T constraints.Ordered](v, lo, hi T) T
```

Clamp returns v clamped to the inclusive range \[lo, hi\]. If v is less than lo, it returns lo. If v is greater than hi, it returns hi. Otherwise, it returns v.

<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L11>)

```go
func Compare[T constraints.Ordered](a, b T) int
```

Compare returns an integer comparing two values. The result will be 0 if a == b, \-1 if a \< b, and \+1 if a \> b.

This function is designed to be fully compatible with the standard library's \`slices.SortFunc\`, making it a convenient tool for sorting slices of any ordered type.

<a name="IsZero"></a>
## func [IsZero](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L53>)

```go
func IsZero[T comparable](v T) bool
```

IsZero returns true if v is the zero value for its type. It is a generic\-safe way to check for zero values.

<a name="Max"></a>
## func [Max](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L30>)

```go
func Max[T constraints.Ordered](a, b T) T
```

Max returns the larger of a or b.

<a name="Min"></a>
## func [Min](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L22>)

```go
func Min[T constraints.Ordered](a, b T) T
```

Min returns the smaller of a or b.

# cond

```go
import "github.com/goexts/generic/cond"
```

Package cond provides generic, ternary\-like conditional functions.

This package offers a concise way to express simple conditional logic in a single expression, avoiding the need for a more verbose if\-else block. It provides functions for both eagerly\-evaluated values and lazily\-evaluated functions.

Example \(Eager Evaluation\):

```
// Instead of:
// var status string
// if code == 200 {
// 	status = "OK"
// } else {
// 	status = "Error"
// }

status := cond.If(code == 200, "OK", "Error")
```

Example \(Lazy Evaluation\):

```
// The expensive functions are only called when needed.
result := cond.IfFunc(isComplex, doComplexCalculation, doSimpleCalculation)
```

## Index

- [func If\[T any\]\(condition bool, trueVal T, falseVal T\) T](<#If>)
- [func IfFunc\[T any\]\(condition bool, trueFn func\(\) T, falseFn func\(\) T\) T](<#IfFunc>)
- [func IfFuncE\[T any\]\(condition bool, trueFn func\(\) \(T, error\), falseFn func\(\) \(T, error\)\) \(T, error\)](<#IfFuncE>)


<a name="If"></a>
## func [If](<https://github.com/goexts/generic/blob/main/cond/cond.go#L8>)

```go
func If[T any](condition bool, trueVal T, falseVal T) T
```

If returns trueVal if the condition is true, and falseVal otherwise. This is a generic, eagerly\-evaluated ternary\-like expression. Both trueVal and falseVal are evaluated before this function is called.

For lazy evaluation where values are expensive to compute, see IfFunc.

<a name="IfFunc"></a>
## func [IfFunc](<https://github.com/goexts/generic/blob/main/cond/cond.go#L19>)

```go
func IfFunc[T any](condition bool, trueFn func() T, falseFn func() T) T
```

IfFunc returns the result of trueFn if the condition is true, and the result of falseFn otherwise. This is a generic, lazily\-evaluated ternary\-like expression. Only the function corresponding to the condition's outcome is executed.

<a name="IfFuncE"></a>
## func [IfFuncE](<https://github.com/goexts/generic/blob/main/cond/cond.go#L30>)

```go
func IfFuncE[T any](condition bool, trueFn func() (T, error), falseFn func() (T, error)) (T, error)
```

IfFuncE returns the result of trueFn if the condition is true, and the result of falseFn otherwise. It is the error\-returning version of IfFunc. This is a generic, lazily\-evaluated ternary\-like expression. Only the function corresponding to the condition's outcome is executed.

# configure

```go
import "github.com/goexts/generic/configure"
```

Package configure provides utilities for applying functional options to objects.

Package configure provides a robust, type\-safe, and flexible implementation of the Functional Options Pattern for Go. It is designed to handle a wide range of configuration scenarios, from simple object initialization to complex, multi\-stage product compilation.

### Core Concepts

The package is built around a few core ideas:

- \*\*Type\-Safe Application\*\*: For the highest performance and compile\-time safety, use the \`Apply\` and \`ApplyE\` functions. They are ideal when all options are of the same, known type.
  
  // Example of simple, type\-safe configuration: type Server struct \{ Port int Host string \} type Option func\(\*Server\) func WithPort\(p int\) Option \{ return func\(s \*Server\) \{ s.Port = p \} \} func WithHost\(h string\) Option \{ return func\(s \*Server\) \{ s.Host = h \} \}
  
  server := &Server\{\} configure.Apply\(server, \[\]Option\{ WithPort\(8080\), WithHost\("localhost"\), \}\)

- \*\*Flexible Application\*\*: When you need to handle a mix of different option types, use \`ApplyAny\`. This function uses type assertions to provide flexibility, at the cost of compile\-time safety and a minor performance overhead.
  
  opts := \[\]any\{ WithPort\(8080\), func\(s \*Server\) \{ s.Host = "example.com" \}, // A raw function \} server, err := configure.New\[Server\]\(opts...\)

- \*\*Stateful Builder\*\*: For scenarios where options are collected progressively from different parts of your application, use the \`Builder\`. It provides a fluent, chainable API.
  
  builder := configure.NewBuilder\[Server\]\(\). Add\(WithPort\(443\)\). AddWhen\(isProduction, WithHost\("prod.server.com"\)\)
  
  server, err := builder.Build\(\)

- \*\*Compilation\*\*: For the advanced use case of transforming a configuration object \`C\` into a final product \`P\`, use the top\-level \`Compile\` function. This separates the configuration logic from the product creation logic.
  
  // Example: Using a \`ClientConfig\` to create an \`\*http.Client\` type ClientConfig struct \{ Timeout time.Duration \} factory := func\(c \*ClientConfig\) \(\*http.Client, error\) \{ return &http.Client\{Timeout: c.Timeout\}, nil \}
  
  configBuilder := configure.NewBuilder\[ClientConfig\]\(\). Add\(func\(c \*ClientConfig\) \{ c.Timeout = 20 \* time.Second \}\)
  
  httpClient, err := configure.Compile\(configBuilder, factory\)

By combining these tools, developers can choose the right approach for their specific needs, ensuring code remains clean, maintainable, and robust.

## Index

- [func Apply\[T any, O FuncOption\[T\]\]\(target \*T, opts \[\]O\) \*T](<#Apply>)
- [func ApplyAny\[T any\]\(target \*T, opts \[\]any\) \(\*T, error\)](<#ApplyAny>)
- [func ApplyAnyWith\[T any\]\(target \*T, opts ...any\) \(\*T, error\)](<#ApplyAnyWith>)
- [func ApplyE\[T any, O FuncOptionE\[T\]\]\(target \*T, opts \[\]O\) \(\*T, error\)](<#ApplyE>)
- [func ApplyWith\[T any\]\(target \*T, opts ...Option\[T\]\) \*T](<#ApplyWith>)
- [func ApplyWithE\[T any\]\(target \*T, opts ...OptionE\[T\]\) \(\*T, error\)](<#ApplyWithE>)
- [func Compile\[C any, P any\]\(builder \*Builder\[C\], factory func\(c \*C\) \(\*P, error\)\) \(\*P, error\)](<#Compile>)
- [func IsConfigError\(err error\) bool](<#IsConfigError>)
- [func IsEmptyTargetValueError\(err error\) bool](<#IsEmptyTargetValueError>)
- [func IsExecutionFailedError\(err error\) bool](<#IsExecutionFailedError>)
- [func IsUnsupportedTypeError\(err error\) bool](<#IsUnsupportedTypeError>)
- [func New\[T any, O FuncOption\[T\]\]\(opts \[\]O\) \*T](<#New>)
- [func NewAny\[T any\]\(opts ...any\) \(\*T, error\)](<#NewAny>)
- [func NewE\[T any, O FuncOptionE\[T\]\]\(opts \[\]O\) \(\*T, error\)](<#NewE>)
- [func NewWith\[T any\]\(opts ...Option\[T\]\) \*T](<#NewWith>)
- [func NewWithE\[T any\]\(opts ...OptionE\[T\]\) \(\*T, error\)](<#NewWithE>)
- [type Applier](<#Applier>)
- [type ApplierE](<#ApplierE>)
- [type Builder](<#Builder>)
  - [func NewBuilder\[C any\]\(\) \*Builder\[C\]](<#NewBuilder>)
  - [func \(b \*Builder\[C\]\) Add\(opts ...any\) \*Builder\[C\]](<#Builder[C].Add>)
  - [func \(b \*Builder\[C\]\) AddWhen\(condition bool, opt any\) \*Builder\[C\]](<#Builder[C].AddWhen>)
  - [func \(b \*Builder\[C\]\) Apply\(target \*C\) error](<#Builder[C].Apply>)
  - [func \(b \*Builder\[C\]\) ApplyTo\(target \*C\) \(\*C, error\)](<#Builder[C].ApplyTo>)
  - [func \(b \*Builder\[C\]\) Build\(\) \(\*C, error\)](<#Builder[C].Build>)
- [type ConfigError](<#ConfigError>)
  - [func \(e \*ConfigError\) Error\(\) string](<#ConfigError.Error>)
  - [func \(e \*ConfigError\) Unwrap\(\) error](<#ConfigError.Unwrap>)
- [type ErrorCode](<#ErrorCode>)
- [type FuncOption](<#FuncOption>)
- [type FuncOptionAny](<#FuncOptionAny>)
- [type FuncOptionE](<#FuncOptionE>)
- [type Option](<#Option>)
  - [func OptionSet\[T any\]\(opts ...Option\[T\]\) Option\[T\]](<#OptionSet>)
  - [func \(o Option\[T\]\) Apply\(target \*T\)](<#Option[T].Apply>)
- [type OptionE](<#OptionE>)
  - [func OptionSetE\[T any\]\(opts ...OptionE\[T\]\) OptionE\[T\]](<#OptionSetE>)
  - [func WithValidation\[T any\]\(validator func\(\*T\) error\) OptionE\[T\]](<#WithValidation>)
  - [func \(o OptionE\[T\]\) Apply\(target \*T\) error](<#OptionE[T].Apply>)


<a name="Apply"></a>
## func [Apply](<https://github.com/goexts/generic/blob/main/configure/apply.go#L116>)

```go
func Apply[T any, O FuncOption[T]](target *T, opts []O) *T
```

Apply applies a slice of options to the target. It is the core, high\-performance function for applying a homogeneous set of type\-safe options. Its generic constraint allows for custom\-defined option types, such as \`type MyOption func\(\*T\)\`.

For handling mixed option types, see ApplyAny.

<a name="ApplyAny"></a>
## func [ApplyAny](<https://github.com/goexts/generic/blob/main/configure/apply.go#L160>)

```go
func ApplyAny[T any](target *T, opts []any) (*T, error)
```

ApplyAny applies a slice of options of various types \(any\). This function provides flexibility by using reflection to handle heterogeneous options, at the cost of compile\-time type safety and a minor performance overhead.

For type\-safe, high\-performance application, see Apply or ApplyE.

<a name="ApplyAnyWith"></a>
## func [ApplyAnyWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L173>)

```go
func ApplyAnyWith[T any](target *T, opts ...any) (*T, error)
```

ApplyAnyWith is the variadic convenience wrapper for ApplyAny.

<a name="ApplyE"></a>
## func [ApplyE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L137>)

```go
func ApplyE[T any, O FuncOptionE[T]](target *T, opts []O) (*T, error)
```

ApplyE applies a slice of error\-returning options to the target. It is the core, high\-performance function for applying a homogeneous set of type\-safe, error\-returning options. Its generic constraint allows for custom\-defined option types.

For handling mixed option types, see ApplyAny.

<a name="ApplyWith"></a>
## func [ApplyWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L127>)

```go
func ApplyWith[T any](target *T, opts ...Option[T]) *T
```

ApplyWith is the variadic convenience wrapper for Apply.

<a name="ApplyWithE"></a>
## func [ApplyWithE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L150>)

```go
func ApplyWithE[T any](target *T, opts ...OptionE[T]) (*T, error)
```

ApplyWithE is the variadic convenience wrapper for ApplyE.

<a name="Compile"></a>
## func [Compile](<https://github.com/goexts/generic/blob/main/configure/builder.go#L82>)

```go
func Compile[C any, P any](builder *Builder[C], factory func(c *C) (*P, error)) (*P, error)
```

Compile creates a final product \`P\` by first building a configuration \`C\` using the provided builder, and then passing the result to a factory function. This is the primary top\-level function for the Config \-\> Product workflow, ensuring a clean separation between configuration and compilation.

<a name="IsConfigError"></a>
## func [IsConfigError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L71>)

```go
func IsConfigError(err error) bool
```

IsConfigError checks if the given error is a \*ConfigError.

<a name="IsEmptyTargetValueError"></a>
## func [IsEmptyTargetValueError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L92>)

```go
func IsEmptyTargetValueError(err error) bool
```

IsEmptyTargetValueError checks if the error is a ConfigError with the code ErrEmptyTargetValue.

<a name="IsExecutionFailedError"></a>
## func [IsExecutionFailedError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L85>)

```go
func IsExecutionFailedError(err error) bool
```

IsExecutionFailedError checks if the error is a ConfigError with the code ErrExecutionFailed.

<a name="IsUnsupportedTypeError"></a>
## func [IsUnsupportedTypeError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L78>)

```go
func IsUnsupportedTypeError(err error) bool
```

IsUnsupportedTypeError checks if the error is a ConfigError with the code ErrUnsupportedType.

<a name="New"></a>
## func [New](<https://github.com/goexts/generic/blob/main/configure/apply.go#L197>)

```go
func New[T any, O FuncOption[T]](opts []O) *T
```

New creates a new instance of T and applies the given options. It is a convenient, type\-safe constructor for creating objects with homogeneous options. For mixed\-type or error\-returning options, see NewAny or NewE.

<a name="NewAny"></a>
## func [NewAny](<https://github.com/goexts/generic/blob/main/configure/apply.go#L227>)

```go
func NewAny[T any](opts ...any) (*T, error)
```

NewAny creates a new instance of T, applies the given options of any type, and returns it. It is a convenient top\-level constructor for simple object creation where the configuration type and the product type are the same.

It uses ApplyAny for maximum flexibility in accepting options.

<a name="NewE"></a>
## func [NewE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L211>)

```go
func NewE[T any, O FuncOptionE[T]](opts []O) (*T, error)
```

NewE creates a new instance of T, applies the error\-returning options, and returns the configured instance or an error. It is a convenient, type\-safe constructor for creating objects with homogeneous, error\-returning options.

<a name="NewWith"></a>
## func [NewWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L203>)

```go
func NewWith[T any](opts ...Option[T]) *T
```

NewWith is the variadic convenience wrapper for New.

<a name="NewWithE"></a>
## func [NewWithE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L217>)

```go
func NewWithE[T any](opts ...OptionE[T]) (*T, error)
```

NewWithE is the variadic convenience wrapper for NewE.

<a name="Applier"></a>
## type [Applier](<https://github.com/goexts/generic/blob/main/configure/apply.go#L10-L12>)

Applier is an interface for types that can apply a configuration to an object. It provides an extension point for ApplyAny, allowing custom types to be used as options without reflection.

```go
type Applier[T any] interface {
    Apply(*T)
}
```

<a name="ApplierE"></a>
## type [ApplierE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L17-L19>)

ApplierE is an interface for types that can apply a configuration and return an error. It provides an extension point for ApplyAny, allowing custom types to be used as options without reflection.

```go
type ApplierE[T any] interface {
    Apply(*T) error
}
```

<a name="Builder"></a>
## type [Builder](<https://github.com/goexts/generic/blob/main/configure/builder.go#L15-L17>)

Builder provides a fluent interface for collecting and applying options. It is ideal for scenarios where configuration options are gathered progressively from different parts of an application.

The generic type C represents the configuration type being built, and is expected to be a struct type. Using a pointer type for C is not recommended as it can lead to unexpected behavior.

```go
type Builder[C any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewBuilder"></a>
### func [NewBuilder](<https://github.com/goexts/generic/blob/main/configure/builder.go#L20>)

```go
func NewBuilder[C any]() *Builder[C]
```

NewBuilder creates a new, empty configuration builder.

<a name="Builder[C].Add"></a>
### func \(\*Builder\[C\]\) [Add](<https://github.com/goexts/generic/blob/main/configure/builder.go#L25>)

```go
func (b *Builder[C]) Add(opts ...any) *Builder[C]
```

Add adds one or more options to the builder. It supports a fluent, chainable API.

<a name="Builder[C].AddWhen"></a>
### func \(\*Builder\[C\]\) [AddWhen](<https://github.com/goexts/generic/blob/main/configure/builder.go#L32>)

```go
func (b *Builder[C]) AddWhen(condition bool, opt any) *Builder[C]
```

AddWhen conditionally adds an option to the builder if the condition is true. It supports a fluent, chainable API.

<a name="Builder[C].Apply"></a>
### func \(\*Builder\[C\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/builder.go#L73>)

```go
func (b *Builder[C]) Apply(target *C) error
```

Apply implements the ApplierE interface. This allows a Builder instance to be passed directly as an option to other functions like New or ApplyAny, acting as a "super option".

<a name="Builder[C].ApplyTo"></a>
### func \(\*Builder\[C\]\) [ApplyTo](<https://github.com/goexts/generic/blob/main/configure/builder.go#L52>)

```go
func (b *Builder[C]) ApplyTo(target *C) (*C, error)
```

ApplyTo applies all collected options to an existing target object.

<a name="Builder[C].Build"></a>
### func \(\*Builder\[C\]\) [Build](<https://github.com/goexts/generic/blob/main/configure/builder.go#L62>)

```go
func (b *Builder[C]) Build() (*C, error)
```

Build creates a new, zero\-value instance of the configuration object C and applies all collected options to it. The resulting object can then be used directly or passed to a factory.

<a name="ConfigError"></a>
## type [ConfigError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L29-L36>)

ConfigError is a custom error type for the configure package. It wraps an original error while providing additional context, such as the type of option that caused the failure and a specific error code.

```go
type ConfigError struct {
    // Code is the category of the error.
    Code ErrorCode
    // TypeString is the string representation of the option's type.
    TypeString string
    // Err is the underlying error, if any.
    Err error
}
```

<a name="ConfigError.Error"></a>
### func \(\*ConfigError\) [Error](<https://github.com/goexts/generic/blob/main/configure/errors.go#L54>)

```go
func (e *ConfigError) Error() string
```

Error implements the standard error interface.

<a name="ConfigError.Unwrap"></a>
### func \(\*ConfigError\) [Unwrap](<https://github.com/goexts/generic/blob/main/configure/errors.go#L49>)

```go
func (e *ConfigError) Unwrap() error
```

Unwrap makes ConfigError compatible with the standard library's errors.Is and errors.As functions, allowing for proper error chain inspection.

<a name="ErrorCode"></a>
## type [ErrorCode](<https://github.com/goexts/generic/blob/main/configure/errors.go#L9>)

ErrorCode defines the specific category of a configuration error.

```go
type ErrorCode int
```

<a name="ErrUnsupportedType"></a>Error codes for specific configuration failures.

```go
const (
    // ErrUnsupportedType indicates that an option's type is not supported by
    // the ApplyAny function.
    ErrUnsupportedType ErrorCode = iota

    // ErrExecutionFailed indicates that an option function returned an error
    // during its execution.
    ErrExecutionFailed

    // ErrEmptyTargetValue indicates that a nil pointer was passed as the target
    // for configuration.
    ErrEmptyTargetValue
)
```

<a name="FuncOption"></a>
## type [FuncOption](<https://github.com/goexts/generic/blob/main/configure/options.go#L31-L33>)

FuncOption is a generic constraint that permits any function type whose underlying type is func\(\*T\). This enables the top\-level Apply function to accept custom\-defined option types, such as \`type MyOption func\(\*T\)\`.

```go
type FuncOption[T any] interface {
    // contains filtered or unexported methods
}
```

<a name="FuncOptionAny"></a>
## type [FuncOptionAny](<https://github.com/goexts/generic/blob/main/configure/options.go#L46-L48>)

FuncOptionAny is a generic constraint that permits any function type whose underlying type is either func\(\*T\) or func\(\*T\) error. This provides a convenient way to create functions that can accept both error\-returning and non\-error\-returning function options.

```go
type FuncOptionAny[T any] interface {
    // contains filtered or unexported methods
}
```

<a name="FuncOptionE"></a>
## type [FuncOptionE](<https://github.com/goexts/generic/blob/main/configure/options.go#L38-L40>)

FuncOptionE is a generic constraint that permits any function type whose underlying type is func\(\*T\) error. This enables the top\-level ApplyE function to accept custom\-defined, error\-returning option types.

```go
type FuncOptionE[T any] interface {
    // contains filtered or unexported methods
}
```

<a name="Option"></a>
## type [Option](<https://github.com/goexts/generic/blob/main/configure/options.go#L5>)

Option represents a function that configures an object of type T. It is the primary, non\-error\-returning type for the Functional Options Pattern.

```go
type Option[T any] func(*T)
```

<a name="OptionSet"></a>
### func [OptionSet](<https://github.com/goexts/generic/blob/main/configure/apply.go#L179>)

```go
func OptionSet[T any](opts ...Option[T]) Option[T]
```

OptionSet bundles multiple options into a single option. This allows for creating reusable and modular sets of configurations.

<a name="Option[T].Apply"></a>
### func \(Option\[T\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/options.go#L9>)

```go
func (o Option[T]) Apply(target *T)
```

Apply implements the Applier\[T\] interface, allowing an Option\[T\] to be used as a flexible option type with functions like ApplyAny.

<a name="OptionE"></a>
## type [OptionE](<https://github.com/goexts/generic/blob/main/configure/options.go#L17>)

OptionE represents a function that configures an object of type T and may return an error. The 'E' suffix is a convention for "Error".

```go
type OptionE[T any] func(*T) error
```

<a name="OptionSetE"></a>
### func [OptionSetE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L187>)

```go
func OptionSetE[T any](opts ...OptionE[T]) OptionE[T]
```

OptionSetE bundles multiple error\-returning options into a single option. If any option in the set returns an error, the application stops and the error is returned.

<a name="WithValidation"></a>
### func [WithValidation](<https://github.com/goexts/generic/blob/main/configure/constructors.go#L6>)

```go
func WithValidation[T any](validator func(*T) error) OptionE[T]
```

WithValidation creates an option that validates the target object. If the validator function returns an error, the configuration process will stop.

<a name="OptionE[T].Apply"></a>
### func \(OptionE\[T\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/options.go#L21>)

```go
func (o OptionE[T]) Apply(target *T) error
```

Apply implements the ApplierE\[T\] interface, allowing an OptionE\[T\] to be used as a flexible option type with functions like ApplyAny.

# maps

```go
import "github.com/goexts/generic/maps"
```

Package maps provides a set of generic functions for common operations on maps.

This package is a generated adapter and mirrors the public API of the standard Go experimental package \`golang.org/x/exp/maps\`. It offers a convenient way to access these common utilities, such as cloning maps, extracting keys or values, and comparing maps for equality.

Example \(Extracting Keys and Values\):

```
ages := map[string]int{
	"Alice": 30,
	"Bob":   25,
	"Carol": 35,
}

names := maps.Keys(ages)   // Returns ["Alice", "Bob", "Carol"] (order is not guaranteed)
_ = maps.Values(ages) // Returns [30, 25, 35] (order is not guaranteed)

// Sort the names for deterministic output
slices.Sort(names)
// names is now ["Alice", "Bob", "Carol"]
```

Package maps implements the functions, types, and interfaces for the module.

Package maps contains generated code by adptool.

## Index

- [func Clear\[M \~map\[K\]V, K comparable, V any\]\(m M\)](<#Clear>)
- [func Clone\[M \~map\[K\]V, K comparable, V any\]\(m M\) M](<#Clone>)
- [func Copy\[M1 \~map\[K\]V, M2 \~map\[K\]V, K comparable, V any\]\(dst M1, src M2\)](<#Copy>)
- [func DeleteFunc\[M \~map\[K\]V, K comparable, V any\]\(m M, del func\(K, V\) bool\)](<#DeleteFunc>)
- [func Equal\[M1, M2 \~map\[K\]V, K, V comparable\]\(m1 M1, m2 M2\) bool](<#Equal>)
- [func EqualFunc\[M1 \~map\[K\]V1, M2 \~map\[K\]V2, K comparable, V1, V2 any\]\(m1 M1, m2 M2, eq func\(V1, V2\) bool\) bool](<#EqualFunc>)
- [func Filter\[M \~map\[K\]V, K comparable, V any\]\(m M, keys ...K\)](<#Filter>)
- [func FilterFunc\[M \~map\[K\]V, K comparable, V any\]\(m M, f func\(K, V\) bool\)](<#FilterFunc>)
- [func GetOr\[V any\]\(v V, ok bool, defaultValue V\) V](<#GetOr>)
- [func GetOrNil\[V any\]\(v \*V, ok bool\) \*V](<#GetOrNil>)
- [func GetOrZero\[V any\]\(v V, ok bool\) V](<#GetOrZero>)
- [func KVsToMap\[KV KeyValue\[K, V\], K comparable, V any, M \~map\[K\]V\]\(kvs \[\]KeyValue\[K, V\]\) M](<#KVsToMap>)
- [func Keys\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]K](<#Keys>)
- [func MapToKVs\[M \~map\[K\]V, K comparable, V any, KV KeyValue\[K, V\]\]\(m M\) \[\]KV](<#MapToKVs>)
- [func MapToStruct\[M \~map\[K\]V, K comparable, V any, S any\]\(m M, f func\(\*S, K, V\) \*S\) \*S](<#MapToStruct>)
- [func MapToTypes\[M \~map\[K\]V, K comparable, V any, T any\]\(m M, f func\(K, V\) T\) \[\]T](<#MapToTypes>)
- [func Merge\[M \~map\[K\]V, K comparable, V any\]\(dest M, src M, overlay bool\)](<#Merge>)
- [func MergeFunc\[M \~map\[K\]V, K comparable, V any\]\(dest M, src M, cmp func\(key K, src V, val V\) V\)](<#MergeFunc>)
- [func MergeMaps\[M \~map\[K\]V, K comparable, V any\]\(m M, ms ...M\)](<#MergeMaps>)
- [func MergeMapsFunc\[M \~map\[K\]V, K comparable, V any\]\(merge func\(K, V, V\) V, m M, ms ...M\)](<#MergeMapsFunc>)
- [func MustGet\[V any\]\(v V, ok bool\) V](<#MustGet>)
- [func Transform\[M \~map\[K\]V, K comparable, V any, TK comparable, TV any\]\(m M, f func\(K, V\) \(TK, TV, bool\)\) map\[TK\]TV](<#Transform>)
- [func TypesToMap\[T any, M \~map\[K\]V, K comparable, V any\]\(ts \[\]T, f func\(T\) \(K, V\)\) M](<#TypesToMap>)
- [func Values\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]V](<#Values>)
- [type KeyValue](<#KeyValue>)


<a name="Clear"></a>
## func [Clear](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L12>)

```go
func Clear[M ~map[K]V, K comparable, V any](m M)
```



<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L16>)

```go
func Clone[M ~map[K]V, K comparable, V any](m M) M
```



<a name="Copy"></a>
## func [Copy](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L20>)

```go
func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)
```



<a name="DeleteFunc"></a>
## func [DeleteFunc](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L24>)

```go
func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)
```



<a name="Equal"></a>
## func [Equal](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L28>)

```go
func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool
```



<a name="EqualFunc"></a>
## func [EqualFunc](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L32>)

```go
func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool
```



<a name="Filter"></a>
## func [Filter](<https://github.com/goexts/generic/blob/main/maps/map.go#L57>)

```go
func Filter[M ~map[K]V, K comparable, V any](m M, keys ...K)
```

Filter removes all key/value pairs from m for which f returns false.

<a name="FilterFunc"></a>
## func [FilterFunc](<https://github.com/goexts/generic/blob/main/maps/map.go#L64>)

```go
func FilterFunc[M ~map[K]V, K comparable, V any](m M, f func(K, V) bool)
```

FilterFunc is like Filter, but uses a function.

<a name="GetOr"></a>
## func [GetOr](<https://github.com/goexts/generic/blob/main/maps/map.go#L161>)

```go
func GetOr[V any](v V, ok bool, defaultValue V) V
```

GetOr is a utility function that simplifies map lookups. It returns the value from a map lookup or a default value if the key is not found.

<a name="GetOrNil"></a>
## func [GetOrNil](<https://github.com/goexts/generic/blob/main/maps/map.go#L180>)

```go
func GetOrNil[V any](v *V, ok bool) *V
```

GetOrNil is a utility function that simplifies map lookups for pointer types. It returns the value from a map lookup or nil if the key is not found.

<a name="GetOrZero"></a>
## func [GetOrZero](<https://github.com/goexts/generic/blob/main/maps/map.go#L170>)

```go
func GetOrZero[V any](v V, ok bool) V
```

GetOrZero is a utility function that simplifies map lookups. It returns the value from a map lookup or the zero value of the type if the key is not found.

<a name="KVsToMap"></a>
## func [KVsToMap](<https://github.com/goexts/generic/blob/main/maps/map.go#L88>)

```go
func KVsToMap[KV KeyValue[K, V], K comparable, V any, M ~map[K]V](kvs []KeyValue[K, V]) M
```

KVsToMap converts a slice of key\-value pairs to a map.

<a name="Keys"></a>
## func [Keys](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L36>)

```go
func Keys[M ~map[K]V, K comparable, V any](m M) []K
```



<a name="MapToKVs"></a>
## func [MapToKVs](<https://github.com/goexts/generic/blob/main/maps/map.go#L79>)

```go
func MapToKVs[M ~map[K]V, K comparable, V any, KV KeyValue[K, V]](m M) []KV
```

MapToKVs converts a map to a slice of key\-value pairs.

<a name="MapToStruct"></a>
## func [MapToStruct](<https://github.com/goexts/generic/blob/main/maps/map.go#L116>)

```go
func MapToStruct[M ~map[K]V, K comparable, V any, S any](m M, f func(*S, K, V) *S) *S
```

MapToStruct converts a map to a struct.

<a name="MapToTypes"></a>
## func [MapToTypes](<https://github.com/goexts/generic/blob/main/maps/map.go#L97>)

```go
func MapToTypes[M ~map[K]V, K comparable, V any, T any](m M, f func(K, V) T) []T
```

MapToTypes converts a map to a slice of types.

<a name="Merge"></a>
## func [Merge](<https://github.com/goexts/generic/blob/main/maps/map.go#L10>)

```go
func Merge[M ~map[K]V, K comparable, V any](dest M, src M, overlay bool)
```

Merge merges the values of src into dest. If overlay is true, existing values in dest will be overwritten.

<a name="MergeFunc"></a>
## func [MergeFunc](<https://github.com/goexts/generic/blob/main/maps/map.go#L20>)

```go
func MergeFunc[M ~map[K]V, K comparable, V any](dest M, src M, cmp func(key K, src V, val V) V)
```

MergeFunc merges the values of src into dest using the provided merge function. If a key exists in both maps, the merge function will be called to determine the final value.

<a name="MergeMaps"></a>
## func [MergeMaps](<https://github.com/goexts/generic/blob/main/maps/map.go#L32>)

```go
func MergeMaps[M ~map[K]V, K comparable, V any](m M, ms ...M)
```

MergeMaps merges multiple maps into a single map. If a key exists in multiple maps, the value from the last map will be used.

<a name="MergeMapsFunc"></a>
## func [MergeMapsFunc](<https://github.com/goexts/generic/blob/main/maps/map.go#L45>)

```go
func MergeMapsFunc[M ~map[K]V, K comparable, V any](merge func(K, V, V) V, m M, ms ...M)
```

MergeMapsFunc merges multiple maps into a single map using a custom merge function. If a key exists in multiple maps, the merge function will be called to determine the final value.

<a name="MustGet"></a>
## func [MustGet](<https://github.com/goexts/generic/blob/main/maps/map.go#L152>)

```go
func MustGet[V any](v V, ok bool) V
```

MustGet is a utility function that simplifies map lookups. It returns the value from a map lookup and panics if the key is not found.

<a name="Transform"></a>
## func [Transform](<https://github.com/goexts/generic/blob/main/maps/map.go#L128>)

```go
func Transform[M ~map[K]V, K comparable, V any, TK comparable, TV any](m M, f func(K, V) (TK, TV, bool)) map[TK]TV
```

Transform remaps the keys and values of a map using a custom transformation function. The transformation function is called for each key\-value pair in the original map. If the transformation function returns false as its third return value, the key\-value pair is skipped. Otherwise, the transformed key\-value pair is added to the new map.

<a name="TypesToMap"></a>
## func [TypesToMap](<https://github.com/goexts/generic/blob/main/maps/map.go#L106>)

```go
func TypesToMap[T any, M ~map[K]V, K comparable, V any](ts []T, f func(T) (K, V)) M
```

TypesToMap converts a slice of types to a map.

<a name="Values"></a>
## func [Values](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L40>)

```go
func Values[M ~map[K]V, K comparable, V any](m M) []V
```



<a name="KeyValue"></a>
## type [KeyValue](<https://github.com/goexts/generic/blob/main/maps/map.go#L73-L76>)

KeyValue is a key\-value pair.

```go
type KeyValue[K comparable, V any] struct {
    Key K
    Val V
}
```

# must

```go
import "github.com/goexts/generic/must"
```

Package must provides helper functions that wrap calls returning an error and panic if the error is non\-nil. This is intended to reduce boilerplate in specific, controlled contexts.

WARNING: The functions in this package should be used with extreme care. They intentionally convert a recoverable error into a non\-recoverable panic. This is only appropriate in specific situations where an error is considered a bug in the program, not a predictable runtime failure.

Appropriate Use Cases:

- Program initialization \(e.g., in \`init\` functions or \`main\`\): parsing hardcoded configuration, compiling essential regular expressions, or setting up database connections that are required for the application to start.

- Test setup: When setting up test fixtures where a failure indicates a broken test, not a feature to be tested.

Example:

```
// Instead of:
// re, err := regexp.Compile(`\w+`)
// if err != nil {
// 	panic(err)
// }

// Use must.Must for cleaner initialization code:
re := must.Must(regexp.Compile(`\w+`))
```

DO NOT use these functions for regular application logic where errors are expected \(e.g., handling user input, network requests, file I/O\).

## Index

- [func Cast\[T any\]\(v any\) T](<#Cast>)
- [func Do\[T any\]\(v T, err error\) T](<#Do>)
- [func Do2\[T any, U any\]\(v1 T, v2 U, err error\) \(T, U\)](<#Do2>)


<a name="Cast"></a>
## func [Cast](<https://github.com/goexts/generic/blob/main/must/must.go#L25>)

```go
func Cast[T any](v any) T
```

Cast performs a type assertion and panics if it fails. It provides a more informative panic message than a raw type assertion.

<a name="Do"></a>
## func [Do](<https://github.com/goexts/generic/blob/main/must/must.go#L8>)

```go
func Do[T any](v T, err error) T
```

Do panics if err is not nil, otherwise it returns the value v. It is useful for wrapping function calls that return a value and an error, where the error is not expected.

<a name="Do2"></a>
## func [Do2](<https://github.com/goexts/generic/blob/main/must/must.go#L16>)

```go
func Do2[T any, U any](v1 T, v2 U, err error) (T, U)
```

Do2 is similar to Do, but for functions that return two values and an error.

# promise

```go
import "github.com/goexts/generic/promise"
```

Package promise provides a generic, type\-safe implementation of Promises, inspired by the JavaScript Promise API. It is designed to simplify the management of asynchronous operations and avoid complex callback chains \("callback hell"\).

### Core Concepts

A Promise represents the eventual completion \(or failure\) of an asynchronous operation and its resulting value. A Promise is in one of three states:

- pending: the initial state; neither fulfilled nor rejected.
- fulfilled: the operation completed successfully, resulting in a value.
- rejected: the operation failed, resulting in an error.

### Basic Usage

The primary way to create a promise is with the \`New\` function, which takes an \`executor\` function. The executor is run in a new goroutine and receives \`resolve\` and \`reject\` functions to control the promise's outcome.

Example:

```
// Create a promise that resolves after a delay.
p := promise.New(func(resolve func(string), reject func(error)) {
	time.Sleep(100 * time.Millisecond)
	resolve("Hello, World!")
})

// The Await method blocks until the promise is settled.
val, err := p.Await()
// val is "Hello, World!", err is nil.
```

### Chaining

Promises can be chained together using methods like \`Then\`, \`Catch\`, and \`Finally\` to create a clean, linear asynchronous workflow.

```
resultPromise := promise.Async(func() (int, error) {
	// Simulate an API call
	return 42, nil
}).Then(func(val int) int {
	// Transform the result
	return val * 2
}).Catch(func(err error) (int, error) {
	// Handle any previous errors and potentially recover.
	fmt.Printf("An error occurred: %v\n", err)
	return 0, nil // Recover with a default value
})

finalResult, _ := resultPromise.Await() // finalResult is 84
```

## Index

- [func Await\[T any\]\(p \*Promise\[T\]\) \(T, error\)](<#Await>)
- [type Promise](<#Promise>)
  - [func Async\[T any\]\(f func\(\) \(T, error\)\) \*Promise\[T\]](<#Async>)
  - [func New\[T any\]\(executor func\(resolve func\(T\), reject func\(error\)\)\) \*Promise\[T\]](<#New>)
  - [func \(p \*Promise\[T\]\) Await\(\) \(T, error\)](<#Promise[T].Await>)
  - [func \(p \*Promise\[T\]\) Catch\(onRejected func\(error\) \(T, error\)\) \*Promise\[T\]](<#Promise[T].Catch>)
  - [func \(p \*Promise\[T\]\) Finally\(onFinally func\(\)\) \*Promise\[T\]](<#Promise[T].Finally>)
  - [func \(p \*Promise\[T\]\) Reject\(err error\)](<#Promise[T].Reject>)
  - [func \(p \*Promise\[T\]\) Resolve\(value T\)](<#Promise[T].Resolve>)
  - [func \(p \*Promise\[T\]\) Then\(onFulfilled func\(T\) T\) \*Promise\[T\]](<#Promise[T].Then>)
  - [func \(p \*Promise\[T\]\) ThenWithPromise\(onFulfilled func\(T\) \*Promise\[T\]\) \*Promise\[T\]](<#Promise[T].ThenWithPromise>)


<a name="Await"></a>
## func [Await](<https://github.com/goexts/generic/blob/main/promise/promise.go#L192>)

```go
func Await[T any](p *Promise[T]) (T, error)
```

Await is a standalone function that waits for a promise to be settled. It is a functional equivalent of the p.Await\(\) method.

<a name="Promise"></a>
## type [Promise](<https://github.com/goexts/generic/blob/main/promise/promise.go#L11-L17>)

Promise represents the eventual completion \(or failure\) of an asynchronous operation and its resulting value. It is a generic, type\-safe implementation inspired by the JavaScript Promise API.

```go
type Promise[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="Async"></a>
### func [Async](<https://github.com/goexts/generic/blob/main/promise/promise.go#L179>)

```go
func Async[T any](f func() (T, error)) *Promise[T]
```

Async is a helper function that wraps a function returning \(T, error\) into a new Promise. This is useful for converting existing functions into promise\-based asynchronous operations.

<a name="New"></a>
### func [New](<https://github.com/goexts/generic/blob/main/promise/promise.go#L22>)

```go
func New[T any](executor func(resolve func(T), reject func(error))) *Promise[T]
```

New creates a new Promise. The provided executor function is executed in a new goroutine. The executor receives \`resolve\` and \`reject\` functions to control the promise's outcome.

<a name="Promise[T].Await"></a>
### func \(\*Promise\[T\]\) [Await](<https://github.com/goexts/generic/blob/main/promise/promise.go#L72>)

```go
func (p *Promise[T]) Await() (T, error)
```

Await blocks until the promise is settled and returns the resulting value and error. It is the primary way to get the result of a promise.

<a name="Promise[T].Catch"></a>
### func \(\*Promise\[T\]\) [Catch](<https://github.com/goexts/generic/blob/main/promise/promise.go#L124>)

```go
func (p *Promise[T]) Catch(onRejected func(error) (T, error)) *Promise[T]
```

Catch attaches a callback that executes when the promise is rejected. It allows for error handling and recovery. The onRejected callback can return a new value to fulfill the promise, or a new error to continue the rejection chain.

<a name="Promise[T].Finally"></a>
### func \(\*Promise\[T\]\) [Finally](<https://github.com/goexts/generic/blob/main/promise/promise.go#L149>)

```go
func (p *Promise[T]) Finally(onFinally func()) *Promise[T]
```

Finally attaches a callback that executes when the promise is settled \(either fulfilled or rejected\). It is useful for cleanup logic. The returned promise will be settled with the same value or error as the original promise, after onFinally has completed.

<a name="Promise[T].Reject"></a>
### func \(\*Promise\[T\]\) [Reject](<https://github.com/goexts/generic/blob/main/promise/promise.go#L57>)

```go
func (p *Promise[T]) Reject(err error)
```

Reject rejects the promise with an error. If the promise is already settled, this call is ignored.

<a name="Promise[T].Resolve"></a>
### func \(\*Promise\[T\]\) [Resolve](<https://github.com/goexts/generic/blob/main/promise/promise.go#L42>)

```go
func (p *Promise[T]) Resolve(value T)
```

Resolve fulfills the promise with a value. If the promise is already settled, this call is ignored.

<a name="Promise[T].Then"></a>
### func \(\*Promise\[T\]\) [Then](<https://github.com/goexts/generic/blob/main/promise/promise.go#L80>)

```go
func (p *Promise[T]) Then(onFulfilled func(T) T) *Promise[T]
```

Then attaches a callback that executes when the promise is fulfilled. It returns a new promise that resolves with the result of the onFulfilled callback. If the original promise is rejected, the new promise is rejected with the same error.

<a name="Promise[T].ThenWithPromise"></a>
### func \(\*Promise\[T\]\) [ThenWithPromise](<https://github.com/goexts/generic/blob/main/promise/promise.go#L98>)

```go
func (p *Promise[T]) ThenWithPromise(onFulfilled func(T) *Promise[T]) *Promise[T]
```

ThenWithPromise is like Then, but the callback returns a new Promise. This allows for chaining of asynchronous operations.

# ptr

```go
import "github.com/goexts/generic/ptr"
```

Package ptr provides generic utility functions for working with pointers. It simplifies common operations such as creating a pointer from a literal value or safely dereferencing a pointer that might be nil.

This package is particularly useful in contexts where you need to assign a pointer to a struct field, but you only have a literal value \(e.g., a string, an integer, or a boolean\).

Example:

```
// Without ptr package
port := 8080
config := &ServerConfig{
	Port: &port,
}

// With ptr package
config := &ServerConfig{
	Port: ptr.Of(8080), // Cleaner and more concise
}
```

## Index

- [func Of\[T any\]\(v T\) \*T](<#Of>)
- [func To\[T any\]\(v any\) \*T](<#To>)
- [func ToVal\[T any\]\(v any\) T](<#ToVal>)
- [func Val\[T any\]\(v \*T\) T](<#Val>)


<a name="Of"></a>
## func [Of](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L10>)

```go
func Of[T any](v T) *T
```

Of returns a pointer to the given value v. This is a convenient helper for creating a pointer to a literal or a variable in a single expression, often used for struct field initialization.

Example:

```
config := &MyConfig{ Timeout: ptr.Of(5*time.Second) }
```

<a name="To"></a>
## func [To](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L30>)

```go
func To[T any](v any) *T
```

To converts an \`any\` value to a pointer of type \*T. It handles three cases:

1. If v is of type T, it returns a pointer to it \(&v\).
2. If v is already of type \*T, it returns v directly.
3. Otherwise, it returns a new pointer to a zero value of T.

<a name="ToVal"></a>
## func [ToVal](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L47>)

```go
func ToVal[T any](v any) T
```

ToVal converts an \`any\` value to a value of type T. It handles three cases:

1. If v is a non\-nil pointer of type \*T, it returns the dereferenced value.
2. If v is of type T, it returns v directly.
3. Otherwise, it returns the zero value of T.

<a name="Val"></a>
## func [Val](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L17>)

```go
func Val[T any](v *T) T
```

Val returns the value that the pointer v points to. If the pointer is nil, it safely returns the zero value of the type T. This avoids a panic when dereferencing a nil pointer.

# res

```go
import "github.com/goexts/generic/res"
```

Package res provides a generic, Rust\-inspired \`Result\[T\]\` type for expressive error handling.

### Core Concept

A \`Result\[T\]\` is a type that represents either a success \(containing a value of type T\) or a failure \(containing an error\). It is a monadic type that allows for chaining operations in a clean, readable way, especially in data processing pipelines where each step can fail.

This pattern provides an alternative to returning \`\(value, error\)\` pairs at each step. Instead of checking for an error after every call, you can chain methods and handle the final result once.

### Warning: Paradigm and Trade\\\-offs

While powerful, the \`Result\` type introduces a paradigm that is not idiomatic Go. Standard Go error handling \(returning \`\(T, error\)\`\) is simpler and more direct for most use cases. The \`Result\` type is best suited for specific scenarios like complex data transformation chains.

Be especially cautious with methods like \`Unwrap\` and \`Expect\`, which panic on an \`Err\` value. They should only be used when an error is considered a fatal, unrecoverable bug, similar to the \`must\` package.

### Example

```
// A function that returns a Result
func ParseInt(s string) res.Result[int] {
	n, err := strconv.Atoi(s)
	return res.Of(n, err)
}

// Chaining operations
result := ParseInt("123").Unwrap() // result is 123

// Safely handling the result
val, ok := ParseInt("not-a-number").Ok()
// val is 0, ok is false
```

## Index

- [func Or\[T any\]\(v T, err error, defaultValue T\) T](<#Or>)
- [func OrZero\[T any\]\(v T, err error\) T](<#OrZero>)
- [type Result](<#Result>)
  - [func Err\[T any\]\(err error\) Result\[T\]](<#Err>)
  - [func Of\[T any\]\(value T, err error\) Result\[T\]](<#Of>)
  - [func Ok\[T any\]\(value T\) Result\[T\]](<#Ok>)
  - [func \(r Result\[T\]\) Err\(\) error](<#Result[T].Err>)
  - [func \(r Result\[T\]\) Expect\(message string\) T](<#Result[T].Expect>)
  - [func \(r Result\[T\]\) IsErr\(\) bool](<#Result[T].IsErr>)
  - [func \(r Result\[T\]\) IsOk\(\) bool](<#Result[T].IsOk>)
  - [func \(r Result\[T\]\) Ok\(\) \(T, bool\)](<#Result[T].Ok>)
  - [func \(r Result\[T\]\) Unwrap\(\) T](<#Result[T].Unwrap>)
  - [func \(r Result\[T\]\) UnwrapOr\(defaultValue T\) T](<#Result[T].UnwrapOr>)


<a name="Or"></a>
## func [Or](<https://github.com/goexts/generic/blob/main/res/res.go#L87>)

```go
func Or[T any](v T, err error, defaultValue T) T
```

Or is a utility function that simplifies handling of \(value, error\) returns. It returns the value if err is nil, otherwise it returns the provided default value.

<a name="OrZero"></a>
## func [OrZero](<https://github.com/goexts/generic/blob/main/res/res.go#L96>)

```go
func OrZero[T any](v T, err error) T
```

OrZero is a utility function that simplifies handling of \(value, error\) returns. It returns the value if err is nil, otherwise it returns the zero value of the type.

<a name="Result"></a>
## type [Result](<https://github.com/goexts/generic/blob/main/res/res.go#L9-L12>)

Result is a type that represents either a success \(containing a value of type T\) or a failure \(containing an error\). It is a monadic type that allows for chaining operations in a clean, readable way. See the package documentation for more details and usage examples.

```go
type Result[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="Err"></a>
### func [Err](<https://github.com/goexts/generic/blob/main/res/res.go#L20>)

```go
func Err[T any](err error) Result[T]
```

Err creates a new failed Result containing the given error.

<a name="Of"></a>
### func [Of](<https://github.com/goexts/generic/blob/main/res/res.go#L27>)

```go
func Of[T any](value T, err error) Result[T]
```

Of converts a standard Go \(value, error\) pair into a Result. If err is not nil, it returns an Err result; otherwise, it returns an Ok result.

<a name="Ok"></a>
### func [Ok](<https://github.com/goexts/generic/blob/main/res/res.go#L15>)

```go
func Ok[T any](value T) Result[T]
```

Ok creates a new successful Result containing the given value.

<a name="Result[T].Err"></a>
### func \(Result\[T\]\) [Err](<https://github.com/goexts/generic/blob/main/res/res.go#L81>)

```go
func (r Result[T]) Err() error
```

Err returns the contained error, or nil if the result is Ok.

<a name="Result[T].Expect"></a>
### func \(Result\[T\]\) [Expect](<https://github.com/goexts/generic/blob/main/res/res.go#L67>)

```go
func (r Result[T]) Expect(message string) T
```

Expect returns the contained Ok value. It panics with a custom message if the result is an Err. This is similar to Unwrap but provides a more context\-specific panic message.

<a name="Result[T].IsErr"></a>
### func \(Result\[T\]\) [IsErr](<https://github.com/goexts/generic/blob/main/res/res.go#L40>)

```go
func (r Result[T]) IsErr() bool
```

IsErr returns true if the result is an Err \(i.e., contains an error\).

<a name="Result[T].IsOk"></a>
### func \(Result\[T\]\) [IsOk](<https://github.com/goexts/generic/blob/main/res/res.go#L35>)

```go
func (r Result[T]) IsOk() bool
```

IsOk returns true if the result is Ok \(i.e., does not contain an error\).

<a name="Result[T].Ok"></a>
### func \(Result\[T\]\) [Ok](<https://github.com/goexts/generic/blob/main/res/res.go#L76>)

```go
func (r Result[T]) Ok() (T, bool)
```

Ok returns the contained value and a boolean indicating if the result was Ok. This provides a safe, idiomatic Go way to access the value.

<a name="Result[T].Unwrap"></a>
### func \(Result\[T\]\) [Unwrap](<https://github.com/goexts/generic/blob/main/res/res.go#L48>)

```go
func (r Result[T]) Unwrap() T
```

Unwrap returns the contained Ok value. It panics if the result is an Err. Because this function may panic, it should only be used when the caller is certain that the result is Ok, or when a panic is the desired behavior. See also: Expect, UnwrapOr.

<a name="Result[T].UnwrapOr"></a>
### func \(Result\[T\]\) [UnwrapOr](<https://github.com/goexts/generic/blob/main/res/res.go#L57>)

```go
func (r Result[T]) UnwrapOr(defaultValue T) T
```

UnwrapOr returns the contained Ok value or a provided default value. It is a safe way to access the value without panicking.

# set

```go
import "github.com/goexts/generic/set"
```

Package set provides a collection of generic, stateless functions for performing set\-like operations on standard Go slices.

### Core Philosophy

Instead of introducing a new \`Set\` data structure, this package provides utilities that treat slices as sets. This approach offers several advantages:

- It is lightweight and requires no new types to learn.
- It integrates seamlessly with the rest of the Go ecosystem, which heavily relies on slices.
- It promotes a functional style of programming.

The functions in this package operate on slices of any \`comparable\` type.

### Example

```
setA := []int{1, 2, 3, 4}
setB := []int{3, 4, 5, 6}

// Calculate the union of the two sets
union := set.Union(setA, setB) // Result (order not guaranteed): [1, 2, 3, 4, 5, 6]

// Calculate the intersection of the two sets
intersection := set.Intersection(setA, setB) // Result (order not guaranteed): [3, 4]

// Calculate the difference (elements in B but not in A)
difference := set.Difference(setA, setB) // Result (order not guaranteed): [5, 6]

// Remove duplicates from a slice
unique := set.Unique([]string{"a", "b", "a", "c", "b"}) // Result (order not guaranteed): ["a", "b", "c"]
```

## Index

- [func Contains\[T comparable\]\(s \[\]T, e T\) bool](<#Contains>)
- [func Difference\[T comparable\]\(s1, s2 \[\]T\) \[\]T](<#Difference>)
- [func Exists\[T any\]\(s \[\]T, f func\(T\) bool\) bool](<#Exists>)
- [func Intersection\[T comparable\]\(s1, s2 \[\]T\) \[\]T](<#Intersection>)
- [func Union\[T comparable\]\(s1, s2 \[\]T\) \[\]T](<#Union>)
- [func Unique\[T comparable\]\(s \[\]T\) \[\]T](<#Unique>)


<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/set/set.go#L5>)

```go
func Contains[T comparable](s []T, e T) bool
```

Contains checks if a slice \`s\` contains the element \`e\`. The check is performed using the equality operator \(==\).

<a name="Difference"></a>
## func [Difference](<https://github.com/goexts/generic/blob/main/set/set.go#L77>)

```go
func Difference[T comparable](s1, s2 []T) []T
```

Difference returns a new slice containing the elements from s2 that are not present in s1 \(s2 \- s1\). The order of elements in the returned slice is not guaranteed.

<a name="Exists"></a>
## func [Exists](<https://github.com/goexts/generic/blob/main/set/set.go#L15>)

```go
func Exists[T any](s []T, f func(T) bool) bool
```

Exists checks if at least one element in a slice \`s\` satisfies the predicate \`f\`.

<a name="Intersection"></a>
## func [Intersection](<https://github.com/goexts/generic/blob/main/set/set.go#L59>)

```go
func Intersection[T comparable](s1, s2 []T) []T
```

Intersection returns a new slice containing only the elements that exist in both s1 and s2. The order of elements in the returned slice is not guaranteed.

<a name="Union"></a>
## func [Union](<https://github.com/goexts/generic/blob/main/set/set.go#L41>)

```go
func Union[T comparable](s1, s2 []T) []T
```

Union returns a new slice containing the unique elements present in either s1 or s2. The order of elements in the returned slice is not guaranteed.

<a name="Unique"></a>
## func [Unique](<https://github.com/goexts/generic/blob/main/set/set.go#L26>)

```go
func Unique[T comparable](s []T) []T
```

Unique returns a new slice containing only the unique elements of the input slice \`s\`. The order of elements in the returned slice is not guaranteed.

# slices

```go
import "github.com/goexts/generic/slices"
```

Package slices provides a rich set of generic functions for common operations on slices of any element type.

This package is a generated adapter and mirrors the public API of the standard Go experimental package \`golang.org/x/exp/slices\`. It offers a convenient way to access these common utilities for searching, sorting, comparing, and manipulating slices.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`slices\` package.

Example \(Sorting and Searching\):

```
numbers := []int{3, 1, 4, 1, 5, 9}

// Check if a slice contains a value
_ = slices.Contains(numbers, 5) // true

// Sort the slice in place
slices.Sort(numbers)
// numbers is now [1, 1, 3, 4, 5, 9]

// Find the index of a value in a sorted slice
idx, found := slices.BinarySearch(numbers, 4)
// idx is 3, found is true
```

Package slices implements the functions, types, and interfaces for the module.

Package slices contains generated code by adptool.

Package slices implements the functions, types, and interfaces for the module.

## Index

- [Variables](<#variables>)
- [func Append\[T \~\[\]S, S any\]\(arr T, v S\) \(T, int\)](<#Append>)
- [func BinarySearch\[S \~\[\]E, E constraints.Ordered\]\(x S, target E\) \(int, bool\)](<#BinarySearch>)
- [func BinarySearchFunc\[S \~\[\]E, E, T any\]\(x S, target T, cmp func\(E, T\) int\) \(int, bool\)](<#BinarySearchFunc>)
- [func Clip\[S \~\[\]E, E any\]\(s S\) S](<#Clip>)
- [func Clone\[S \~\[\]E, E any\]\(s S\) S](<#Clone>)
- [func Compact\[S \~\[\]E, E comparable\]\(s S\) S](<#Compact>)
- [func CompactFunc\[S \~\[\]E, E any\]\(s S, eq func\(E, E\) bool\) S](<#CompactFunc>)
- [func Compare\[S \~\[\]E, E constraints.Ordered\]\(s1, s2 S\) int](<#Compare>)
- [func CompareFunc\[S1 \~\[\]E1, S2 \~\[\]E2, E1, E2 any\]\(s1 S1, s2 S2, cmp func\(E1, E2\) int\) int](<#CompareFunc>)
- [func Contains\[S \~\[\]E, E comparable\]\(s S, v E\) bool](<#Contains>)
- [func ContainsFunc\[S \~\[\]E, E any\]\(s S, f func\(E\) bool\) bool](<#ContainsFunc>)
- [func CopyAt\[T \~\[\]S, S any\]\(s, t T, i int\) T](<#CopyAt>)
- [func Count\[T \~\[\]S, S E\]\(s, sub T\) int](<#Count>)
- [func CountArray\[T \~\[\]S, S E\]\(ss T, s S\) int](<#CountArray>)
- [func Cut\[T \~\[\]S, S E\]\(s, sep T\) \(before, after T, found bool\)](<#Cut>)
- [func Delete\[S \~\[\]E, E any\]\(s S, i, j int\) S](<#Delete>)
- [func DeleteFunc\[S \~\[\]E, E any\]\(s S, del func\(E\) bool\) S](<#DeleteFunc>)
- [func Equal\[S \~\[\]E, E comparable\]\(s1, s2 S\) bool](<#Equal>)
- [func EqualFunc\[S1 \~\[\]E1, S2 \~\[\]E2, E1, E2 any\]\(s1 S1, s2 S2, eq func\(E1, E2\) bool\) bool](<#EqualFunc>)
- [func Filter\[T \~\[\]S, S any\]\(s T, f func\(S\) bool\) T](<#Filter>)
- [func FilterExcluded\[S \~\[\]E, E comparable\]\(s S, excludes S\) S](<#FilterExcluded>)
- [func FilterIncluded\[S \~\[\]E, E comparable\]\(s S, includes S\) S](<#FilterIncluded>)
- [func Grow\[S \~\[\]E, E any\]\(s S, n int\) S](<#Grow>)
- [func Index\[S \~\[\]E, E comparable\]\(s S, v E\) int](<#Index>)
- [func IndexFunc\[S \~\[\]E, E any\]\(s S, f func\(E\) bool\) int](<#IndexFunc>)
- [func IndexSlice\[T \~\[\]S, S E\]\(s, substr T\) int](<#IndexSlice>)
- [func Insert\[S \~\[\]E, E any\]\(s S, i int, v ...E\) S](<#Insert>)
- [func InsertWith\[T \~\[\]S, S any\]\(s T, v S, fn func\(a, b S\) bool\) T](<#InsertWith>)
- [func IsSorted\[S \~\[\]E, E constraints.Ordered\]\(x S\) bool](<#IsSorted>)
- [func IsSortedFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\) bool](<#IsSortedFunc>)
- [func Join\[T \~\[\]S, S any\]\(s \[\]T, sep T\) T](<#Join>)
- [func LastIndexSlice\[T \~\[\]S, S E\]\(s, sep T\) int](<#LastIndexSlice>)
- [func Map\[S, T any\]\(s \[\]S, f func\(S\) T\) \[\]T](<#Map>)
- [func Max\[S \~\[\]E, E constraints.Ordered\]\(x S\) E](<#Max>)
- [func MaxFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\) E](<#MaxFunc>)
- [func Min\[S \~\[\]E, E constraints.Ordered\]\(x S\) E](<#Min>)
- [func MinFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\) E](<#MinFunc>)
- [func OverWithError\[S any\]\(s \[\]S, err error\) func\(func\(int, S\) bool\)](<#OverWithError>)
- [func Read\[T \~\[\]S, S any\]\(arr T, offset int, limit int\) T](<#Read>)
- [func Reduce\[S, T any\]\(s \[\]S, initial T, f func\(T, S\) T\) T](<#Reduce>)
- [func RemoveWith\[T \~\[\]S, S any\]\(s T, fn func\(a S\) bool\) T](<#RemoveWith>)
- [func Repeat\[T \~\[\]S, S any\]\(b T, count int\) T](<#Repeat>)
- [func Replace\[S \~\[\]E, E any\]\(s S, i, j int, v ...E\) S](<#Replace>)
- [func Reverse\[S \~\[\]E, E any\]\(s S\)](<#Reverse>)
- [func Sort\[S \~\[\]E, E constraints.Ordered\]\(x S\)](<#Sort>)
- [func SortFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\)](<#SortFunc>)
- [func SortStableFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\)](<#SortStableFunc>)
- [func Split\[T \~\[\]S, S E\]\(s, sep T\) \[\]T](<#Split>)
- [func Transform\[TS \~\[\]S, S any, T any\]\(s TS, f func\(S\) \(T, bool\)\) \[\]T](<#Transform>)
- [func Unique\[T \~\[\]S, S E\]\(s T\) T](<#Unique>)
- [type E](<#E>)


## Variables

<a name="ErrWrongIndex"></a>

```go
var (
    // ErrWrongIndex is an error when index is out of range
    ErrWrongIndex = errors.New("slices.Array: wrong index")
)
```

<a name="Append"></a>
## func [Append](<https://github.com/goexts/generic/blob/main/slices/slice.go#L18>)

```go
func Append[T ~[]S, S any](arr T, v S) (T, int)
```

Append appends the element v to the end of Array\[S\] s.

<a name="BinarySearch"></a>
## func [BinarySearch](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L13>)

```go
func BinarySearch[S ~[]E, E constraints.Ordered](x S, target E) (int, bool)
```



<a name="BinarySearchFunc"></a>
## func [BinarySearchFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L17>)

```go
func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)
```



<a name="Clip"></a>
## func [Clip](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L21>)

```go
func Clip[S ~[]E, E any](s S) S
```



<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L25>)

```go
func Clone[S ~[]E, E any](s S) S
```



<a name="Compact"></a>
## func [Compact](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L29>)

```go
func Compact[S ~[]E, E comparable](s S) S
```



<a name="CompactFunc"></a>
## func [CompactFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L33>)

```go
func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S
```



<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L37>)

```go
func Compare[S ~[]E, E constraints.Ordered](s1, s2 S) int
```



<a name="CompareFunc"></a>
## func [CompareFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L41>)

```go
func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int
```



<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L45>)

```go
func Contains[S ~[]E, E comparable](s S, v E) bool
```



<a name="ContainsFunc"></a>
## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L49>)

```go
func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool
```



<a name="CopyAt"></a>
## func [CopyAt](<https://github.com/goexts/generic/blob/main/slices/slice.go#L26>)

```go
func CopyAt[T ~[]S, S any](s, t T, i int) T
```

CopyAt copies the elements from t into s at the specified index. It panics if the index is negative. If the required length is greater than the length of s, s is grown to accommodate the new elements.

<a name="Count"></a>
## func [Count](<https://github.com/goexts/generic/blob/main/slices/slice.go#L44>)

```go
func Count[T ~[]S, S E](s, sub T) int
```

Count counts the number of non\-overlapping instances of substr in s. If substr is an empty Array, Count returns 1 \+ the number of Unicode code points in s.

<a name="CountArray"></a>
## func [CountArray](<https://github.com/goexts/generic/blob/main/slices/slice.go#L65>)

```go
func CountArray[T ~[]S, S E](ss T, s S) int
```

CountArray counts the number of non\-overlapping instances of c in s.

<a name="Cut"></a>
## func [Cut](<https://github.com/goexts/generic/blob/main/slices/slice.go#L79>)

```go
func Cut[T ~[]S, S E](s, sep T) (before, after T, found bool)
```

Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, nil, false.

<a name="Delete"></a>
## func [Delete](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L53>)

```go
func Delete[S ~[]E, E any](s S, i, j int) S
```



<a name="DeleteFunc"></a>
## func [DeleteFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L57>)

```go
func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S
```



<a name="Equal"></a>
## func [Equal](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L61>)

```go
func Equal[S ~[]E, E comparable](s1, s2 S) bool
```



<a name="EqualFunc"></a>
## func [EqualFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L65>)

```go
func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool
```



<a name="Filter"></a>
## func [Filter](<https://github.com/goexts/generic/blob/main/slices/slice.go#L87>)

```go
func Filter[T ~[]S, S any](s T, f func(S) bool) T
```

Filter returns a new slice containing all elements of s for which f\(s\) is true.

<a name="FilterExcluded"></a>
## func [FilterExcluded](<https://github.com/goexts/generic/blob/main/slices/slice.go#L139>)

```go
func FilterExcluded[S ~[]E, E comparable](s S, excludes S) S
```

FilterExcluded returns a new slice containing all elements of s that are not present in excludes. The order of elements in the result is the same as in the original slice. The function is optimized for small to medium\-sized exclude lists. For very large exclude lists, consider using a map for better performance.

<a name="FilterIncluded"></a>
## func [FilterIncluded](<https://github.com/goexts/generic/blob/main/slices/slice.go#L104>)

```go
func FilterIncluded[S ~[]E, E comparable](s S, includes S) S
```

FilterIncluded returns a new slice containing all elements of s that are present in includes. The order of elements in the result is the same as in the original slice. The function is optimized for small to medium\-sized include lists. For very large include lists, consider using a map for better performance.

<a name="Grow"></a>
## func [Grow](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L69>)

```go
func Grow[S ~[]E, E any](s S, n int) S
```



<a name="Index"></a>
## func [Index](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L73>)

```go
func Index[S ~[]E, E comparable](s S, v E) int
```



<a name="IndexFunc"></a>
## func [IndexFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L77>)

```go
func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int
```



<a name="IndexSlice"></a>
## func [IndexSlice](<https://github.com/goexts/generic/blob/main/slices/slice.go#L174>)

```go
func IndexSlice[T ~[]S, S E](s, substr T) int
```

IndexSlice returns the index of the first instance of substr in s, or \-1 if substr is not present in s. It works similarly to strings.Index but operates on slices of comparable elements. If substr is an empty slice, it returns 0. The time complexity is O\(n\*m\) where n is the length of s and m is the length of substr.

<a name="Insert"></a>
## func [Insert](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L81>)

```go
func Insert[S ~[]E, E any](s S, i int, v ...E) S
```



<a name="InsertWith"></a>
## func [InsertWith](<https://github.com/goexts/generic/blob/main/slices/slice.go#L198>)

```go
func InsertWith[T ~[]S, S any](s T, v S, fn func(a, b S) bool) T
```

InsertWith inserts v into s at the first index where fn\(a, b\) is true.

<a name="IsSorted"></a>
## func [IsSorted](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L85>)

```go
func IsSorted[S ~[]E, E constraints.Ordered](x S) bool
```



<a name="IsSortedFunc"></a>
## func [IsSortedFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L89>)

```go
func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool
```



<a name="Join"></a>
## func [Join](<https://github.com/goexts/generic/blob/main/slices/slice.go#L212>)

```go
func Join[T ~[]S, S any](s []T, sep T) T
```

Join concatenates the elements of its first argument to create a single Array\[S\]. The separator Array\[S\] sep is placed between elements in the resulting Array\[S\].

<a name="LastIndexSlice"></a>
## func [LastIndexSlice](<https://github.com/goexts/generic/blob/main/slices/slice.go#L235>)

```go
func LastIndexSlice[T ~[]S, S E](s, sep T) int
```

LastIndexSlice returns the index of the last instance of substr in s, or \-1 if substr is not present in s.

<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/slices/slice.go#L259>)

```go
func Map[S, T any](s []S, f func(S) T) []T
```

Map transforms a slice of one type to a slice of another type by applying a function to each element.

<a name="Max"></a>
## func [Max](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L93>)

```go
func Max[S ~[]E, E constraints.Ordered](x S) E
```



<a name="MaxFunc"></a>
## func [MaxFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L97>)

```go
func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E
```



<a name="Min"></a>
## func [Min](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L101>)

```go
func Min[S ~[]E, E constraints.Ordered](x S) E
```



<a name="MinFunc"></a>
## func [MinFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L105>)

```go
func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E
```



<a name="OverWithError"></a>
## func [OverWithError](<https://github.com/goexts/generic/blob/main/slices/slice.go#L273>)

```go
func OverWithError[S any](s []S, err error) func(func(int, S) bool)
```

OverWithError returns an iterator function for a slice that may have an associated error. The returned iterator will only yield values if the provided error is nil and the slice is not empty. This is useful for chaining operations that can fail.

<a name="Read"></a>
## func [Read](<https://github.com/goexts/generic/blob/main/slices/slice.go#L288>)

```go
func Read[T ~[]S, S any](arr T, offset int, limit int) T
```

Read returns a slice of the Array\[S\] s beginning at offset and length limit. If offset or limit is negative, it is treated as if it were zero.

<a name="Reduce"></a>
## func [Reduce](<https://github.com/goexts/generic/blob/main/slices/slice.go#L300>)

```go
func Reduce[S, T any](s []S, initial T, f func(T, S) T) T
```

Reduce aggregates all elements of a slice into a single value by applying a function. It iterates through the slice, applying the function 'f' to an accumulator and the current element.

<a name="RemoveWith"></a>
## func [RemoveWith](<https://github.com/goexts/generic/blob/main/slices/slice.go#L309>)

```go
func RemoveWith[T ~[]S, S any](s T, fn func(a S) bool) T
```

RemoveWith removes the first index where fn\(a, b\) is true.

<a name="Repeat"></a>
## func [Repeat](<https://github.com/goexts/generic/blob/main/slices/slice.go#L323>)

```go
func Repeat[T ~[]S, S any](b T, count int) T
```

Repeat returns a new Array\[S\] consisting of count copies of the Array\[S\] s.

It panics if count is negative or if the result of \(len\(s\) \* count\) overflows.

<a name="Replace"></a>
## func [Replace](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L109>)

```go
func Replace[S ~[]E, E any](s S, i, j int, v ...E) S
```



<a name="Reverse"></a>
## func [Reverse](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L113>)

```go
func Reverse[S ~[]E, E any](s S)
```



<a name="Sort"></a>
## func [Sort](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L117>)

```go
func Sort[S ~[]E, E constraints.Ordered](x S)
```



<a name="SortFunc"></a>
## func [SortFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L121>)

```go
func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)
```



<a name="SortStableFunc"></a>
## func [SortStableFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L125>)

```go
func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int)
```



<a name="Split"></a>
## func [Split](<https://github.com/goexts/generic/blob/main/slices/slice.go#L348>)

```go
func Split[T ~[]S, S E](s, sep T) []T
```

Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators.

<a name="Transform"></a>
## func [Transform](<https://github.com/goexts/generic/blob/main/slices/slice.go#L358>)

```go
func Transform[TS ~[]S, S any, T any](s TS, f func(S) (T, bool)) []T
```

Transform combines the behavior of mapping and filtering a slice. It iterates over each element of the input slice \`s\`, applies the function \`f\`, and if the function returns \`true\`, the transformed element is included in the result.

<a name="Unique"></a>
## func [Unique](<https://github.com/goexts/generic/blob/main/slices/slice.go#L373>)

```go
func Unique[T ~[]S, S E](s T) T
```

Unique returns a new slice with duplicate elements removed. The order of the first occurrence of each element is preserved.

<a name="E"></a>
## type [E](<https://github.com/goexts/generic/blob/main/slices/slice.go#L10>)

E is comparable type of slice element

```go
type E = comparable
```

# strings

```go
import "github.com/goexts/generic/strings"
```

Package strings provides a collection of functions for string manipulation.

This package is a generated adapter and mirrors the public API of the standard Go library's \`strings\` package. It offers a convenient way to access the rich set of standard string utilities.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`strings\` package.

Example:

```
addr := "[INFO] This is a log message."

// Check for a prefix
_ = strings.HasPrefix(addr, "[INFO]") // true

// Trim the prefix
msg := strings.TrimPrefix(addr, "[INFO] ")
// msg is "This is a log message."
```

Package strings implements the functions, types, and interfaces for the module.

Package strings contains generated code by adptool.

Package strings implements the functions, types, and interfaces for the module.

## Index

- [func Clone\(s string\) string](<#Clone>)
- [func Compare\(a, b string\) int](<#Compare>)
- [func Contains\(s, substr string\) bool](<#Contains>)
- [func ContainsAny\(s, chars string\) bool](<#ContainsAny>)
- [func ContainsFunc\(s string, f func\(rune\) bool\) bool](<#ContainsFunc>)
- [func ContainsRune\(s string, r rune\) bool](<#ContainsRune>)
- [func Count\(s, substr string\) int](<#Count>)
- [func Cut\(s, sep string\) \(before, after string, found bool\)](<#Cut>)
- [func CutPrefix\(s, prefix string\) \(after string, found bool\)](<#CutPrefix>)
- [func CutSuffix\(s, suffix string\) \(before string, found bool\)](<#CutSuffix>)
- [func EqualFold\(s, t string\) bool](<#EqualFold>)
- [func Fields\(s string\) \[\]string](<#Fields>)
- [func FieldsFunc\(s string, f func\(rune\) bool\) \[\]string](<#FieldsFunc>)
- [func FieldsFuncSeq\(s string, f func\(rune\) bool\) iter.Seq\[string\]](<#FieldsFuncSeq>)
- [func FieldsSeq\(s string\) iter.Seq\[string\]](<#FieldsSeq>)
- [func HasPrefix\(s, prefix string\) bool](<#HasPrefix>)
- [func HasSuffix\(s, suffix string\) bool](<#HasSuffix>)
- [func Index\(s, substr string\) int](<#Index>)
- [func IndexAny\(s, chars string\) int](<#IndexAny>)
- [func IndexByte\(s string, c byte\) int](<#IndexByte>)
- [func IndexFunc\(s string, f func\(rune\) bool\) int](<#IndexFunc>)
- [func IndexRune\(s string, r rune\) int](<#IndexRune>)
- [func Join\(elems \[\]string, sep string\) string](<#Join>)
- [func LastIndex\(s, substr string\) int](<#LastIndex>)
- [func LastIndexAny\(s, chars string\) int](<#LastIndexAny>)
- [func LastIndexByte\(s string, c byte\) int](<#LastIndexByte>)
- [func LastIndexFunc\(s string, f func\(rune\) bool\) int](<#LastIndexFunc>)
- [func Lines\(s string\) iter.Seq\[string\]](<#Lines>)
- [func Map\(mapping func\(rune\) rune, s string\) string](<#Map>)
- [func NewReader\(s string\) \*strings.Reader](<#NewReader>)
- [func NewReplacer\(oldnew ...string\) \*strings.Replacer](<#NewReplacer>)
- [func ParseOr\[T any\]\(s string, def ...T\) T](<#ParseOr>)
- [func Repeat\(s string, count int\) string](<#Repeat>)
- [func Replace\(s, old, new string, n int\) string](<#Replace>)
- [func ReplaceAll\(s, old, new string\) string](<#ReplaceAll>)
- [func Split\(s, sep string\) \[\]string](<#Split>)
- [func SplitAfter\(s, sep string\) \[\]string](<#SplitAfter>)
- [func SplitAfterN\(s, sep string, n int\) \[\]string](<#SplitAfterN>)
- [func SplitAfterSeq\(s, sep string\) iter.Seq\[string\]](<#SplitAfterSeq>)
- [func SplitN\(s, sep string, n int\) \[\]string](<#SplitN>)
- [func SplitSeq\(s, sep string\) iter.Seq\[string\]](<#SplitSeq>)
- [func Title\(s string\) string](<#Title>)
- [func ToLower\(s string\) string](<#ToLower>)
- [func ToLowerSpecial\(c unicode.SpecialCase, s string\) string](<#ToLowerSpecial>)
- [func ToTitle\(s string\) string](<#ToTitle>)
- [func ToTitleSpecial\(c unicode.SpecialCase, s string\) string](<#ToTitleSpecial>)
- [func ToUpper\(s string\) string](<#ToUpper>)
- [func ToUpperSpecial\(c unicode.SpecialCase, s string\) string](<#ToUpperSpecial>)
- [func ToValidUTF8\(s, replacement string\) string](<#ToValidUTF8>)
- [func Trim\(s, cutset string\) string](<#Trim>)
- [func TrimFunc\(s string, f func\(rune\) bool\) string](<#TrimFunc>)
- [func TrimLeft\(s, cutset string\) string](<#TrimLeft>)
- [func TrimLeftFunc\(s string, f func\(rune\) bool\) string](<#TrimLeftFunc>)
- [func TrimPrefix\(s, prefix string\) string](<#TrimPrefix>)
- [func TrimRight\(s, cutset string\) string](<#TrimRight>)
- [func TrimRightFunc\(s string, f func\(rune\) bool\) string](<#TrimRightFunc>)
- [func TrimSpace\(s string\) string](<#TrimSpace>)
- [func TrimSuffix\(s, suffix string\) string](<#TrimSuffix>)
- [type Builder](<#Builder>)
- [type Reader](<#Reader>)
- [type Replacer](<#Replacer>)


<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L20>)

```go
func Clone(s string) string
```



<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L24>)

```go
func Compare(a, b string) int
```



<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L28>)

```go
func Contains(s, substr string) bool
```



<a name="ContainsAny"></a>
## func [ContainsAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L32>)

```go
func ContainsAny(s, chars string) bool
```



<a name="ContainsFunc"></a>
## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L36>)

```go
func ContainsFunc(s string, f func(rune) bool) bool
```



<a name="ContainsRune"></a>
## func [ContainsRune](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L40>)

```go
func ContainsRune(s string, r rune) bool
```



<a name="Count"></a>
## func [Count](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L44>)

```go
func Count(s, substr string) int
```



<a name="Cut"></a>
## func [Cut](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L48>)

```go
func Cut(s, sep string) (before, after string, found bool)
```



<a name="CutPrefix"></a>
## func [CutPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L52>)

```go
func CutPrefix(s, prefix string) (after string, found bool)
```



<a name="CutSuffix"></a>
## func [CutSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L56>)

```go
func CutSuffix(s, suffix string) (before string, found bool)
```



<a name="EqualFold"></a>
## func [EqualFold](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L60>)

```go
func EqualFold(s, t string) bool
```



<a name="Fields"></a>
## func [Fields](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L64>)

```go
func Fields(s string) []string
```



<a name="FieldsFunc"></a>
## func [FieldsFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L68>)

```go
func FieldsFunc(s string, f func(rune) bool) []string
```



<a name="FieldsFuncSeq"></a>
## func [FieldsFuncSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L72>)

```go
func FieldsFuncSeq(s string, f func(rune) bool) iter.Seq[string]
```



<a name="FieldsSeq"></a>
## func [FieldsSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L76>)

```go
func FieldsSeq(s string) iter.Seq[string]
```



<a name="HasPrefix"></a>
## func [HasPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L80>)

```go
func HasPrefix(s, prefix string) bool
```



<a name="HasSuffix"></a>
## func [HasSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L84>)

```go
func HasSuffix(s, suffix string) bool
```



<a name="Index"></a>
## func [Index](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L88>)

```go
func Index(s, substr string) int
```



<a name="IndexAny"></a>
## func [IndexAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L92>)

```go
func IndexAny(s, chars string) int
```



<a name="IndexByte"></a>
## func [IndexByte](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L96>)

```go
func IndexByte(s string, c byte) int
```



<a name="IndexFunc"></a>
## func [IndexFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L100>)

```go
func IndexFunc(s string, f func(rune) bool) int
```



<a name="IndexRune"></a>
## func [IndexRune](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L104>)

```go
func IndexRune(s string, r rune) int
```



<a name="Join"></a>
## func [Join](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L108>)

```go
func Join(elems []string, sep string) string
```



<a name="LastIndex"></a>
## func [LastIndex](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L112>)

```go
func LastIndex(s, substr string) int
```



<a name="LastIndexAny"></a>
## func [LastIndexAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L116>)

```go
func LastIndexAny(s, chars string) int
```



<a name="LastIndexByte"></a>
## func [LastIndexByte](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L120>)

```go
func LastIndexByte(s string, c byte) int
```



<a name="LastIndexFunc"></a>
## func [LastIndexFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L124>)

```go
func LastIndexFunc(s string, f func(rune) bool) int
```



<a name="Lines"></a>
## func [Lines](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L128>)

```go
func Lines(s string) iter.Seq[string]
```



<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L132>)

```go
func Map(mapping func(rune) rune, s string) string
```



<a name="NewReader"></a>
## func [NewReader](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L136>)

```go
func NewReader(s string) *strings.Reader
```



<a name="NewReplacer"></a>
## func [NewReplacer](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L140>)

```go
func NewReplacer(oldnew ...string) *strings.Replacer
```



<a name="ParseOr"></a>
## func [ParseOr](<https://github.com/goexts/generic/blob/main/strings/parse.go#L15>)

```go
func ParseOr[T any](s string, def ...T) T
```

ParseOr converts a string to a specified type, with support for a default value. It supports all basic types \(int/uint variants, float, bool, string\) and JSON\-deserializable types. If parsing fails and a default value is provided, it returns the default value. If parsing fails and no default is provided, it panics.

<a name="Repeat"></a>
## func [Repeat](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L144>)

```go
func Repeat(s string, count int) string
```



<a name="Replace"></a>
## func [Replace](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L148>)

```go
func Replace(s, old, new string, n int) string
```



<a name="ReplaceAll"></a>
## func [ReplaceAll](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L152>)

```go
func ReplaceAll(s, old, new string) string
```



<a name="Split"></a>
## func [Split](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L156>)

```go
func Split(s, sep string) []string
```



<a name="SplitAfter"></a>
## func [SplitAfter](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L160>)

```go
func SplitAfter(s, sep string) []string
```



<a name="SplitAfterN"></a>
## func [SplitAfterN](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L164>)

```go
func SplitAfterN(s, sep string, n int) []string
```



<a name="SplitAfterSeq"></a>
## func [SplitAfterSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L168>)

```go
func SplitAfterSeq(s, sep string) iter.Seq[string]
```



<a name="SplitN"></a>
## func [SplitN](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L172>)

```go
func SplitN(s, sep string, n int) []string
```



<a name="SplitSeq"></a>
## func [SplitSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L176>)

```go
func SplitSeq(s, sep string) iter.Seq[string]
```



<a name="Title"></a>
## func [Title](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L180>)

```go
func Title(s string) string
```



<a name="ToLower"></a>
## func [ToLower](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L184>)

```go
func ToLower(s string) string
```



<a name="ToLowerSpecial"></a>
## func [ToLowerSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L188>)

```go
func ToLowerSpecial(c unicode.SpecialCase, s string) string
```



<a name="ToTitle"></a>
## func [ToTitle](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L192>)

```go
func ToTitle(s string) string
```



<a name="ToTitleSpecial"></a>
## func [ToTitleSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L196>)

```go
func ToTitleSpecial(c unicode.SpecialCase, s string) string
```



<a name="ToUpper"></a>
## func [ToUpper](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L200>)

```go
func ToUpper(s string) string
```



<a name="ToUpperSpecial"></a>
## func [ToUpperSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L204>)

```go
func ToUpperSpecial(c unicode.SpecialCase, s string) string
```



<a name="ToValidUTF8"></a>
## func [ToValidUTF8](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L208>)

```go
func ToValidUTF8(s, replacement string) string
```



<a name="Trim"></a>
## func [Trim](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L212>)

```go
func Trim(s, cutset string) string
```



<a name="TrimFunc"></a>
## func [TrimFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L216>)

```go
func TrimFunc(s string, f func(rune) bool) string
```



<a name="TrimLeft"></a>
## func [TrimLeft](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L220>)

```go
func TrimLeft(s, cutset string) string
```



<a name="TrimLeftFunc"></a>
## func [TrimLeftFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L224>)

```go
func TrimLeftFunc(s string, f func(rune) bool) string
```



<a name="TrimPrefix"></a>
## func [TrimPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L228>)

```go
func TrimPrefix(s, prefix string) string
```



<a name="TrimRight"></a>
## func [TrimRight](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L232>)

```go
func TrimRight(s, cutset string) string
```



<a name="TrimRightFunc"></a>
## func [TrimRightFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L236>)

```go
func TrimRightFunc(s string, f func(rune) bool) string
```



<a name="TrimSpace"></a>
## func [TrimSpace](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L240>)

```go
func TrimSpace(s string) string
```



<a name="TrimSuffix"></a>
## func [TrimSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L244>)

```go
func TrimSuffix(s, suffix string) string
```



<a name="Builder"></a>
## type [Builder](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L15>)



```go
type Builder = strings.Builder
```

<a name="Reader"></a>
## type [Reader](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L16>)



```go
type Reader = strings.Reader
```

<a name="Replacer"></a>
## type [Replacer](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L17>)



```go
type Replacer = strings.Replacer
```

# examples

```go
import "github.com/goexts/generic/docs/examples"
```

## Index



# bytes

```go
import "github.com/goexts/generic/slices/bytes"
```

Package bytes contains generated code by adptool.

Package bytes provides a rich set of functions for the manipulation of byte slices.

This package is a generated adapter and mirrors the public API of the standard Go library's \`bytes\` package. It offers a convenient way to access the rich set of standard byte slice utilities within the generic context of this library.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`bytes\` package.

Example:

```
data := []byte("  [INFO] message  ")

// Trim whitespace
trimmed := bytes.TrimSpace(data)
// trimmed is "[INFO] message"

// Check for a prefix
_ = bytes.HasPrefix(trimmed, []byte("[INFO]")) // true
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Clone\(b \[\]byte\) \[\]byte](<#Clone>)
- [func Compare\(a, b \[\]byte\) int](<#Compare>)
- [func Contains\(b, subslice \[\]byte\) bool](<#Contains>)
- [func ContainsAny\(b \[\]byte, chars string\) bool](<#ContainsAny>)
- [func ContainsFunc\(b \[\]byte, f func\(rune\) bool\) bool](<#ContainsFunc>)
- [func ContainsRune\(b \[\]byte, r rune\) bool](<#ContainsRune>)
- [func Count\(s, sep \[\]byte\) int](<#Count>)
- [func Cut\(s, sep \[\]byte\) \(before, after \[\]byte, found bool\)](<#Cut>)
- [func CutPrefix\(s, prefix \[\]byte\) \(after \[\]byte, found bool\)](<#CutPrefix>)
- [func CutSuffix\(s, suffix \[\]byte\) \(before \[\]byte, found bool\)](<#CutSuffix>)
- [func Equal\(a, b \[\]byte\) bool](<#Equal>)
- [func EqualFold\(s, t \[\]byte\) bool](<#EqualFold>)
- [func Fields\(s \[\]byte\) \[\]\[\]byte](<#Fields>)
- [func FieldsFunc\(s \[\]byte, f func\(rune\) bool\) \[\]\[\]byte](<#FieldsFunc>)
- [func FieldsFuncSeq\(s \[\]byte, f func\(rune\) bool\) iter.Seq\[\[\]byte\]](<#FieldsFuncSeq>)
- [func FieldsSeq\(s \[\]byte\) iter.Seq\[\[\]byte\]](<#FieldsSeq>)
- [func HasPrefix\(s, prefix \[\]byte\) bool](<#HasPrefix>)
- [func HasSuffix\(s, suffix \[\]byte\) bool](<#HasSuffix>)
- [func Index\(s, sep \[\]byte\) int](<#Index>)
- [func IndexAny\(s \[\]byte, chars string\) int](<#IndexAny>)
- [func IndexByte\(b \[\]byte, c byte\) int](<#IndexByte>)
- [func IndexFunc\(s \[\]byte, f func\(r rune\) bool\) int](<#IndexFunc>)
- [func IndexRune\(s \[\]byte, r rune\) int](<#IndexRune>)
- [func Join\(s \[\]\[\]byte, sep \[\]byte\) \[\]byte](<#Join>)
- [func LastIndex\(s, sep \[\]byte\) int](<#LastIndex>)
- [func LastIndexAny\(s \[\]byte, chars string\) int](<#LastIndexAny>)
- [func LastIndexByte\(s \[\]byte, c byte\) int](<#LastIndexByte>)
- [func LastIndexFunc\(s \[\]byte, f func\(r rune\) bool\) int](<#LastIndexFunc>)
- [func Lines\(s \[\]byte\) iter.Seq\[\[\]byte\]](<#Lines>)
- [func Map\(mapping func\(r rune\) rune, s \[\]byte\) \[\]byte](<#Map>)
- [func NewBuffer\(buf \[\]byte\) \*bytes.Buffer](<#NewBuffer>)
- [func NewBufferString\(s string\) \*bytes.Buffer](<#NewBufferString>)
- [func NewReader\(b \[\]byte\) \*bytes.Reader](<#NewReader>)
- [func Repeat\(b \[\]byte, count int\) \[\]byte](<#Repeat>)
- [func Replace\(s, old, new \[\]byte, n int\) \[\]byte](<#Replace>)
- [func ReplaceAll\(s, old, new \[\]byte\) \[\]byte](<#ReplaceAll>)
- [func Runes\(s \[\]byte\) \[\]rune](<#Runes>)
- [func Split\(s, sep \[\]byte\) \[\]\[\]byte](<#Split>)
- [func SplitAfter\(s, sep \[\]byte\) \[\]\[\]byte](<#SplitAfter>)
- [func SplitAfterN\(s, sep \[\]byte, n int\) \[\]\[\]byte](<#SplitAfterN>)
- [func SplitAfterSeq\(s, sep \[\]byte\) iter.Seq\[\[\]byte\]](<#SplitAfterSeq>)
- [func SplitN\(s, sep \[\]byte, n int\) \[\]\[\]byte](<#SplitN>)
- [func SplitSeq\(s, sep \[\]byte\) iter.Seq\[\[\]byte\]](<#SplitSeq>)
- [func Title\(s \[\]byte\) \[\]byte](<#Title>)
- [func ToLower\(s \[\]byte\) \[\]byte](<#ToLower>)
- [func ToLowerSpecial\(c unicode.SpecialCase, s \[\]byte\) \[\]byte](<#ToLowerSpecial>)
- [func ToTitle\(s \[\]byte\) \[\]byte](<#ToTitle>)
- [func ToTitleSpecial\(c unicode.SpecialCase, s \[\]byte\) \[\]byte](<#ToTitleSpecial>)
- [func ToUpper\(s \[\]byte\) \[\]byte](<#ToUpper>)
- [func ToUpperSpecial\(c unicode.SpecialCase, s \[\]byte\) \[\]byte](<#ToUpperSpecial>)
- [func ToValidUTF8\(s, replacement \[\]byte\) \[\]byte](<#ToValidUTF8>)
- [func Trim\(s \[\]byte, cutset string\) \[\]byte](<#Trim>)
- [func TrimFunc\(s \[\]byte, f func\(r rune\) bool\) \[\]byte](<#TrimFunc>)
- [func TrimLeft\(s \[\]byte, cutset string\) \[\]byte](<#TrimLeft>)
- [func TrimLeftFunc\(s \[\]byte, f func\(r rune\) bool\) \[\]byte](<#TrimLeftFunc>)
- [func TrimPrefix\(s, prefix \[\]byte\) \[\]byte](<#TrimPrefix>)
- [func TrimRight\(s \[\]byte, cutset string\) \[\]byte](<#TrimRight>)
- [func TrimRightFunc\(s \[\]byte, f func\(r rune\) bool\) \[\]byte](<#TrimRightFunc>)
- [func TrimSpace\(s \[\]byte\) \[\]byte](<#TrimSpace>)
- [func TrimSuffix\(s, suffix \[\]byte\) \[\]byte](<#TrimSuffix>)
- [type Buffer](<#Buffer>)
- [type Bytes](<#Bytes>)
  - [func FromString\(s string\) Bytes](<#FromString>)
  - [func \(b Bytes\) Contains\(sub \[\]byte\) bool](<#Bytes.Contains>)
  - [func \(b Bytes\) FindString\(s string\) int](<#Bytes.FindString>)
  - [func \(b Bytes\) HasPrefix\(prefix \[\]byte\) bool](<#Bytes.HasPrefix>)
  - [func \(b Bytes\) HasSuffix\(suffix \[\]byte\) bool](<#Bytes.HasSuffix>)
  - [func \(b Bytes\) Index\(sub \[\]byte\) int](<#Bytes.Index>)
  - [func \(b Bytes\) Read\(offset int, limit int\) \[\]byte](<#Bytes.Read>)
  - [func \(b Bytes\) ReadString\(offset int, limit int\) string](<#Bytes.ReadString>)
  - [func \(b Bytes\) Replace\(old, replacement \[\]byte, n int\) \[\]byte](<#Bytes.Replace>)
  - [func \(b Bytes\) String\(\) string](<#Bytes.String>)
  - [func \(b Bytes\) Trim\(cutset string\) \[\]byte](<#Bytes.Trim>)
  - [func \(b Bytes\) TrimPrefix\(prefix \[\]byte\) \[\]byte](<#Bytes.TrimPrefix>)
  - [func \(b Bytes\) TrimSpace\(\) \[\]byte](<#Bytes.TrimSpace>)
  - [func \(b Bytes\) TrimSuffix\(suffix \[\]byte\) \[\]byte](<#Bytes.TrimSuffix>)
- [type Reader](<#Reader>)


## Constants

<a name="MinRead"></a>

```go
const MinRead = bytes.MinRead
```

## Variables

<a name="ErrTooLarge"></a>

```go
var ErrTooLarge = bytes.ErrTooLarge
```

<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L23>)

```go
func Clone(b []byte) []byte
```



<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L27>)

```go
func Compare(a, b []byte) int
```



<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L31>)

```go
func Contains(b, subslice []byte) bool
```



<a name="ContainsAny"></a>
## func [ContainsAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L35>)

```go
func ContainsAny(b []byte, chars string) bool
```



<a name="ContainsFunc"></a>
## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L39>)

```go
func ContainsFunc(b []byte, f func(rune) bool) bool
```



<a name="ContainsRune"></a>
## func [ContainsRune](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L43>)

```go
func ContainsRune(b []byte, r rune) bool
```



<a name="Count"></a>
## func [Count](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L47>)

```go
func Count(s, sep []byte) int
```



<a name="Cut"></a>
## func [Cut](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L51>)

```go
func Cut(s, sep []byte) (before, after []byte, found bool)
```



<a name="CutPrefix"></a>
## func [CutPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L55>)

```go
func CutPrefix(s, prefix []byte) (after []byte, found bool)
```



<a name="CutSuffix"></a>
## func [CutSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L59>)

```go
func CutSuffix(s, suffix []byte) (before []byte, found bool)
```



<a name="Equal"></a>
## func [Equal](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L63>)

```go
func Equal(a, b []byte) bool
```



<a name="EqualFold"></a>
## func [EqualFold](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L67>)

```go
func EqualFold(s, t []byte) bool
```



<a name="Fields"></a>
## func [Fields](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L71>)

```go
func Fields(s []byte) [][]byte
```



<a name="FieldsFunc"></a>
## func [FieldsFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L75>)

```go
func FieldsFunc(s []byte, f func(rune) bool) [][]byte
```



<a name="FieldsFuncSeq"></a>
## func [FieldsFuncSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L79>)

```go
func FieldsFuncSeq(s []byte, f func(rune) bool) iter.Seq[[]byte]
```



<a name="FieldsSeq"></a>
## func [FieldsSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L83>)

```go
func FieldsSeq(s []byte) iter.Seq[[]byte]
```



<a name="HasPrefix"></a>
## func [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L87>)

```go
func HasPrefix(s, prefix []byte) bool
```



<a name="HasSuffix"></a>
## func [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L91>)

```go
func HasSuffix(s, suffix []byte) bool
```



<a name="Index"></a>
## func [Index](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L95>)

```go
func Index(s, sep []byte) int
```



<a name="IndexAny"></a>
## func [IndexAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L99>)

```go
func IndexAny(s []byte, chars string) int
```



<a name="IndexByte"></a>
## func [IndexByte](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L103>)

```go
func IndexByte(b []byte, c byte) int
```



<a name="IndexFunc"></a>
## func [IndexFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L107>)

```go
func IndexFunc(s []byte, f func(r rune) bool) int
```



<a name="IndexRune"></a>
## func [IndexRune](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L111>)

```go
func IndexRune(s []byte, r rune) int
```



<a name="Join"></a>
## func [Join](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L115>)

```go
func Join(s [][]byte, sep []byte) []byte
```



<a name="LastIndex"></a>
## func [LastIndex](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L119>)

```go
func LastIndex(s, sep []byte) int
```



<a name="LastIndexAny"></a>
## func [LastIndexAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L123>)

```go
func LastIndexAny(s []byte, chars string) int
```



<a name="LastIndexByte"></a>
## func [LastIndexByte](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L127>)

```go
func LastIndexByte(s []byte, c byte) int
```



<a name="LastIndexFunc"></a>
## func [LastIndexFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L131>)

```go
func LastIndexFunc(s []byte, f func(r rune) bool) int
```



<a name="Lines"></a>
## func [Lines](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L135>)

```go
func Lines(s []byte) iter.Seq[[]byte]
```



<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L139>)

```go
func Map(mapping func(r rune) rune, s []byte) []byte
```



<a name="NewBuffer"></a>
## func [NewBuffer](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L143>)

```go
func NewBuffer(buf []byte) *bytes.Buffer
```



<a name="NewBufferString"></a>
## func [NewBufferString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L147>)

```go
func NewBufferString(s string) *bytes.Buffer
```



<a name="NewReader"></a>
## func [NewReader](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L151>)

```go
func NewReader(b []byte) *bytes.Reader
```



<a name="Repeat"></a>
## func [Repeat](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L155>)

```go
func Repeat(b []byte, count int) []byte
```



<a name="Replace"></a>
## func [Replace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L159>)

```go
func Replace(s, old, new []byte, n int) []byte
```



<a name="ReplaceAll"></a>
## func [ReplaceAll](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L163>)

```go
func ReplaceAll(s, old, new []byte) []byte
```



<a name="Runes"></a>
## func [Runes](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L167>)

```go
func Runes(s []byte) []rune
```



<a name="Split"></a>
## func [Split](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L171>)

```go
func Split(s, sep []byte) [][]byte
```



<a name="SplitAfter"></a>
## func [SplitAfter](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L175>)

```go
func SplitAfter(s, sep []byte) [][]byte
```



<a name="SplitAfterN"></a>
## func [SplitAfterN](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L179>)

```go
func SplitAfterN(s, sep []byte, n int) [][]byte
```



<a name="SplitAfterSeq"></a>
## func [SplitAfterSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L183>)

```go
func SplitAfterSeq(s, sep []byte) iter.Seq[[]byte]
```



<a name="SplitN"></a>
## func [SplitN](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L187>)

```go
func SplitN(s, sep []byte, n int) [][]byte
```



<a name="SplitSeq"></a>
## func [SplitSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L191>)

```go
func SplitSeq(s, sep []byte) iter.Seq[[]byte]
```



<a name="Title"></a>
## func [Title](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L195>)

```go
func Title(s []byte) []byte
```



<a name="ToLower"></a>
## func [ToLower](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L199>)

```go
func ToLower(s []byte) []byte
```



<a name="ToLowerSpecial"></a>
## func [ToLowerSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L203>)

```go
func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte
```



<a name="ToTitle"></a>
## func [ToTitle](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L207>)

```go
func ToTitle(s []byte) []byte
```



<a name="ToTitleSpecial"></a>
## func [ToTitleSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L211>)

```go
func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte
```



<a name="ToUpper"></a>
## func [ToUpper](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L215>)

```go
func ToUpper(s []byte) []byte
```



<a name="ToUpperSpecial"></a>
## func [ToUpperSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L219>)

```go
func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte
```



<a name="ToValidUTF8"></a>
## func [ToValidUTF8](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L223>)

```go
func ToValidUTF8(s, replacement []byte) []byte
```



<a name="Trim"></a>
## func [Trim](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L227>)

```go
func Trim(s []byte, cutset string) []byte
```



<a name="TrimFunc"></a>
## func [TrimFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L231>)

```go
func TrimFunc(s []byte, f func(r rune) bool) []byte
```



<a name="TrimLeft"></a>
## func [TrimLeft](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L235>)

```go
func TrimLeft(s []byte, cutset string) []byte
```



<a name="TrimLeftFunc"></a>
## func [TrimLeftFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L239>)

```go
func TrimLeftFunc(s []byte, f func(r rune) bool) []byte
```



<a name="TrimPrefix"></a>
## func [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L243>)

```go
func TrimPrefix(s, prefix []byte) []byte
```



<a name="TrimRight"></a>
## func [TrimRight](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L247>)

```go
func TrimRight(s []byte, cutset string) []byte
```



<a name="TrimRightFunc"></a>
## func [TrimRightFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L251>)

```go
func TrimRightFunc(s []byte, f func(r rune) bool) []byte
```



<a name="TrimSpace"></a>
## func [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L255>)

```go
func TrimSpace(s []byte) []byte
```



<a name="TrimSuffix"></a>
## func [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L259>)

```go
func TrimSuffix(s, suffix []byte) []byte
```



<a name="Buffer"></a>
## type [Buffer](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L19>)



```go
type Buffer = bytes.Buffer
```

<a name="Bytes"></a>
## type [Bytes](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L11>)

Bytes is a type alias for \[\]byte to provide methods.

```go
type Bytes []byte
```

<a name="FromString"></a>
### func [FromString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L85>)

```go
func FromString(s string) Bytes
```

FromString converts a string to a Bytes slice.

<a name="Bytes.Contains"></a>
### func \(Bytes\) [Contains](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L70>)

```go
func (b Bytes) Contains(sub []byte) bool
```

Contains reports whether sub is within b.

<a name="Bytes.FindString"></a>
### func \(Bytes\) [FindString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L35>)

```go
func (b Bytes) FindString(s string) int
```

FindString returns the index of the first instance of s in b, or \-1 if s is not present in b.

<a name="Bytes.HasPrefix"></a>
### func \(Bytes\) [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L75>)

```go
func (b Bytes) HasPrefix(prefix []byte) bool
```

HasPrefix tests whether the byte slice b begins with prefix.

<a name="Bytes.HasSuffix"></a>
### func \(Bytes\) [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L80>)

```go
func (b Bytes) HasSuffix(suffix []byte) bool
```

HasSuffix tests whether the byte slice b ends with suffix.

<a name="Bytes.Index"></a>
### func \(Bytes\) [Index](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L30>)

```go
func (b Bytes) Index(sub []byte) int
```

Index returns the index of the first instance of sub in b, or \-1 if sub is not present in b.

<a name="Bytes.Read"></a>
### func \(Bytes\) [Read](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L14>)

```go
func (b Bytes) Read(offset int, limit int) []byte
```

Read returns a slice of the Bytes s beginning at offset and length limit.

<a name="Bytes.ReadString"></a>
### func \(Bytes\) [ReadString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L25>)

```go
func (b Bytes) ReadString(offset int, limit int) string
```

ReadString returns a string of the Bytes s beginning at offset and length limit.

<a name="Bytes.Replace"></a>
### func \(Bytes\) [Replace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L65>)

```go
func (b Bytes) Replace(old, replacement []byte, n int) []byte
```

Replace returns a copy of the slice with the first n non\-overlapping instances of old replaced by replacement.

<a name="Bytes.String"></a>
### func \(Bytes\) [String](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L40>)

```go
func (b Bytes) String() string
```

String converts the Bytes slice to a string.

<a name="Bytes.Trim"></a>
### func \(Bytes\) [Trim](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L45>)

```go
func (b Bytes) Trim(cutset string) []byte
```

Trim returns a slice of the bytes, with all leading and trailing bytes contained in cutset removed.

<a name="Bytes.TrimPrefix"></a>
### func \(Bytes\) [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L55>)

```go
func (b Bytes) TrimPrefix(prefix []byte) []byte
```

TrimPrefix returns b without the provided leading prefix.

<a name="Bytes.TrimSpace"></a>
### func \(Bytes\) [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L50>)

```go
func (b Bytes) TrimSpace() []byte
```

TrimSpace returns a slice of the bytes, with all leading and trailing white space removed.

<a name="Bytes.TrimSuffix"></a>
### func \(Bytes\) [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L60>)

```go
func (b Bytes) TrimSuffix(suffix []byte) []byte
```

TrimSuffix returns b without the provided trailing suffix.

<a name="Reader"></a>
## type [Reader](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L20>)



```go
type Reader = bytes.Reader
```

# runes

```go
import "github.com/goexts/generic/slices/runes"
```

Package runes provides a rich set of functions for the manipulation of rune slices \(\`\[\]rune\`\).

This package is essential for correct, Unicode\-aware text processing at the code point level.

This package is a generated adapter and mirrors the public API of the Go experimental package \`golang.org/x/text/runes\`. It offers a convenient way to access these specialized utilities within the generic context of this library.

For detailed information on the behavior of specific functions and the underlying Unicode algorithms, please refer to the official documentation for the \`golang.org/x/text/runes\` package.

Example:

```
text := []rune("  Hello, 世界!  ")

// Trim whitespace using Unicode-aware functions
trimmed := runes.TrimSpace(text)
// trimmed is "Hello, 世界!"
```

Package runes contains generated code by adptool.

## Index

- [func If\(s runes.Set, tIn, tNotIn transform.Transformer\) runes.Transformer](<#If>)
- [func In\(rt \*unicode.RangeTable\) runes.Set](<#In>)
- [func Map\(mapping func\(rune\) rune\) runes.Transformer](<#Map>)
- [func NotIn\(rt \*unicode.RangeTable\) runes.Set](<#NotIn>)
- [func Predicate\(f func\(rune\) bool\) runes.Set](<#Predicate>)
- [func Remove\(s runes.Set\) runes.Transformer](<#Remove>)
- [func ReplaceIllFormed\(\) runes.Transformer](<#ReplaceIllFormed>)
- [type Runes](<#Runes>)
  - [func FromString\(s string\) Runes](<#FromString>)
  - [func \(r Runes\) Contains\(sub \[\]rune\) bool](<#Runes.Contains>)
  - [func \(r Runes\) FindString\(s string\) int](<#Runes.FindString>)
  - [func \(r Runes\) HasPrefix\(prefix \[\]rune\) bool](<#Runes.HasPrefix>)
  - [func \(r Runes\) HasSuffix\(suffix \[\]rune\) bool](<#Runes.HasSuffix>)
  - [func \(r Runes\) Index\(sub \[\]rune\) int](<#Runes.Index>)
  - [func \(r Runes\) Read\(offset int, limit int\) \[\]rune](<#Runes.Read>)
  - [func \(r Runes\) ReadString\(offset int, limit int\) string](<#Runes.ReadString>)
  - [func \(r Runes\) Replace\(old, replacement \[\]rune, n int\) \[\]rune](<#Runes.Replace>)
  - [func \(r Runes\) String\(\) string](<#Runes.String>)
  - [func \(r Runes\) StringArray\(\) \[\]string](<#Runes.StringArray>)
  - [func \(r Runes\) ToBytes\(\) \[\]byte](<#Runes.ToBytes>)
  - [func \(r Runes\) Trim\(cutset string\) \[\]rune](<#Runes.Trim>)
  - [func \(r Runes\) TrimPrefix\(prefix \[\]rune\) \[\]rune](<#Runes.TrimPrefix>)
  - [func \(r Runes\) TrimSpace\(\) \[\]rune](<#Runes.TrimSpace>)
  - [func \(r Runes\) TrimSuffix\(suffix \[\]rune\) \[\]rune](<#Runes.TrimSuffix>)
- [type Set](<#Set>)
- [type Transformer](<#Transformer>)


<a name="If"></a>
## func [If](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L20>)

```go
func If(s runes.Set, tIn, tNotIn transform.Transformer) runes.Transformer
```



<a name="In"></a>
## func [In](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L24>)

```go
func In(rt *unicode.RangeTable) runes.Set
```



<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L28>)

```go
func Map(mapping func(rune) rune) runes.Transformer
```



<a name="NotIn"></a>
## func [NotIn](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L32>)

```go
func NotIn(rt *unicode.RangeTable) runes.Set
```



<a name="Predicate"></a>
## func [Predicate](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L36>)

```go
func Predicate(f func(rune) bool) runes.Set
```



<a name="Remove"></a>
## func [Remove](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L40>)

```go
func Remove(s runes.Set) runes.Transformer
```



<a name="ReplaceIllFormed"></a>
## func [ReplaceIllFormed](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L44>)

```go
func ReplaceIllFormed() runes.Transformer
```



<a name="Runes"></a>
## type [Runes](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L13>)

Runes is a type alias for \[\]rune to provide methods.

```go
type Runes []rune
```

<a name="FromString"></a>
### func [FromString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L164>)

```go
func FromString(s string) Runes
```

FromString converts a string to a rune slice \(\[\]rune\). This is a convenience function that is equivalent to \`\[\]rune\(s\)\`.

<a name="Runes.Contains"></a>
### func \(Runes\) [Contains](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L148>)

```go
func (r Runes) Contains(sub []rune) bool
```

Contains reports whether sub is within r.

<a name="Runes.FindString"></a>
### func \(Runes\) [FindString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L39>)

```go
func (r Runes) FindString(s string) int
```

FindString returns the index of the first instance of s in r, or \-1 if s is not present in r.

<a name="Runes.HasPrefix"></a>
### func \(Runes\) [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L153>)

```go
func (r Runes) HasPrefix(prefix []rune) bool
```

HasPrefix tests whether the Runes slice s begins with prefix.

<a name="Runes.HasSuffix"></a>
### func \(Runes\) [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L158>)

```go
func (r Runes) HasSuffix(suffix []rune) bool
```

HasSuffix tests whether the Runes slice s ends with suffix.

<a name="Runes.Index"></a>
### func \(Runes\) [Index](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L34>)

```go
func (r Runes) Index(sub []rune) int
```

Index returns the index of the first instance of sub in r, or \-1 if sub is not present in r.

<a name="Runes.Read"></a>
### func \(Runes\) [Read](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L16>)

```go
func (r Runes) Read(offset int, limit int) []rune
```

Read returns a slice of the Runes s beginning at offset and length limit.

<a name="Runes.ReadString"></a>
### func \(Runes\) [ReadString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L29>)

```go
func (r Runes) ReadString(offset int, limit int) string
```

ReadString returns a string of the Runes s beginning at offset and length limit.

<a name="Runes.Replace"></a>
### func \(Runes\) [Replace](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L114>)

```go
func (r Runes) Replace(old, replacement []rune, n int) []rune
```

Replace returns a copy of the slice with the first n non\-overlapping instances of old replaced by replacement.

<a name="Runes.String"></a>
### func \(Runes\) [String](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L53>)

```go
func (r Runes) String() string
```

String converts the Runes slice to a string.

<a name="Runes.StringArray"></a>
### func \(Runes\) [StringArray](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L44>)

```go
func (r Runes) StringArray() []string
```

StringArray converts each rune to a string and returns a slice of strings.

<a name="Runes.ToBytes"></a>
### func \(Runes\) [ToBytes](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L58>)

```go
func (r Runes) ToBytes() []byte
```

ToBytes converts the rune slice back to a UTF\-8 encoded byte slice.

<a name="Runes.Trim"></a>
### func \(Runes\) [Trim](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L63>)

```go
func (r Runes) Trim(cutset string) []rune
```

Trim returns a slice of the runes, with all leading and trailing runes contained in cutset removed.

<a name="Runes.TrimPrefix"></a>
### func \(Runes\) [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L98>)

```go
func (r Runes) TrimPrefix(prefix []rune) []rune
```

TrimPrefix returns s without the provided leading prefix.

<a name="Runes.TrimSpace"></a>
### func \(Runes\) [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L81>)

```go
func (r Runes) TrimSpace() []rune
```

TrimSpace returns a slice of the runes, with all leading and trailing white space removed.

<a name="Runes.TrimSuffix"></a>
### func \(Runes\) [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L106>)

```go
func (r Runes) TrimSuffix(suffix []rune) []rune
```

TrimSuffix returns s without the provided trailing suffix.

<a name="Set"></a>
## type [Set](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L16>)



```go
type Set = runes.Set
```

<a name="Transformer"></a>
## type [Transformer](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L17>)



```go
type Transformer = runes.Transformer
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
