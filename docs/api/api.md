<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cast

```go
import "github.com/goexts/generic/cast"
```

Package cast provides safe, generic alternatives to Go's standard type assertion. It simplifies type conversions by offering convenient, single\-expression functions that gracefully handle the \`value, ok\` idiom, avoiding panics on incorrect type assertions.

### Usage

A common use case is safely dispatching events of different types:

```
type UserCreatedEvent struct{ UserID int }
type OrderPlacedEvent struct{ OrderID string }

func HandleEvent(event any) {
	if u, ok := cast.As[UserCreatedEvent](event); ok {
		processUserCreated(u)
		return
	}
	if o, ok := cast.As[OrderPlacedEvent](event); ok {
		processOrderPlaced(o)
		return
	}
	// Optionally, handle or log unknown event types.
}
```

Another simple example:

```
var myVal any = "hello world"

// Safely cast `myVal` to a string.
if str, ok := cast.As[string](myVal); ok {
	fmt.Printf("Successfully casted to string: %s\n", str)
}

// Attempt to cast to an incorrect type.
if _, ok := cast.As[int](myVal); !ok {
	fmt.Println("Failed to cast to int, as expected.")
}
```

For more details on specific functions, refer to the function documentation.

## Index

- [func Or\[T any\]\(v any, def T\) T](<#Or>)
- [func OrZero\[T any\]\(v any\) T](<#OrZero>)
- [func Try\[T any\]\(v any\) \(T, bool\)](<#Try>)


<a name="Or"></a>
## func [Or](<https://github.com/goexts/generic/blob/main/cast/cast.go#L15>)

```go
func Or[T any](v any, def T) T
```

Or attempts to perform a type assertion of v to type T. If the assertion is successful, it returns the converted value. If the assertion fails, it returns the provided default value \`def\`.

<a name="OrZero"></a>
## func [OrZero](<https://github.com/goexts/generic/blob/main/cast/cast.go#L25>)

```go
func OrZero[T any](v any) T
```

OrZero attempts to perform a type assertion of v to type T. If the assertion is successful, it returns the converted value. If the assertion fails, it returns the zero value of type T.

<a name="Try"></a>
## func [Try](<https://github.com/goexts/generic/blob/main/cast/cast.go#L7>)

```go
func Try[T any](v any) (T, bool)
```

Try attempts to perform a type assertion of v to type T. It is a direct, generic wrapper around Go's \`value, ok\` idiom. If the assertion is successful, it returns the converted value and true. If the assertion fails, it returns the zero value of T and false.

# cmp

```go
import "github.com/goexts/generic/cmp"
```

Package cmp provides generic, type\-safe functions for comparing ordered types.

This package offers fundamental comparison utilities like Min, Max, and Clamp. Its central function, Compare, is designed to be fully compatible with the standard library's \`slices.SortFunc\`, making it easy to sort slices of any ordered type.

### Usage

Sorting a slice of structs by a specific field:

```
type Product struct {
	ID    int
	Price float64
}

products := []Product{
	{ID: 1, Price: 99.99},
	{ID: 2, Price: 49.99},
	{ID: 3, Price: 74.99},
}

// Sort products by price in ascending order.
slices.SortFunc(products, func(a, b Product) int {
	return cmp.Compare(a.Price, b.Price)
})
```

Multi\-level sorting with custom logic:

```
type Employee struct {
	Department string
	Seniority  int
	Name       string
}

// Sort employees by Department (A-Z), then Seniority (descending), then Name (A-Z).
func SortEmployees(employees []Employee) {
	slices.SortFunc(employees, func(a, b Employee) int {
		if res := cmp.Compare(a.Department, b.Department); res != 0 {
			return res
		}
		if res := cmp.Compare(b.Seniority, a.Seniority); res != 0 { // Note b, a for descending
			return res
		}
		return cmp.Compare(a.Name, b.Name)
	})
}
```

For more details, refer to the function documentation.

## Index

- [func Clamp\[T constraints.Ordered\]\(v, lo, hi T\) T](<#Clamp>)
- [func Compare\[T constraints.Ordered\]\(a, b T\) int](<#Compare>)
- [func IsZero\[T comparable\]\(v T\) bool](<#IsZero>)
- [func Max\[T constraints.Ordered\]\(a, b T\) T](<#Max>)
- [func Min\[T constraints.Ordered\]\(a, b T\) T](<#Min>)


<a name="Clamp"></a>
## func [Clamp](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L41>)

```go
func Clamp[T constraints.Ordered](v, lo, hi T) T
```

Clamp returns v clamped to the inclusive range \[lo, hi\]. If v is less than lo, it returns lo. If v is greater than hi, it returns hi. Otherwise, it returns v.

<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L11>)

```go
func Compare[T constraints.Ordered](a, b T) int
```

Compare returns an integer comparing two values. The result will be 0 if a == b, \-1 if a \< b, and \+1 if a \> b.

This function is designed to be fully compatible with the standard library's \`slices.SortFunc\`, making it a convenient tool for sorting slices of any ordered type.

<a name="IsZero"></a>
## func [IsZero](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L53>)

```go
func IsZero[T comparable](v T) bool
```

IsZero returns true if v is the zero value for its type. It is a generic\-safe way to check for zero values.

<a name="Max"></a>
## func [Max](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L30>)

```go
func Max[T constraints.Ordered](a, b T) T
```

Max returns the larger of a or b.

<a name="Min"></a>
## func [Min](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L22>)

```go
func Min[T constraints.Ordered](a, b T) T
```

Min returns the smaller of a or b.

# cond

```go
import "github.com/goexts/generic/cond"
```

Package cond provides generic, ternary\-like conditional functions.

This package offers a concise way to express simple conditional logic in a single expression, avoiding the need for a more verbose if\-else block. It provides functions for both eagerly\-evaluated values \(If\) and lazily\-evaluated functions \(IfFunc\).

### Usage

\#\# Eager Evaluation with \`If\`

The \`If\` function is a direct replacement for a simple ternary operation. Both the \`trueVal\` and \`falseVal\` are evaluated before the function is called.

```
// Determine a status message based on an error.
func GetStatusMessage(err error) string {
	return cond.If(err == nil, "Status: OK", "Status: Failed")
}

// Assign a value based on a boolean condition.
isLoggedIn := true
buttonText := cond.If(isLoggedIn, "Logout", "Login")
```

\#\# Lazy Evaluation with \`IfFunc\`

The \`IfFunc\` function accepts functions that are only executed when needed. This is useful when the values to be returned involve expensive computations.

```
// The expensive functions are only called when the condition is met.
func calculateResult(isComplex bool) int {
	return cond.IfFunc(isComplex, doComplexCalculation, doSimpleCalculation)
}

func doComplexCalculation() int {
	// Simulate a time-consuming operation.
	time.Sleep(1 * time.Second)
	return 100
}

func doSimpleCalculation() int {
	return 1
}
```

Choose \`If\` for simple values and \`IfFunc\` to optimize performance when dealing with computationally intensive branches.

## Index

- [func If\[T any\]\(condition bool, trueVal T, falseVal T\) T](<#If>)
- [func IfFunc\[T any\]\(condition bool, trueFn func\(\) T, falseFn func\(\) T\) T](<#IfFunc>)
- [func IfFuncE\[T any\]\(condition bool, trueFn func\(\) \(T, error\), falseFn func\(\) \(T, error\)\) \(T, error\)](<#IfFuncE>)


<a name="If"></a>
## func [If](<https://github.com/goexts/generic/blob/main/cond/cond.go#L8>)

```go
func If[T any](condition bool, trueVal T, falseVal T) T
```

If returns trueVal if the condition is true, and falseVal otherwise. This is a generic, eagerly\-evaluated ternary\-like expression. Both trueVal and falseVal are evaluated before this function is called.

For lazy evaluation where values are expensive to compute, see IfFunc.

<a name="IfFunc"></a>
## func [IfFunc](<https://github.com/goexts/generic/blob/main/cond/cond.go#L19>)

```go
func IfFunc[T any](condition bool, trueFn func() T, falseFn func() T) T
```

IfFunc returns the result of trueFn if the condition is true, and the result of falseFn otherwise. This is a generic, lazily\-evaluated ternary\-like expression. Only the function corresponding to the condition's outcome is executed.

<a name="IfFuncE"></a>
## func [IfFuncE](<https://github.com/goexts/generic/blob/main/cond/cond.go#L30>)

```go
func IfFuncE[T any](condition bool, trueFn func() (T, error), falseFn func() (T, error)) (T, error)
```

IfFuncE returns the result of trueFn if the condition is true, and the result of falseFn otherwise. It is the error\-returning version of IfFunc. This is a generic, lazily\-evaluated ternary\-like expression. Only the function corresponding to the condition's outcome is executed.

# configure

```go
import "github.com/goexts/generic/configure"
```

Package configure provides utilities for applying functional options to objects.

Package configure provides a robust, type\-safe, and flexible implementation of the Functional Options Pattern for Go. It is designed to simplify the initialization of complex objects by allowing optional parameters to be passed in a clean and readable way.

This pattern is ideal for constructors where many parameters are optional, have sensible defaults, or where you want to avoid a large number of arguments.

### Usage

The core of the pattern involves defining an \`Option\` type and functions that return these options.

\#\# Basic Example: Configuring a Logger

Imagine you are creating a \`Logger\` that can be configured with different logging levels and output writers. The default is to log at the "info" level to standard output.

```
// 1. Define the object to be configured.
type Logger struct {
	level string
	out   io.Writer
}

// 2. Create functions that return an `Option` for each configurable field.
func WithLevel(level string) configure.Option[Logger] {
	return configure.OptionFunc[Logger](func(l *Logger) error {
		l.level = level
		return nil
	})
}

func WithOutput(w io.Writer) configure.Option[Logger] {
	return configure.OptionFunc[Logger](func(l *Logger) error {
		l.out = w
		return nil
	})
}

// 3. Create a constructor that applies the options to a default instance.
func NewLogger(options ...configure.Option[Logger]) (*Logger, error) {
	// Start with default values.
	l := &Logger{
		level: "info",
		out:   os.Stdout,
	}

	// Apply any provided options.
	configure.ApplyWith(l, options...)

	// You can also perform validation after applying options.
	if l.level == "" {
		return nil, fmt.Errorf("log level cannot be empty")
	}

	return l, nil
}
```

Now, you can create loggers with different configurations easily:

```
// A default logger (info level, stdout).
logger1, _ := NewLogger()

// A debug-level logger.
logger2, _ := NewLogger(WithLevel("debug"))

// A logger that writes to a file.
file, _ := os.Create("app.log")
logger3, _ := NewLogger(WithLevel("error"), WithOutput(file))
```

For more advanced usage, including stateful builders and compilation, refer to the function\-specific documentation.

## Index

- [func Apply\[T any, O OptionFunc\[T\]\]\(target \*T, opts \[\]O\) \*T](<#Apply>)
- [func ApplyAny\[T any\]\(target \*T, opts \[\]any\) \(\*T, error\)](<#ApplyAny>)
- [func ApplyAnyWith\[T any\]\(target \*T, opts ...any\) \(\*T, error\)](<#ApplyAnyWith>)
- [func ApplyE\[T any, O OptionFuncE\[T\]\]\(target \*T, opts \[\]O\) \(\*T, error\)](<#ApplyE>)
- [func ApplyWith\[T any\]\(target \*T, opts ...Option\[T\]\) \*T](<#ApplyWith>)
- [func ApplyWithE\[T any\]\(target \*T, opts ...OptionE\[T\]\) \(\*T, error\)](<#ApplyWithE>)
- [func Chain\[S any, T OptionFunc\[S\]\]\(opts ...T\) T](<#Chain>)
- [func ChainE\[S any, T OptionFuncE\[S\]\]\(opts ...T\) T](<#ChainE>)
- [func Compile\[C any, P any\]\(factory func\(c \*C\) \(\*P, error\), builder \*Builder\[C\]\) \(\*P, error\)](<#Compile>)
- [func IsConfigError\(err error\) bool](<#IsConfigError>)
- [func IsEmptyTargetValueError\(err error\) bool](<#IsEmptyTargetValueError>)
- [func IsExecutionFailedError\(err error\) bool](<#IsExecutionFailedError>)
- [func IsUnsupportedTypeError\(err error\) bool](<#IsUnsupportedTypeError>)
- [func New\[T any, O OptionFunc\[T\]\]\(opts \[\]O\) \*T](<#New>)
- [func NewAny\[T any\]\(opts ...any\) \(\*T, error\)](<#NewAny>)
- [func NewE\[T any, O OptionFuncE\[T\]\]\(opts \[\]O\) \(\*T, error\)](<#NewE>)
- [func NewWith\[T any\]\(opts ...Option\[T\]\) \*T](<#NewWith>)
- [func NewWithE\[T any\]\(opts ...OptionE\[T\]\) \(\*T, error\)](<#NewWithE>)
- [type Applier](<#Applier>)
- [type ApplierE](<#ApplierE>)
- [type Builder](<#Builder>)
  - [func NewBuilder\[C any\]\(base ...\*C\) \*Builder\[C\]](<#NewBuilder>)
  - [func \(b \*Builder\[C\]\) Add\(opts ...any\) \*Builder\[C\]](<#Builder[C].Add>)
  - [func \(b \*Builder\[C\]\) AddWhen\(condition bool, optIfTrue any, optIfFalse ...any\) \*Builder\[C\]](<#Builder[C].AddWhen>)
  - [func \(b \*Builder\[C\]\) Apply\(target \*C\) error](<#Builder[C].Apply>)
  - [func \(b \*Builder\[C\]\) Build\(\) \(\*C, error\)](<#Builder[C].Build>)
- [type ConfigError](<#ConfigError>)
  - [func \(e \*ConfigError\) Error\(\) string](<#ConfigError.Error>)
  - [func \(e \*ConfigError\) Unwrap\(\) error](<#ConfigError.Unwrap>)
- [type ErrorCode](<#ErrorCode>)
- [type Option](<#Option>)
  - [func OptionSet\[T any\]\(opts ...Option\[T\]\) Option\[T\]](<#OptionSet>)
  - [func \(o Option\[T\]\) Apply\(target \*T\)](<#Option[T].Apply>)
- [type OptionE](<#OptionE>)
  - [func OptionSetE\[T any\]\(opts ...OptionE\[T\]\) OptionE\[T\]](<#OptionSetE>)
  - [func WithValidation\[T any\]\(validator func\(\*T\) error\) OptionE\[T\]](<#WithValidation>)
  - [func \(o OptionE\[T\]\) Apply\(target \*T\) error](<#OptionE[T].Apply>)
- [type OptionFunc](<#OptionFunc>)
- [type OptionFuncAny](<#OptionFuncAny>)
- [type OptionFuncE](<#OptionFuncE>)


<a name="Apply"></a>
## func [Apply](<https://github.com/goexts/generic/blob/main/configure/apply.go#L119>)

```go
func Apply[T any, O OptionFunc[T]](target *T, opts []O) *T
```

Apply applies a slice of options to the target object. It is the core, high\-performance function for applying a homogeneous set of type\-safe options. Its generic constraint allows for custom\-defined option types, such as \`type MyOption func\(\*T\)\`.

The \`opts\` parameter is a slice of options. If you have a variadic list of options \(e.g., \`WithFoo\(\), WithBar\(\)\`\), use the \`ApplyWith\` convenience wrapper instead.

For handling mixed option types, see ApplyAny.

<a name="ApplyAny"></a>
## func [ApplyAny](<https://github.com/goexts/generic/blob/main/configure/apply.go#L175>)

```go
func ApplyAny[T any](target *T, opts []any) (*T, error)
```

ApplyAny applies a slice of options of various types \(any\) to the target object. This function provides flexibility by using reflection to handle heterogeneous options, at the cost of compile\-time type safety and a minor performance overhead.

The \`opts\` parameter is a slice of options. If you have a variadic list of options \(e.g., \`WithFoo\(\), WithBar\(\)\`\), use the \`ApplyAnyWith\` convenience wrapper instead.

For type\-safe, high\-performance application, see Apply or ApplyE.

<a name="ApplyAnyWith"></a>
## func [ApplyAnyWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L188>)

```go
func ApplyAnyWith[T any](target *T, opts ...any) (*T, error)
```

ApplyAnyWith is the variadic convenience wrapper for ApplyAny.

<a name="ApplyE"></a>
## func [ApplyE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L148>)

```go
func ApplyE[T any, O OptionFuncE[T]](target *T, opts []O) (*T, error)
```

ApplyE applies a slice of error\-returning options to the target object. It is the core, high\-performance function for applying a homogeneous set of type\-safe, error\-returning options. Its generic constraint allows for custom\-defined option types.

The \`opts\` parameter is a slice of options. If you have a variadic list of options \(e.g., \`WithFoo\(\), WithBar\(\)\`\), use the \`ApplyWithE\` convenience wrapper instead.

For handling mixed option types, see ApplyAny.

<a name="ApplyWith"></a>
## func [ApplyWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L135>)

```go
func ApplyWith[T any](target *T, opts ...Option[T]) *T
```

ApplyWith is the variadic convenience wrapper for Apply. It is useful for applying a short, explicit list of options.

Example:

```
ApplyWith(config, WithTimeout(5*time.Second), WithPort(8080))
```

<a name="ApplyWithE"></a>
## func [ApplyWithE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L162>)

```go
func ApplyWithE[T any](target *T, opts ...OptionE[T]) (*T, error)
```

ApplyWithE is the variadic convenience wrapper for ApplyE. It is useful for applying a short, explicit list of options.

<a name="Chain"></a>
## func [Chain](<https://github.com/goexts/generic/blob/main/configure/options.go#L62>)

```go
func Chain[S any, T OptionFunc[S]](opts ...T) T
```

Chain combines multiple options \(of any type satisfying OptionFunc\[S\]\) into a single option. The returned option will apply all provided options in sequence.

<a name="ChainE"></a>
## func [ChainE](<https://github.com/goexts/generic/blob/main/configure/options.go#L84>)

```go
func ChainE[S any, T OptionFuncE[S]](opts ...T) T
```

ChainE combines multiple error\-returning options \(of any type satisfying OptionFuncE\[S\]\) into a single option. The returned option will apply all provided options in sequence. If any option returns an error, the chain stops and that error is returned.

<a name="Compile"></a>
## func [Compile](<https://github.com/goexts/generic/blob/main/configure/builder.go#L95>)

```go
func Compile[C any, P any](factory func(c *C) (*P, error), builder *Builder[C]) (*P, error)
```

Compile creates a final product \`P\` by first building a configuration \`C\` using the provided \`builder\`, and then passing the result to a \`factory\` function. This function acts as the primary top\-level entry point for the Config \-\> Product workflow, emphasizing the factory's role in producing the final product from the configuration.

<a name="IsConfigError"></a>
## func [IsConfigError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L71>)

```go
func IsConfigError(err error) bool
```

IsConfigError checks if the given error is a \*ConfigError.

<a name="IsEmptyTargetValueError"></a>
## func [IsEmptyTargetValueError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L92>)

```go
func IsEmptyTargetValueError(err error) bool
```

IsEmptyTargetValueError checks if the error is a ConfigError with the code ErrEmptyTargetValue.

<a name="IsExecutionFailedError"></a>
## func [IsExecutionFailedError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L85>)

```go
func IsExecutionFailedError(err error) bool
```

IsExecutionFailedError checks if the error is a ConfigError with the code ErrExecutionFailed.

<a name="IsUnsupportedTypeError"></a>
## func [IsUnsupportedTypeError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L78>)

```go
func IsUnsupportedTypeError(err error) bool
```

IsUnsupportedTypeError checks if the error is a ConfigError with the code ErrUnsupportedType.

<a name="New"></a>
## func [New](<https://github.com/goexts/generic/blob/main/configure/apply.go#L195>)

```go
func New[T any, O OptionFunc[T]](opts []O) *T
```

New creates a new instance of T and applies the given options. It is a convenient, type\-safe constructor for creating objects with homogeneous options. For mixed\-type or error\-returning options, see NewAny or NewE.

<a name="NewAny"></a>
## func [NewAny](<https://github.com/goexts/generic/blob/main/configure/apply.go#L225>)

```go
func NewAny[T any](opts ...any) (*T, error)
```

NewAny creates a new instance of T, applies the given options of any type, and returns it. It is a convenient top\-level constructor for simple object creation where the configuration type and the product type are the same.

It uses ApplyAny for maximum flexibility in accepting options.

<a name="NewE"></a>
## func [NewE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L209>)

```go
func NewE[T any, O OptionFuncE[T]](opts []O) (*T, error)
```

NewE creates a new instance of T, applies the error\-returning options, and returns the configured instance or an error. It is a convenient, type\-safe constructor for creating objects with homogeneous, error\-returning options.

<a name="NewWith"></a>
## func [NewWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L201>)

```go
func NewWith[T any](opts ...Option[T]) *T
```

NewWith is the variadic convenience wrapper for New.

<a name="NewWithE"></a>
## func [NewWithE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L215>)

```go
func NewWithE[T any](opts ...OptionE[T]) (*T, error)
```

NewWithE is the variadic convenience wrapper for NewE.

<a name="Applier"></a>
## type [Applier](<https://github.com/goexts/generic/blob/main/configure/apply.go#L10-L12>)

Applier is an interface for types that can apply a configuration to an object. It provides an extension point for ApplyAny, allowing custom types to be used as options without reflection.

```go
type Applier[T any] interface {
    Apply(*T)
}
```

<a name="ApplierE"></a>
## type [ApplierE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L17-L19>)

ApplierE is an interface for types that can apply a configuration and return an error. It provides an extension point for ApplyAny, allowing custom types to be used as options without reflection.

```go
type ApplierE[T any] interface {
    Apply(*T) error
}
```

<a name="Builder"></a>
## type [Builder](<https://github.com/goexts/generic/blob/main/configure/builder.go#L16-L19>)

Builder provides a fluent interface for collecting and applying options. It is ideal for scenarios where configuration options are gathered progressively from different parts of an application.

The generic type C represents the configuration type being built, and is expected to be a struct type. Using a pointer type for C as the generic parameter \(e.g., Builder\[\*MyConfig\]\) is not recommended as it can lead to unexpected behavior and double\-pointers.

```go
type Builder[C any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewBuilder"></a>
### func [NewBuilder](<https://github.com/goexts/generic/blob/main/configure/builder.go#L29>)

```go
func NewBuilder[C any](base ...*C) *Builder[C]
```

NewBuilder creates a new configuration builder. It can optionally take a base configuration object. If provided, this base configuration will be cloned and used as the starting point for applying options when \`Build\` is called. If no base is provided, a zero\-value instance of C will be used.

Panics if the generic type C is itself a pointer type \(e.g., Builder\[\*MyConfig\]\), as this is an unsupported and likely unintended usage pattern that leads to double\-pointers.

<a name="Builder[C].Add"></a>
### func \(\*Builder\[C\]\) [Add](<https://github.com/goexts/generic/blob/main/configure/builder.go#L44>)

```go
func (b *Builder[C]) Add(opts ...any) *Builder[C]
```

Add adds one or more options to the builder. It supports a fluent, chainable API.

<a name="Builder[C].AddWhen"></a>
### func \(\*Builder\[C\]\) [AddWhen](<https://github.com/goexts/generic/blob/main/configure/builder.go#L54>)

```go
func (b *Builder[C]) AddWhen(condition bool, optIfTrue any, optIfFalse ...any) *Builder[C]
```

AddWhen conditionally adds an option to the builder based on a condition. If \`condition\` is true, \`optIfTrue\` is added. If \`condition\` is false and \`optIfFalse\` is provided \(as the first element of the variadic parameter\), then \`optIfFalse\` is added instead. It supports a fluent, chainable API.

<a name="Builder[C].Apply"></a>
### func \(\*Builder\[C\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/builder.go#L86>)

```go
func (b *Builder[C]) Apply(target *C) error
```

Apply implements the ApplierE interface. This allows a Builder instance to be passed directly as an option to other functions like New or ApplyAny, acting as a "super option".

<a name="Builder[C].Build"></a>
### func \(\*Builder\[C\]\) [Build](<https://github.com/goexts/generic/blob/main/configure/builder.go#L72>)

```go
func (b *Builder[C]) Build() (*C, error)
```

Build creates a new configuration object C and applies all collected options to it. It starts with a clone of the base configuration \(if set via \`NewBuilder\`\), or a zero\-value instance of C if no base is provided.

<a name="ConfigError"></a>
## type [ConfigError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L29-L36>)

ConfigError is a custom error type for the configure package. It wraps an original error while providing additional context, such as the type of option that caused the failure and a specific error code.

```go
type ConfigError struct {
    // Code is the category of the error.
    Code ErrorCode
    // TypeString is the string representation of the option's type.
    TypeString string
    // Err is the underlying error, if any.
    Err error
}
```

<a name="ConfigError.Error"></a>
### func \(\*ConfigError\) [Error](<https://github.com/goexts/generic/blob/main/configure/errors.go#L54>)

```go
func (e *ConfigError) Error() string
```

Error implements the standard error interface.

<a name="ConfigError.Unwrap"></a>
### func \(\*ConfigError\) [Unwrap](<https://github.com/goexts/generic/blob/main/configure/errors.go#L49>)

```go
func (e *ConfigError) Unwrap() error
```

Unwrap makes ConfigError compatible with the standard library's errors.Is and errors.As functions, allowing for proper error chain inspection.

<a name="ErrorCode"></a>
## type [ErrorCode](<https://github.com/goexts/generic/blob/main/configure/errors.go#L9>)

ErrorCode defines the specific category of a configuration error.

```go
type ErrorCode int
```

<a name="ErrUnsupportedType"></a>Error codes for specific configuration failures.

```go
const (
    // ErrUnsupportedType indicates that an option's type is not supported by
    // the ApplyAny function.
    ErrUnsupportedType ErrorCode = iota

    // ErrExecutionFailed indicates that an option function returned an error
    // during its execution.
    ErrExecutionFailed

    // ErrEmptyTargetValue indicates that a nil pointer was passed as the target
    // for configuration.
    ErrEmptyTargetValue
)
```

<a name="Option"></a>
## type [Option](<https://github.com/goexts/generic/blob/main/configure/options.go#L5>)

Option represents a function that configures an object of type T. It is the primary, non\-error\-returning type for the Functional Options Pattern.

```go
type Option[T any] func(*T)
```

<a name="OptionSet"></a>
### func [OptionSet](<https://github.com/goexts/generic/blob/main/configure/options.go#L54>)

```go
func OptionSet[T any](opts ...Option[T]) Option[T]
```

OptionSet bundles multiple options into a single option. This allows for creating reusable and modular sets of configurations.

Deprecated: Use Chain instead for more generic and flexible option chaining.

<a name="Option[T].Apply"></a>
### func \(Option\[T\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/options.go#L9>)

```go
func (o Option[T]) Apply(target *T)
```

Apply implements the Applier\[T\] interface, allowing an Option\[T\] to be used as a flexible option type with functions like ApplyAny.

<a name="OptionE"></a>
## type [OptionE](<https://github.com/goexts/generic/blob/main/configure/options.go#L17>)

OptionE represents a function that configures an object of type T and may return an error. The 'E' suffix is a convention for "Error".

```go
type OptionE[T any] func(*T) error
```

<a name="OptionSetE"></a>
### func [OptionSetE](<https://github.com/goexts/generic/blob/main/configure/options.go#L74>)

```go
func OptionSetE[T any](opts ...OptionE[T]) OptionE[T]
```

OptionSetE bundles multiple error\-returning options into a single option. If any option in the set returns an error, the application stops and the error is returned.

Deprecated: Use ChainE instead for more generic and flexible error\-returning option chaining.

<a name="WithValidation"></a>
### func [WithValidation](<https://github.com/goexts/generic/blob/main/configure/constructors.go#L6>)

```go
func WithValidation[T any](validator func(*T) error) OptionE[T]
```

WithValidation creates an option that validates the target object. If the validator function returns an error, the configuration process will stop.

<a name="OptionE[T].Apply"></a>
### func \(OptionE\[T\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/options.go#L21>)

```go
func (o OptionE[T]) Apply(target *T) error
```

Apply implements the ApplierE\[T\] interface, allowing an OptionE\[T\] to be used as a flexible option type with functions like ApplyAny.

<a name="OptionFunc"></a>
## type [OptionFunc](<https://github.com/goexts/generic/blob/main/configure/options.go#L31-L33>)

OptionFunc is a generic constraint that permits any function type whose underlying type is func\(\*T\). This enables the top\-level Apply function to accept custom\-defined option types, such as \`type MyOption func\(\*T\)\`.

```go
type OptionFunc[T any] interface {
    // contains filtered or unexported methods
}
```

<a name="OptionFuncAny"></a>
## type [OptionFuncAny](<https://github.com/goexts/generic/blob/main/configure/options.go#L46-L48>)

OptionFuncAny is a generic constraint that permits any function type whose underlying type is either func\(\*T\) or func\(\*T\) error. This provides a convenient way to create functions that can accept both error\-returning and non\-error\-returning function options.

```go
type OptionFuncAny[T any] interface {
    // contains filtered or unexported methods
}
```

<a name="OptionFuncE"></a>
## type [OptionFuncE](<https://github.com/goexts/generic/blob/main/configure/options.go#L38-L40>)

OptionFuncE is a generic constraint that permits any function type whose underlying type is func\(\*T\) error. This enables the top\-level ApplyE function to accept custom\-defined, error\-returning option types.

```go
type OptionFuncE[T any] interface {
    // contains filtered or unexported methods
}
```

# maps

```go
import "github.com/goexts/generic/maps"
```

Package maps provides a set of generic functions for common operations on maps.

This package is a generated adapter that mirrors the public API of the standard Go experimental package \`golang.org/x/exp/maps\`. It offers a convenient way to access common utilities for cloning, extracting keys/values, and comparing maps.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`golang.org/x/exp/maps\` package.

Package maps implements the functions, types, and interfaces for the module.

Package maps contains generated code by adptool.

## Index

- [func Clear\[M \~map\[K\]V, K comparable, V any\]\(m M\)](<#Clear>)
- [func Clone\[M \~map\[K\]V, K comparable, V any\]\(m M\) M](<#Clone>)
- [func Concat\[M \~map\[K\]V, K comparable, V any\]\(m M, ms ...M\)](<#Concat>)
- [func ConcatWith\[M \~map\[K\]V, K comparable, V any\]\(merge func\(K, V, V\) V, m M, ms ...M\)](<#ConcatWith>)
- [func Copy\[M1 \~map\[K\]V, M2 \~map\[K\]V, K comparable, V any\]\(dst M1, src M2\)](<#Copy>)
- [func DeleteFunc\[M \~map\[K\]V, K comparable, V any\]\(m M, del func\(K, V\) bool\)](<#DeleteFunc>)
- [func Equal\[M1, M2 \~map\[K\]V, K, V comparable\]\(m1 M1, m2 M2\) bool](<#Equal>)
- [func EqualFunc\[M1 \~map\[K\]V1, M2 \~map\[K\]V2, K comparable, V1, V2 any\]\(m1 M1, m2 M2, eq func\(V1, V2\) bool\) bool](<#EqualFunc>)
- [func Exclude\[M \~map\[K\]V, K comparable, V any\]\(m M, keys ...K\)](<#Exclude>)
- [func Filter\[M \~map\[K\]V, K comparable, V any\]\(m M, f func\(K, V\) bool\)](<#Filter>)
- [func FromKVs\[K comparable, V any, M \~map\[K\]V\]\(kvs \[\]KeyValue\[K, V\]\) M](<#FromKVs>)
- [func FromSlice\[T any, M \~map\[K\]V, K comparable, V any\]\(ts \[\]T, f func\(T\) \(K, V\)\) M](<#FromSlice>)
- [func FromSliceWithIndex\[T any, M \~map\[K\]V, K comparable, V any\]\(ts \[\]T, f func\(int, T\) \(K, V\)\) M](<#FromSliceWithIndex>)
- [func Keys\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]K](<#Keys>)
- [func Merge\[M \~map\[K\]V, K comparable, V any\]\(dest M, src M, overlay bool\)](<#Merge>)
- [func MergeWith\[M \~map\[K\]V, K comparable, V any\]\(dest M, src M, cmp func\(key K, src V, val V\) V\)](<#MergeWith>)
- [func ToSlice\[M \~map\[K\]V, K comparable, V any, T any\]\(m M, f func\(K, V\) T\) \[\]T](<#ToSlice>)
- [func ToSliceWith\[M \~map\[K\]V, K comparable, V any, T any\]\(m M, f func\(K, V\) \(T, bool\)\) \[\]T](<#ToSliceWith>)
- [func ToStruct\[M \~map\[K\]V, K comparable, V any, S any\]\(m M, f func\(\*S, K, V\) \*S\) \*S](<#ToStruct>)
- [func Transform\[M \~map\[K\]V, K comparable, V any, TK comparable, TV any\]\(m M, f func\(K, V\) \(TK, TV, bool\)\) map\[TK\]TV](<#Transform>)
- [func Values\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]V](<#Values>)
- [type KeyValue](<#KeyValue>)
  - [func ToKVs\[M \~map\[K\]V, K comparable, V any\]\(m M\) \[\]KeyValue\[K, V\]](<#ToKVs>)


<a name="Clear"></a>
## func [Clear](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L12>)

```go
func Clear[M ~map[K]V, K comparable, V any](m M)
```



<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L16>)

```go
func Clone[M ~map[K]V, K comparable, V any](m M) M
```



<a name="Concat"></a>
## func [Concat](<https://github.com/goexts/generic/blob/main/maps/map.go#L32>)

```go
func Concat[M ~map[K]V, K comparable, V any](m M, ms ...M)
```

Concat merges multiple maps into a single map. If a key exists in multiple maps, the value from the last map will be used.

<a name="ConcatWith"></a>
## func [ConcatWith](<https://github.com/goexts/generic/blob/main/maps/map.go#L45>)

```go
func ConcatWith[M ~map[K]V, K comparable, V any](merge func(K, V, V) V, m M, ms ...M)
```

ConcatWith merges multiple maps into a single map using a custom merge function. If a key exists in multiple maps, the merge function will be called to determine the final value.

<a name="Copy"></a>
## func [Copy](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L20>)

```go
func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)
```



<a name="DeleteFunc"></a>
## func [DeleteFunc](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L24>)

```go
func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)
```



<a name="Equal"></a>
## func [Equal](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L28>)

```go
func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool
```



<a name="EqualFunc"></a>
## func [EqualFunc](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L32>)

```go
func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool
```



<a name="Exclude"></a>
## func [Exclude](<https://github.com/goexts/generic/blob/main/maps/map.go#L57>)

```go
func Exclude[M ~map[K]V, K comparable, V any](m M, keys ...K)
```

Exclude removes all key/value pairs from m for which f returns false.

<a name="Filter"></a>
## func [Filter](<https://github.com/goexts/generic/blob/main/maps/map.go#L64>)

```go
func Filter[M ~map[K]V, K comparable, V any](m M, f func(K, V) bool)
```

Filter keeps only the key\-value pairs in the map for which the provided function returns true.

<a name="FromKVs"></a>
## func [FromKVs](<https://github.com/goexts/generic/blob/main/maps/map.go#L88>)

```go
func FromKVs[K comparable, V any, M ~map[K]V](kvs []KeyValue[K, V]) M
```

FromKVs converts a slice of key\-value pairs to a map.

<a name="FromSlice"></a>
## func [FromSlice](<https://github.com/goexts/generic/blob/main/maps/map.go#L117>)

```go
func FromSlice[T any, M ~map[K]V, K comparable, V any](ts []T, f func(T) (K, V)) M
```

FromSlice converts a slice of types to a map.

<a name="FromSliceWithIndex"></a>
## func [FromSliceWithIndex](<https://github.com/goexts/generic/blob/main/maps/map.go#L127>)

```go
func FromSliceWithIndex[T any, M ~map[K]V, K comparable, V any](ts []T, f func(int, T) (K, V)) M
```

FromSliceWithIndex converts a slice of types to a map, using the provided function to extract the key and value.

<a name="Keys"></a>
## func [Keys](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L36>)

```go
func Keys[M ~map[K]V, K comparable, V any](m M) []K
```



<a name="Merge"></a>
## func [Merge](<https://github.com/goexts/generic/blob/main/maps/map.go#L10>)

```go
func Merge[M ~map[K]V, K comparable, V any](dest M, src M, overlay bool)
```

Merge merges the values of src into dest. If overlay is true, existing values in dest will be overwritten.

<a name="MergeWith"></a>
## func [MergeWith](<https://github.com/goexts/generic/blob/main/maps/map.go#L20>)

```go
func MergeWith[M ~map[K]V, K comparable, V any](dest M, src M, cmp func(key K, src V, val V) V)
```

MergeWith merges the values of src into dest using the provided merge function. If a key exists in both maps, the merge function will be called to determine the final value.

<a name="ToSlice"></a>
## func [ToSlice](<https://github.com/goexts/generic/blob/main/maps/map.go#L97>)

```go
func ToSlice[M ~map[K]V, K comparable, V any, T any](m M, f func(K, V) T) []T
```

ToSlice converts a map to a slice of types.

<a name="ToSliceWith"></a>
## func [ToSliceWith](<https://github.com/goexts/generic/blob/main/maps/map.go#L106>)

```go
func ToSliceWith[M ~map[K]V, K comparable, V any, T any](m M, f func(K, V) (T, bool)) []T
```

ToSliceWith converts a map to a slice of types, filtering out values that return false.

<a name="ToStruct"></a>
## func [ToStruct](<https://github.com/goexts/generic/blob/main/maps/map.go#L137>)

```go
func ToStruct[M ~map[K]V, K comparable, V any, S any](m M, f func(*S, K, V) *S) *S
```

ToStruct converts a map to a struct.

<a name="Transform"></a>
## func [Transform](<https://github.com/goexts/generic/blob/main/maps/map.go#L149>)

```go
func Transform[M ~map[K]V, K comparable, V any, TK comparable, TV any](m M, f func(K, V) (TK, TV, bool)) map[TK]TV
```

Transform remaps the keys and values of a map using a custom transformation function. The transformation function is called for each key\-value pair in the original map. If the transformation function returns false as its third return value, the key\-value pair is skipped. Otherwise, the transformed key\-value pair is added to the new map.

<a name="Values"></a>
## func [Values](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L40>)

```go
func Values[M ~map[K]V, K comparable, V any](m M) []V
```



<a name="KeyValue"></a>
## type [KeyValue](<https://github.com/goexts/generic/blob/main/maps/map.go#L73-L76>)

KeyValue is a key\-value pair.

```go
type KeyValue[K comparable, V any] struct {
    Key K
    Val V
}
```

<a name="ToKVs"></a>
### func [ToKVs](<https://github.com/goexts/generic/blob/main/maps/map.go#L79>)

```go
func ToKVs[M ~map[K]V, K comparable, V any](m M) []KeyValue[K, V]
```

ToKVs converts a map to a slice of key\-value pairs.

# must

```go
import "github.com/goexts/generic/must"
```

Package must provides helper functions that wrap calls returning \`\(T, error\)\` and panic if the error is non\-nil. This is intended to reduce boilerplate code in specific, controlled contexts where an error should never happen.

### Warning: Use with Extreme Care

The functions in this package intentionally convert a recoverable error into a non\-recoverable panic. This is an anti\-pattern in normal Go application code. It should only be used in situations where an error is truly unexpected and indicates a critical, unrecoverable programmer error \(e.g., a bug\).

### Appropriate Use Cases

1. \*\*Program Initialization:\*\* During startup \(e.g., in \`init\` functions or at the top of \`main\`\), when a failure means the application cannot run at all.

2. \*\*Test Setup:\*\* When preparing test fixtures, where a failure indicates a broken test environment, not a feature to be tested.

\#\# Example: Compiling a Regular Expression

It is common to compile regular expressions at the package level. Since the pattern is hardcoded, a compilation failure is a programmer error, not a runtime error. \`must.Must\` simplifies this.

```
// Before: Verbose error handling for a panic-worthy error.
//
// var wordRegexp *regexp.Regexp
//
// func init() {
// 	var err error
// 	wordRegexp, err = regexp.Compile(`\w+`)
// 	if err != nil {
// 		panic(fmt.Sprintf("failed to compile word regexp: %v", err))
// 	}
// }

// After: Using must.Must for concise, clear initialization.
var wordRegexp = must.Must(regexp.Compile(`\w+`))
```

### Inappropriate Use Cases

NEVER use these functions for regular application logic where errors are expected and should be handled gracefully. This includes, but is not limited to:

\- Handling user input. \- Processing network requests or responses. \- Reading from or writing to files.

## Index

- [func Cast\[T any\]\(v any\) T](<#Cast>)
- [func Do\[T any\]\(v T, err error\) T](<#Do>)
- [func Do2\[T any, U any\]\(v1 T, v2 U, err error\) \(T, U\)](<#Do2>)


<a name="Cast"></a>
## func [Cast](<https://github.com/goexts/generic/blob/main/must/must.go#L25>)

```go
func Cast[T any](v any) T
```

Cast performs a type assertion and panics if it fails. It provides a more informative panic message than a raw type assertion.

<a name="Do"></a>
## func [Do](<https://github.com/goexts/generic/blob/main/must/must.go#L8>)

```go
func Do[T any](v T, err error) T
```

Do panics if err is not nil, otherwise it returns the value v. It is useful for wrapping function calls that return a value and an error, where the error is not expected.

<a name="Do2"></a>
## func [Do2](<https://github.com/goexts/generic/blob/main/must/must.go#L16>)

```go
func Do2[T any, U any](v1 T, v2 U, err error) (T, U)
```

Do2 is similar to Do, but for functions that return two values and an error.

# promise

```go
import "github.com/goexts/generic/promise"
```

Package promise provides a generic, type\-safe implementation of Promises, inspired by similar concepts in other languages like JavaScript. It is designed to simplify the management of asynchronous operations and avoid complex callback chains \(often referred to as "callback hell"\).

### Core Concepts

A Promise represents the eventual completion \(or failure\) of an asynchronous operation and its resulting value. A Promise is always in one of three states:

\- \*\*pending\*\*: The initial state; the asynchronous operation has not yet completed. \- \*\*fulfilled\*\*: The operation completed successfully, and the promise now has a result value. \- \*\*rejected\*\*: The operation failed, and the promise now holds an error.

### Basic Usage

The primary way to create a promise is with the \`New\` function, which takes an \`executor\` function. The executor is run in a new goroutine and is given \`resolve\` and \`reject\` functions to control the promise's final state.

```
// Create a promise that resolves with a message after a short delay.
p := promise.New(func(resolve func(string), reject func(error)) {
	time.Sleep(100 * time.Millisecond)
	resolve("Hello from the promise!")
})

// The Await method blocks until the promise is settled (either fulfilled or rejected).
val, err := p.Await()
// val will be "Hello from the promise!", err will be nil.
```

### Chaining Asynchronous Operations

Promises shine when you need to orchestrate a sequence of asynchronous steps. Methods like \`Then\`, \`Catch\`, and \`Finally\` allow you to build a clean, linear workflow.

Example of a complete chain:

```
// 1. Start an async operation to fetch a user ID.
userIDPromise := promise.Async(func() (int, error) {
	fmt.Println("Fetching user ID...")
	time.Sleep(50 * time.Millisecond)
	return 123, nil // Simulate success
})

// 2. Use `Then` to fetch user data once the ID is available.
userDataPromise := promise.Then(userIDPromise, func(id int) (string, error) {
	fmt.Printf("Fetching data for user %d...\n", id)
	time.Sleep(50 * time.Millisecond)
	return fmt.Sprintf("{\"name\": \"Alice\", \"id\": %d}", id), nil
})

// 3. Use `Catch` to handle any errors that might have occurred in the chain.
finalPromise := promise.Catch(userDataPromise, func(err error) (string, error) {
	fmt.Printf("An error occurred: %v. Recovering.\n", err)
	return "default data", nil // Recover with a default value
})

// 4. Await the final result.
finalResult, _ := finalPromise.Await()
fmt.Printf("Final result: %s\n", finalResult)
```

This creates a readable, non\-blocking sequence of dependent operations.

## Index

- [func Await\[T any\]\(p \*Promise\[T\]\) \(T, error\)](<#Await>)
- [type Promise](<#Promise>)
  - [func Async\[T any\]\(f func\(\) \(T, error\)\) \*Promise\[T\]](<#Async>)
  - [func New\[T any\]\(executor func\(resolve func\(T\), reject func\(error\)\)\) \*Promise\[T\]](<#New>)
  - [func \(p \*Promise\[T\]\) Await\(\) \(T, error\)](<#Promise[T].Await>)
  - [func \(p \*Promise\[T\]\) Catch\(onRejected func\(error\) \(T, error\)\) \*Promise\[T\]](<#Promise[T].Catch>)
  - [func \(p \*Promise\[T\]\) Finally\(onFinally func\(\)\) \*Promise\[T\]](<#Promise[T].Finally>)
  - [func \(p \*Promise\[T\]\) Reject\(err error\)](<#Promise[T].Reject>)
  - [func \(p \*Promise\[T\]\) Resolve\(value T\)](<#Promise[T].Resolve>)
  - [func \(p \*Promise\[T\]\) Then\(onFulfilled func\(T\) T\) \*Promise\[T\]](<#Promise[T].Then>)
  - [func \(p \*Promise\[T\]\) ThenWithPromise\(onFulfilled func\(T\) \*Promise\[T\]\) \*Promise\[T\]](<#Promise[T].ThenWithPromise>)


<a name="Await"></a>
## func [Await](<https://github.com/goexts/generic/blob/main/promise/promise.go#L192>)

```go
func Await[T any](p *Promise[T]) (T, error)
```

Await is a standalone function that waits for a promise to be settled. It is a functional equivalent of the p.Await\(\) method.

<a name="Promise"></a>
## type [Promise](<https://github.com/goexts/generic/blob/main/promise/promise.go#L11-L17>)

Promise represents the eventual completion \(or failure\) of an asynchronous operation and its resulting value. It is a generic, type\-safe implementation inspired by the JavaScript Promise API.

```go
type Promise[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="Async"></a>
### func [Async](<https://github.com/goexts/generic/blob/main/promise/promise.go#L179>)

```go
func Async[T any](f func() (T, error)) *Promise[T]
```

Async is a helper function that wraps a function returning \(T, error\) into a new Promise. This is useful for converting existing functions into promise\-based asynchronous operations.

<a name="New"></a>
### func [New](<https://github.com/goexts/generic/blob/main/promise/promise.go#L22>)

```go
func New[T any](executor func(resolve func(T), reject func(error))) *Promise[T]
```

New creates a new Promise. The provided executor function is executed in a new goroutine. The executor receives \`resolve\` and \`reject\` functions to control the promise's outcome.

<a name="Promise[T].Await"></a>
### func \(\*Promise\[T\]\) [Await](<https://github.com/goexts/generic/blob/main/promise/promise.go#L72>)

```go
func (p *Promise[T]) Await() (T, error)
```

Await blocks until the promise is settled and returns the resulting value and error. It is the primary way to get the result of a promise.

<a name="Promise[T].Catch"></a>
### func \(\*Promise\[T\]\) [Catch](<https://github.com/goexts/generic/blob/main/promise/promise.go#L124>)

```go
func (p *Promise[T]) Catch(onRejected func(error) (T, error)) *Promise[T]
```

Catch attaches a callback that executes when the promise is rejected. It allows for error handling and recovery. The onRejected callback can return a new value to fulfill the promise, or a new error to continue the rejection chain.

<a name="Promise[T].Finally"></a>
### func \(\*Promise\[T\]\) [Finally](<https://github.com/goexts/generic/blob/main/promise/promise.go#L149>)

```go
func (p *Promise[T]) Finally(onFinally func()) *Promise[T]
```

Finally attaches a callback that executes when the promise is settled \(either fulfilled or rejected\). It is useful for cleanup logic. The returned promise will be settled with the same value or error as the original promise, after onFinally has completed.

<a name="Promise[T].Reject"></a>
### func \(\*Promise\[T\]\) [Reject](<https://github.com/goexts/generic/blob/main/promise/promise.go#L57>)

```go
func (p *Promise[T]) Reject(err error)
```

Reject rejects the promise with an error. If the promise is already settled, this call is ignored.

<a name="Promise[T].Resolve"></a>
### func \(\*Promise\[T\]\) [Resolve](<https://github.com/goexts/generic/blob/main/promise/promise.go#L42>)

```go
func (p *Promise[T]) Resolve(value T)
```

Resolve fulfills the promise with a value. If the promise is already settled, this call is ignored.

<a name="Promise[T].Then"></a>
### func \(\*Promise\[T\]\) [Then](<https://github.com/goexts/generic/blob/main/promise/promise.go#L80>)

```go
func (p *Promise[T]) Then(onFulfilled func(T) T) *Promise[T]
```

Then attaches a callback that executes when the promise is fulfilled. It returns a new promise that resolves with the result of the onFulfilled callback. If the original promise is rejected, the new promise is rejected with the same error.

<a name="Promise[T].ThenWithPromise"></a>
### func \(\*Promise\[T\]\) [ThenWithPromise](<https://github.com/goexts/generic/blob/main/promise/promise.go#L98>)

```go
func (p *Promise[T]) ThenWithPromise(onFulfilled func(T) *Promise[T]) *Promise[T]
```

ThenWithPromise is like Then, but the callback returns a new Promise. This allows for chaining of asynchronous operations.

# ptr

```go
import "github.com/goexts/generic/ptr"
```

Package ptr provides generic utility functions for working with pointers. It simplifies common operations such as creating a pointer from a literal value, safely dereferencing a potentially nil pointer, and comparing pointer values.

### Creating Pointers with \\\`Of\\\`

In Go, you cannot take the address of a literal value directly. This package solves that problem, which is especially useful for populating struct fields that are pointers.

```
type Config struct {
	Timeout *int
	Name    *string
}

// Verbose way without the ptr package:
//
// timeout := 30
// name := "default-name"
// cfg := Config{
// 	Timeout: &timeout,
// 	Name:    &name,
// }

// Concise way with the ptr package:
cfg := Config{
	Timeout: ptr.Of(30),
	Name:    ptr.Of("default-name"),
}
```

### Safely Dereferencing with \\\`Value\\\`

Dereferencing a nil pointer causes a panic. The \`Value\` function provides a safe way to get the value of a pointer, returning the zero value of the type if the pointer is nil.

```
var timeout *int // nil
var name = ptr.Of("my-app")

// Safely get the value or the zero value (0 for int).
timeoutValue := ptr.Value(timeout) // Returns 0

// Safely get the value of a non-nil pointer.
nameValue := ptr.Value(name) // Returns "my-app"
```

### Comparing Pointers with \\\`Equal\\\`

The \`Equal\` function safely compares the values that two pointers point to. It handles nil pointers gracefully.

```
p1 := ptr.Of(100)
p2 := ptr.Of(100)
p3 := ptr.Of(200)
var p4 *int // nil

ptr.Equal(p1, p2) // true
ptr.Equal(p1, p3) // false
ptr.Equal(p1, p4) // false
ptr.Equal(p4, p4) // true
```

## Index

- [func Of\[T any\]\(v T\) \*T](<#Of>)
- [func To\[T any\]\(v any\) \*T](<#To>)
- [func ToVal\[T any\]\(v any\) T](<#ToVal>)
- [func Val\[T any\]\(v \*T\) T](<#Val>)


<a name="Of"></a>
## func [Of](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L10>)

```go
func Of[T any](v T) *T
```

Of returns a pointer to the given value v. This is a convenient helper for creating a pointer to a literal or a variable in a single expression, often used for struct field initialization.

Example:

```
config := &MyConfig{ Timeout: ptr.Of(5*time.Second) }
```

<a name="To"></a>
## func [To](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L30>)

```go
func To[T any](v any) *T
```

To converts an \`any\` value to a pointer of type \*T. It handles three cases:

1. If v is of type T, it returns a pointer to it \(&v\).
2. If v is already of type \*T, it returns v directly.
3. Otherwise, it returns a new pointer to a zero value of T.

<a name="ToVal"></a>
## func [ToVal](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L47>)

```go
func ToVal[T any](v any) T
```

ToVal converts an \`any\` value to a value of type T. It handles three cases:

1. If v is a non\-nil pointer of type \*T, it returns the dereferenced value.
2. If v is of type T, it returns v directly.
3. Otherwise, it returns the zero value of T.

<a name="Val"></a>
## func [Val](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L17>)

```go
func Val[T any](v *T) T
```

Val returns the value that the pointer v points to. If the pointer is nil, it safely returns the zero value of the type T. This avoids a panic when dereferencing a nil pointer.

# res

```go
import "github.com/goexts/generic/res"
```

Package res provides a generic, Rust\-inspired \`Result\[T\]\` type for expressive error handling.

### Core Concept

A \`Result\[T\]\` is a type that represents either a success \(containing a value of type T\) or a failure \(containing an error\). It is a monadic type that allows for chaining operations in a clean, readable way, especially in data processing pipelines where each step can fail.

This pattern provides an alternative to returning \`\(value, error\)\` pairs at each step. Instead of checking for an error after every call, you can chain methods and handle the final result once.

### Warning: Paradigm and Trade\\\-offs

While powerful, the \`Result\` type introduces a paradigm that is not idiomatic Go. Standard Go error handling \(returning \`\(T, error\)\`\) is simpler and more direct for most use cases. The \`Result\` type is best suited for specific scenarios like complex data transformation chains where the flow of data is the primary concern.

Be especially cautious with methods like \`Unwrap\` and \`Expect\`, which panic on an \`Err\` value. They should only be used when an error is considered a fatal, unrecoverable bug, similar to the \`must\` package.

### Usage: Data Processing Pipeline

The primary benefit of \`Result\` is in chaining operations where any step can fail. The chain short\-circuits as soon as an error occurs.

Consider a sequence of operations: 1. Get a filename from a map. 2. Read the file content. 3. Parse the content into a number.

```
// Define helper functions that each return a Result.
func getFilename(config map[string]string) res.Result[string] {
	if name, ok := config["filename"]; ok {
		return res.Ok(name)
	}
	return res.Err[string](errors.New("filename not found in config"))
}

func readContent(filename string) res.Result[string] {
	// Simulate reading a file.
	if filename == "data.txt" {
		return res.Ok("12345")
	}
	return res.Err[string](fmt.Errorf("file not found: %s", filename))
}

func parseNumber(content string) res.Result[int] {
	n, err := strconv.Atoi(content)
	return res.Of(n, err)
}

// Now, chain these operations together.
config := map[string]string{"filename": "data.txt"}

// The `AndThen` method chains functions that return a Result.
// The chain stops at the first `Err`.
finalResult := getFilename(config).
	AndThen(readContent).
	AndThen(parseNumber)

// Safely handle the outcome.
if finalResult.IsErr() {
	fmt.Printf("Pipeline failed: %v\n", finalResult.Err())
} else {
	// No error occurred, we can safely get the value.
	fmt.Printf("Pipeline succeeded, result: %d\n", finalResult.Unwrap())
}
```

## Index

- [func Or\[T any\]\(v T, err error, defaultValue T\) T](<#Or>)
- [func OrZero\[T any\]\(v T, err error\) T](<#OrZero>)
- [type Result](<#Result>)
  - [func Err\[T any\]\(err error\) Result\[T\]](<#Err>)
  - [func Of\[T any\]\(value T, err error\) Result\[T\]](<#Of>)
  - [func Ok\[T any\]\(value T\) Result\[T\]](<#Ok>)
  - [func \(r Result\[T\]\) Err\(\) error](<#Result[T].Err>)
  - [func \(r Result\[T\]\) Expect\(message string\) T](<#Result[T].Expect>)
  - [func \(r Result\[T\]\) IsErr\(\) bool](<#Result[T].IsErr>)
  - [func \(r Result\[T\]\) IsOk\(\) bool](<#Result[T].IsOk>)
  - [func \(r Result\[T\]\) Ok\(\) \(T, bool\)](<#Result[T].Ok>)
  - [func \(r Result\[T\]\) Unwrap\(\) T](<#Result[T].Unwrap>)
  - [func \(r Result\[T\]\) UnwrapOr\(defaultValue T\) T](<#Result[T].UnwrapOr>)


<a name="Or"></a>
## func [Or](<https://github.com/goexts/generic/blob/main/res/res.go#L87>)

```go
func Or[T any](v T, err error, defaultValue T) T
```

Or is a utility function that simplifies handling of \(value, error\) returns. It returns the value if err is nil, otherwise it returns the provided default value.

<a name="OrZero"></a>
## func [OrZero](<https://github.com/goexts/generic/blob/main/res/res.go#L96>)

```go
func OrZero[T any](v T, err error) T
```

OrZero is a utility function that simplifies handling of \(value, error\) returns. It returns the value if err is nil, otherwise it returns the zero value of the type.

<a name="Result"></a>
## type [Result](<https://github.com/goexts/generic/blob/main/res/res.go#L9-L12>)

Result is a type that represents either a success \(containing a value of type T\) or a failure \(containing an error\). It is a monadic type that allows for chaining operations in a clean, readable way. See the package documentation for more details and usage examples.

```go
type Result[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="Err"></a>
### func [Err](<https://github.com/goexts/generic/blob/main/res/res.go#L20>)

```go
func Err[T any](err error) Result[T]
```

Err creates a new failed Result containing the given error.

<a name="Of"></a>
### func [Of](<https://github.com/goexts/generic/blob/main/res/res.go#L27>)

```go
func Of[T any](value T, err error) Result[T]
```

Of converts a standard Go \(value, error\) pair into a Result. If err is not nil, it returns an Err result; otherwise, it returns an Ok result.

<a name="Ok"></a>
### func [Ok](<https://github.com/goexts/generic/blob/main/res/res.go#L15>)

```go
func Ok[T any](value T) Result[T]
```

Ok creates a new successful Result containing the given value.

<a name="Result[T].Err"></a>
### func \(Result\[T\]\) [Err](<https://github.com/goexts/generic/blob/main/res/res.go#L81>)

```go
func (r Result[T]) Err() error
```

Err returns the contained error, or nil if the result is Ok.

<a name="Result[T].Expect"></a>
### func \(Result\[T\]\) [Expect](<https://github.com/goexts/generic/blob/main/res/res.go#L67>)

```go
func (r Result[T]) Expect(message string) T
```

Expect returns the contained Ok value. It panics with a custom message if the result is an Err. This is similar to Unwrap but provides a more context\-specific panic message.

<a name="Result[T].IsErr"></a>
### func \(Result\[T\]\) [IsErr](<https://github.com/goexts/generic/blob/main/res/res.go#L40>)

```go
func (r Result[T]) IsErr() bool
```

IsErr returns true if the result is an Err \(i.e., contains an error\).

<a name="Result[T].IsOk"></a>
### func \(Result\[T\]\) [IsOk](<https://github.com/goexts/generic/blob/main/res/res.go#L35>)

```go
func (r Result[T]) IsOk() bool
```

IsOk returns true if the result is Ok \(i.e., does not contain an error\).

<a name="Result[T].Ok"></a>
### func \(Result\[T\]\) [Ok](<https://github.com/goexts/generic/blob/main/res/res.go#L76>)

```go
func (r Result[T]) Ok() (T, bool)
```

Ok returns the contained value and a boolean indicating if the result was Ok. This provides a safe, idiomatic Go way to access the value.

<a name="Result[T].Unwrap"></a>
### func \(Result\[T\]\) [Unwrap](<https://github.com/goexts/generic/blob/main/res/res.go#L48>)

```go
func (r Result[T]) Unwrap() T
```

Unwrap returns the contained Ok value. It panics if the result is an Err. Because this function may panic, it should only be used when the caller is certain that the result is Ok, or when a panic is the desired behavior. See also: Expect, UnwrapOr.

<a name="Result[T].UnwrapOr"></a>
### func \(Result\[T\]\) [UnwrapOr](<https://github.com/goexts/generic/blob/main/res/res.go#L57>)

```go
func (r Result[T]) UnwrapOr(defaultValue T) T
```

UnwrapOr returns the contained Ok value or a provided default value. It is a safe way to access the value without panicking.

# set

```go
import "github.com/goexts/generic/set"
```

Package set provides a collection of generic, stateless functions for performing set\-like operations on standard Go slices.

### Core Philosophy

Instead of introducing a new, stateful \`Set\` data structure, this package provides utilities that treat slices as if they were sets. This approach offers several advantages:

- \*\*Lightweight\*\*: It requires no new types, reducing the learning curve.
- \*\*Idiomatic\*\*: It integrates seamlessly with the rest of the Go ecosystem, which heavily relies on slices.
- \*\*Functional\*\*: It promotes a functional style of programming by taking slices as input and returning new slices as output.

The functions in this package operate on slices of any \`comparable\` type.

### Usage

Note: The output of these functions is not guaranteed to be in any specific order. If a stable order is required, sort the resulting slice.

```
setA := []int{1, 2, 3, 4}
setB := []int{3, 4, 5, 6}
```

\#\# Union

\`Union\` returns a new slice containing all unique elements from the input slices.

```
union := set.Union(setA, setB) // Result (order not guaranteed): [1, 2, 3, 4, 5, 6]
```

\#\# Intersection

\`Intersection\` returns a new slice containing only the elements that exist in all input slices.

```
intersection := set.Intersection(setA, setB) // Result (order not guaranteed): [3, 4]
```

\#\# Difference

\`Difference\` returns a new slice containing elements from the first slice that are not present in the second slice.

```
diffA_B := set.Difference(setA, setB) // Result: [1, 2]
diffB_A := set.Difference(setB, setA) // Result: [5, 6]
```

\#\# Unique

\`Unique\` removes duplicate elements from a single slice.

```
items := []string{"a", "b", "a", "c", "b"}
unique := set.Unique(items) // Result (order not guaranteed): ["a", "b", "c"]
```

## Index

- [func Contains\[T comparable\]\(s \[\]T, e T\) bool](<#Contains>)
- [func Difference\[T comparable\]\(s1, s2 \[\]T\) \[\]T](<#Difference>)
- [func Exists\[T any\]\(s \[\]T, f func\(T\) bool\) bool](<#Exists>)
- [func Intersection\[T comparable\]\(s1, s2 \[\]T\) \[\]T](<#Intersection>)
- [func Union\[T comparable\]\(s1, s2 \[\]T\) \[\]T](<#Union>)
- [func Unique\[T comparable\]\(s \[\]T\) \[\]T](<#Unique>)


<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/set/set.go#L5>)

```go
func Contains[T comparable](s []T, e T) bool
```

Contains checks if a slice \`s\` contains the element \`e\`. The check is performed using the equality operator \(==\).

<a name="Difference"></a>
## func [Difference](<https://github.com/goexts/generic/blob/main/set/set.go#L77>)

```go
func Difference[T comparable](s1, s2 []T) []T
```

Difference returns a new slice containing the elements from s2 that are not present in s1 \(s2 \- s1\). The order of elements in the returned slice is not guaranteed.

<a name="Exists"></a>
## func [Exists](<https://github.com/goexts/generic/blob/main/set/set.go#L15>)

```go
func Exists[T any](s []T, f func(T) bool) bool
```

Exists checks if at least one element in a slice \`s\` satisfies the predicate \`f\`.

<a name="Intersection"></a>
## func [Intersection](<https://github.com/goexts/generic/blob/main/set/set.go#L59>)

```go
func Intersection[T comparable](s1, s2 []T) []T
```

Intersection returns a new slice containing only the elements that exist in both s1 and s2. The order of elements in the returned slice is not guaranteed.

<a name="Union"></a>
## func [Union](<https://github.com/goexts/generic/blob/main/set/set.go#L41>)

```go
func Union[T comparable](s1, s2 []T) []T
```

Union returns a new slice containing the unique elements present in either s1 or s2. The order of elements in the returned slice is not guaranteed.

<a name="Unique"></a>
## func [Unique](<https://github.com/goexts/generic/blob/main/set/set.go#L26>)

```go
func Unique[T comparable](s []T) []T
```

Unique returns a new slice containing only the unique elements of the input slice \`s\`. The order of elements in the returned slice is not guaranteed.

# slices

```go
import "github.com/goexts/generic/slices"
```

Package slices provides a rich set of generic functions for common operations on slices of any element type.

This package is a generated adapter that mirrors the public API of the standard Go experimental package \`golang.org/x/exp/slices\`. It offers a convenient way to access these common utilities for searching, sorting, comparing, and manipulating slices.

For detailed information on the behavior of specific functions, please refer to the pkg.go.dev documentation for the \`slices\` package.

Package slices implements the functions, types, and interfaces for the module.

Package slices contains generated code by adptool.

Package slices implements the functions, types, and interfaces for the module.

## Index

- [Variables](<#variables>)
- [func Append\[S any\]\(arr \[\]S, v S\) \(\[\]S, int\)](<#Append>)
- [func BinarySearch\[S \~\[\]E, E constraints.Ordered\]\(x S, target E\) \(int, bool\)](<#BinarySearch>)
- [func BinarySearchFunc\[S \~\[\]E, E, T any\]\(x S, target T, cmp func\(E, T\) int\) \(int, bool\)](<#BinarySearchFunc>)
- [func Clip\[S \~\[\]E, E any\]\(s S\) S](<#Clip>)
- [func Clone\[S \~\[\]E, E any\]\(s S\) S](<#Clone>)
- [func Compact\[S \~\[\]E, E comparable\]\(s S\) S](<#Compact>)
- [func CompactFunc\[S \~\[\]E, E any\]\(s S, eq func\(E, E\) bool\) S](<#CompactFunc>)
- [func Compare\[S \~\[\]E, E constraints.Ordered\]\(s1, s2 S\) int](<#Compare>)
- [func CompareFunc\[S1 \~\[\]E1, S2 \~\[\]E2, E1, E2 any\]\(s1 S1, s2 S2, cmp func\(E1, E2\) int\) int](<#CompareFunc>)
- [func Contains\[S \~\[\]E, E comparable\]\(s S, v E\) bool](<#Contains>)
- [func ContainsFunc\[S \~\[\]E, E any\]\(s S, f func\(E\) bool\) bool](<#ContainsFunc>)
- [func CopyAt\[S any\]\(s, t \[\]S, i int\) \[\]S](<#CopyAt>)
- [func Count\[S E\]\(s, sub \[\]S\) int](<#Count>)
- [func CountArray\[S E\]\(ss \[\]S, s S\) int](<#CountArray>)
- [func Cut\[S E\]\(s, sep \[\]S\) \(before, after \[\]S, found bool\)](<#Cut>)
- [func Delete\[S \~\[\]E, E any\]\(s S, i, j int\) S](<#Delete>)
- [func DeleteFunc\[S \~\[\]E, E any\]\(s S, del func\(E\) bool\) S](<#DeleteFunc>)
- [func Equal\[S \~\[\]E, E comparable\]\(s1, s2 S\) bool](<#Equal>)
- [func EqualFunc\[S1 \~\[\]E1, S2 \~\[\]E2, E1, E2 any\]\(s1 S1, s2 S2, eq func\(E1, E2\) bool\) bool](<#EqualFunc>)
- [func Filter\[S any\]\(s \[\]S, f func\(S\) bool\) \[\]S](<#Filter>)
- [func FilterExcluded\[S comparable\]\(s \[\]S, excludes \[\]S\) \[\]S](<#FilterExcluded>)
- [func FilterIncluded\[S comparable\]\(s \[\]S, includes \[\]S\) \[\]S](<#FilterIncluded>)
- [func Grow\[S \~\[\]E, E any\]\(s S, n int\) S](<#Grow>)
- [func Index\[S \~\[\]E, E comparable\]\(s S, v E\) int](<#Index>)
- [func IndexFunc\[S \~\[\]E, E any\]\(s S, f func\(E\) bool\) int](<#IndexFunc>)
- [func IndexSlice\[S E\]\(s, substr \[\]S\) int](<#IndexSlice>)
- [func Insert\[S \~\[\]E, E any\]\(s S, i int, v ...E\) S](<#Insert>)
- [func InsertWith\[S any\]\(s \[\]S, v S, fn func\(a, b S\) bool\) \[\]S](<#InsertWith>)
- [func IsSorted\[S \~\[\]E, E constraints.Ordered\]\(x S\) bool](<#IsSorted>)
- [func IsSortedFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\) bool](<#IsSortedFunc>)
- [func Join\[S any\]\(s \[\]\[\]S, sep \[\]S\) \[\]S](<#Join>)
- [func LastIndexSlice\[S E\]\(s, sep \[\]S\) int](<#LastIndexSlice>)
- [func Map\[S, T any\]\(s \[\]S, f func\(S\) T\) \[\]T](<#Map>)
- [func Max\[S \~\[\]E, E constraints.Ordered\]\(x S\) E](<#Max>)
- [func MaxFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\) E](<#MaxFunc>)
- [func Min\[S \~\[\]E, E constraints.Ordered\]\(x S\) E](<#Min>)
- [func MinFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\) E](<#MinFunc>)
- [func OverWithError\[S any\]\(s \[\]S, err error\) func\(func\(int, S\) bool\)](<#OverWithError>)
- [func Read\[S any\]\(arr \[\]S, offset int, limit int\) \[\]S](<#Read>)
- [func Reduce\[S, T any\]\(s \[\]S, initial T, f func\(T, S\) T\) T](<#Reduce>)
- [func RemoveWith\[S any\]\(s \[\]S, fn func\(a S\) bool\) \[\]S](<#RemoveWith>)
- [func Repeat\[S any\]\(b \[\]S, count int\) \[\]S](<#Repeat>)
- [func Replace\[S \~\[\]E, E any\]\(s S, i, j int, v ...E\) S](<#Replace>)
- [func Reverse\[S \~\[\]E, E any\]\(s S\)](<#Reverse>)
- [func Sort\[S \~\[\]E, E constraints.Ordered\]\(x S\)](<#Sort>)
- [func SortFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\)](<#SortFunc>)
- [func SortStableFunc\[S \~\[\]E, E any\]\(x S, cmp func\(a, b E\) int\)](<#SortStableFunc>)
- [func Split\[S E\]\(s, sep \[\]S\) \[\]\[\]S](<#Split>)
- [func Transform\[S any, T any\]\(s \[\]S, f func\(S\) \(T, bool\)\) \[\]T](<#Transform>)
- [func Unique\[S E\]\(s \[\]S\) \[\]S](<#Unique>)
- [type E](<#E>)


## Variables

<a name="ErrWrongIndex"></a>

```go
var (
    // ErrWrongIndex is an error returned when an index is out of range.
    ErrWrongIndex = errors.New("slices: index out of range")
)
```

<a name="Append"></a>
## func [Append](<https://github.com/goexts/generic/blob/main/slices/slice.go#L18>)

```go
func Append[S any](arr []S, v S) ([]S, int)
```

Append appends the element v to the end of the slice s.

<a name="BinarySearch"></a>
## func [BinarySearch](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L13>)

```go
func BinarySearch[S ~[]E, E constraints.Ordered](x S, target E) (int, bool)
```



<a name="BinarySearchFunc"></a>
## func [BinarySearchFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L17>)

```go
func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)
```



<a name="Clip"></a>
## func [Clip](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L21>)

```go
func Clip[S ~[]E, E any](s S) S
```



<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L25>)

```go
func Clone[S ~[]E, E any](s S) S
```



<a name="Compact"></a>
## func [Compact](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L29>)

```go
func Compact[S ~[]E, E comparable](s S) S
```



<a name="CompactFunc"></a>
## func [CompactFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L33>)

```go
func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S
```



<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L37>)

```go
func Compare[S ~[]E, E constraints.Ordered](s1, s2 S) int
```



<a name="CompareFunc"></a>
## func [CompareFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L41>)

```go
func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int
```



<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L45>)

```go
func Contains[S ~[]E, E comparable](s S, v E) bool
```



<a name="ContainsFunc"></a>
## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L49>)

```go
func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool
```



<a name="CopyAt"></a>
## func [CopyAt](<https://github.com/goexts/generic/blob/main/slices/slice.go#L26>)

```go
func CopyAt[S any](s, t []S, i int) []S
```

CopyAt copies the elements from t into s at the specified index. It panics if the index is negative. If the required length is greater than the length of s, s is grown to accommodate the new elements.

<a name="Count"></a>
## func [Count](<https://github.com/goexts/generic/blob/main/slices/slice.go#L41>)

```go
func Count[S E](s, sub []S) int
```

Count counts the number of non\-overlapping instances of substr in s.

<a name="CountArray"></a>
## func [CountArray](<https://github.com/goexts/generic/blob/main/slices/slice.go#L60>)

```go
func CountArray[S E](ss []S, s S) int
```

CountArray counts the number of occurrences of c in s.

<a name="Cut"></a>
## func [Cut](<https://github.com/goexts/generic/blob/main/slices/slice.go#L74>)

```go
func Cut[S E](s, sep []S) (before, after []S, found bool)
```

Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, nil, false.

<a name="Delete"></a>
## func [Delete](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L53>)

```go
func Delete[S ~[]E, E any](s S, i, j int) S
```



<a name="DeleteFunc"></a>
## func [DeleteFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L57>)

```go
func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S
```



<a name="Equal"></a>
## func [Equal](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L61>)

```go
func Equal[S ~[]E, E comparable](s1, s2 S) bool
```



<a name="EqualFunc"></a>
## func [EqualFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L65>)

```go
func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool
```



<a name="Filter"></a>
## func [Filter](<https://github.com/goexts/generic/blob/main/slices/slice.go#L82>)

```go
func Filter[S any](s []S, f func(S) bool) []S
```

Filter returns a new slice containing all elements of s for which f\(s\) is true.

<a name="FilterExcluded"></a>
## func [FilterExcluded](<https://github.com/goexts/generic/blob/main/slices/slice.go#L121>)

```go
func FilterExcluded[S comparable](s []S, excludes []S) []S
```

FilterExcluded returns a new slice containing all elements of s that are not present in excludes.

<a name="FilterIncluded"></a>
## func [FilterIncluded](<https://github.com/goexts/generic/blob/main/slices/slice.go#L96>)

```go
func FilterIncluded[S comparable](s []S, includes []S) []S
```

FilterIncluded returns a new slice containing all elements of s that are present in includes.

<a name="Grow"></a>
## func [Grow](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L69>)

```go
func Grow[S ~[]E, E any](s S, n int) S
```



<a name="Index"></a>
## func [Index](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L73>)

```go
func Index[S ~[]E, E comparable](s S, v E) int
```



<a name="IndexFunc"></a>
## func [IndexFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L77>)

```go
func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int
```



<a name="IndexSlice"></a>
## func [IndexSlice](<https://github.com/goexts/generic/blob/main/slices/slice.go#L146>)

```go
func IndexSlice[S E](s, substr []S) int
```

IndexSlice returns the index of the first instance of substr in s, or \-1 if not present.

<a name="Insert"></a>
## func [Insert](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L81>)

```go
func Insert[S ~[]E, E any](s S, i int, v ...E) S
```



<a name="InsertWith"></a>
## func [InsertWith](<https://github.com/goexts/generic/blob/main/slices/slice.go#L170>)

```go
func InsertWith[S any](s []S, v S, fn func(a, b S) bool) []S
```

InsertWith inserts v into s at the first index where fn\(a, b\) is true.

<a name="IsSorted"></a>
## func [IsSorted](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L85>)

```go
func IsSorted[S ~[]E, E constraints.Ordered](x S) bool
```



<a name="IsSortedFunc"></a>
## func [IsSortedFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L89>)

```go
func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool
```



<a name="Join"></a>
## func [Join](<https://github.com/goexts/generic/blob/main/slices/slice.go#L180>)

```go
func Join[S any](s [][]S, sep []S) []S
```

Join concatenates the elements of s to create a single slice. The separator sep is placed between elements in the resulting slice.

<a name="LastIndexSlice"></a>
## func [LastIndexSlice](<https://github.com/goexts/generic/blob/main/slices/slice.go#L202>)

```go
func LastIndexSlice[S E](s, sep []S) int
```

LastIndexSlice returns the index of the last instance of sep in s, or \-1 if not present.

<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/slices/slice.go#L226>)

```go
func Map[S, T any](s []S, f func(S) T) []T
```

Map transforms a slice of one type to a slice of another type using a mapping function.

<a name="Max"></a>
## func [Max](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L93>)

```go
func Max[S ~[]E, E constraints.Ordered](x S) E
```



<a name="MaxFunc"></a>
## func [MaxFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L97>)

```go
func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E
```



<a name="Min"></a>
## func [Min](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L101>)

```go
func Min[S ~[]E, E constraints.Ordered](x S) E
```



<a name="MinFunc"></a>
## func [MinFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L105>)

```go
func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E
```



<a name="OverWithError"></a>
## func [OverWithError](<https://github.com/goexts/generic/blob/main/slices/slice.go#L238>)

```go
func OverWithError[S any](s []S, err error) func(func(int, S) bool)
```

OverWithError returns an iterator function for a slice that may have an associated error.

<a name="Read"></a>
## func [Read](<https://github.com/goexts/generic/blob/main/slices/slice.go#L252>)

```go
func Read[S any](arr []S, offset int, limit int) []S
```

Read returns a slice of s beginning at offset and with a length of limit.

<a name="Reduce"></a>
## func [Reduce](<https://github.com/goexts/generic/blob/main/slices/slice.go#L263>)

```go
func Reduce[S, T any](s []S, initial T, f func(T, S) T) T
```

Reduce aggregates all elements of a slice into a single value by applying a function.

<a name="RemoveWith"></a>
## func [RemoveWith](<https://github.com/goexts/generic/blob/main/slices/slice.go#L272>)

```go
func RemoveWith[S any](s []S, fn func(a S) bool) []S
```

RemoveWith removes elements from a slice based on a predicate function.

<a name="Repeat"></a>
## func [Repeat](<https://github.com/goexts/generic/blob/main/slices/slice.go#L283>)

```go
func Repeat[S any](b []S, count int) []S
```

Repeat returns a new slice consisting of count copies of the slice s.

<a name="Replace"></a>
## func [Replace](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L109>)

```go
func Replace[S ~[]E, E any](s S, i, j int, v ...E) S
```



<a name="Reverse"></a>
## func [Reverse](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L113>)

```go
func Reverse[S ~[]E, E any](s S)
```



<a name="Sort"></a>
## func [Sort](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L117>)

```go
func Sort[S ~[]E, E constraints.Ordered](x S)
```



<a name="SortFunc"></a>
## func [SortFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L121>)

```go
func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)
```



<a name="SortStableFunc"></a>
## func [SortStableFunc](<https://github.com/goexts/generic/blob/main/slices/slices.adapter.go#L125>)

```go
func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int)
```



<a name="Split"></a>
## func [Split](<https://github.com/goexts/generic/blob/main/slices/slice.go#L303>)

```go
func Split[S E](s, sep []S) [][]S
```

Split slices s into all subslices separated by sep.

<a name="Transform"></a>
## func [Transform](<https://github.com/goexts/generic/blob/main/slices/slice.go#L311>)

```go
func Transform[S any, T any](s []S, f func(S) (T, bool)) []T
```

Transform combines mapping and filtering a slice.

<a name="Unique"></a>
## func [Unique](<https://github.com/goexts/generic/blob/main/slices/slice.go#L325>)

```go
func Unique[S E](s []S) []S
```

Unique returns a new slice with duplicate elements removed.

<a name="E"></a>
## type [E](<https://github.com/goexts/generic/blob/main/slices/slice.go#L10>)

E is a shorthand for the comparable constraint.

```go
type E = comparable
```

# strings

```go
import "github.com/goexts/generic/strings"
```

Package strings provides a rich collection of functions for string manipulation.

This package is a generated adapter that mirrors the public API of the standard Go library's \`strings\` package. It offers a convenient way to access the rich set of standard string utilities.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`strings\` package.

Package strings implements the functions, types, and interfaces for the module.

Package strings contains generated code by adptool.

Package strings implements the functions, types, and interfaces for the module.

## Index

- [func Clone\(s string\) string](<#Clone>)
- [func Compare\(a, b string\) int](<#Compare>)
- [func Contains\(s, substr string\) bool](<#Contains>)
- [func ContainsAny\(s, chars string\) bool](<#ContainsAny>)
- [func ContainsFunc\(s string, f func\(rune\) bool\) bool](<#ContainsFunc>)
- [func ContainsRune\(s string, r rune\) bool](<#ContainsRune>)
- [func Count\(s, substr string\) int](<#Count>)
- [func Cut\(s, sep string\) \(before, after string, found bool\)](<#Cut>)
- [func CutPrefix\(s, prefix string\) \(after string, found bool\)](<#CutPrefix>)
- [func CutSuffix\(s, suffix string\) \(before string, found bool\)](<#CutSuffix>)
- [func EqualFold\(s, t string\) bool](<#EqualFold>)
- [func Fields\(s string\) \[\]string](<#Fields>)
- [func FieldsFunc\(s string, f func\(rune\) bool\) \[\]string](<#FieldsFunc>)
- [func FieldsFuncSeq\(s string, f func\(rune\) bool\) iter.Seq\[string\]](<#FieldsFuncSeq>)
- [func FieldsSeq\(s string\) iter.Seq\[string\]](<#FieldsSeq>)
- [func HasPrefix\(s, prefix string\) bool](<#HasPrefix>)
- [func HasSuffix\(s, suffix string\) bool](<#HasSuffix>)
- [func Index\(s, substr string\) int](<#Index>)
- [func IndexAny\(s, chars string\) int](<#IndexAny>)
- [func IndexByte\(s string, c byte\) int](<#IndexByte>)
- [func IndexFunc\(s string, f func\(rune\) bool\) int](<#IndexFunc>)
- [func IndexRune\(s string, r rune\) int](<#IndexRune>)
- [func Join\(elems \[\]string, sep string\) string](<#Join>)
- [func LastIndex\(s, substr string\) int](<#LastIndex>)
- [func LastIndexAny\(s, chars string\) int](<#LastIndexAny>)
- [func LastIndexByte\(s string, c byte\) int](<#LastIndexByte>)
- [func LastIndexFunc\(s string, f func\(rune\) bool\) int](<#LastIndexFunc>)
- [func Lines\(s string\) iter.Seq\[string\]](<#Lines>)
- [func Map\(mapping func\(rune\) rune, s string\) string](<#Map>)
- [func NewReader\(s string\) \*strings.Reader](<#NewReader>)
- [func NewReplacer\(oldnew ...string\) \*strings.Replacer](<#NewReplacer>)
- [func ParseOr\[T any\]\(s string, def ...T\) T](<#ParseOr>)
- [func Repeat\(s string, count int\) string](<#Repeat>)
- [func Replace\(s, old, new string, n int\) string](<#Replace>)
- [func ReplaceAll\(s, old, new string\) string](<#ReplaceAll>)
- [func Split\(s, sep string\) \[\]string](<#Split>)
- [func SplitAfter\(s, sep string\) \[\]string](<#SplitAfter>)
- [func SplitAfterN\(s, sep string, n int\) \[\]string](<#SplitAfterN>)
- [func SplitAfterSeq\(s, sep string\) iter.Seq\[string\]](<#SplitAfterSeq>)
- [func SplitN\(s, sep string, n int\) \[\]string](<#SplitN>)
- [func SplitSeq\(s, sep string\) iter.Seq\[string\]](<#SplitSeq>)
- [func Title\(s string\) string](<#Title>)
- [func ToLower\(s string\) string](<#ToLower>)
- [func ToLowerSpecial\(c unicode.SpecialCase, s string\) string](<#ToLowerSpecial>)
- [func ToTitle\(s string\) string](<#ToTitle>)
- [func ToTitleSpecial\(c unicode.SpecialCase, s string\) string](<#ToTitleSpecial>)
- [func ToUpper\(s string\) string](<#ToUpper>)
- [func ToUpperSpecial\(c unicode.SpecialCase, s string\) string](<#ToUpperSpecial>)
- [func ToValidUTF8\(s, replacement string\) string](<#ToValidUTF8>)
- [func Trim\(s, cutset string\) string](<#Trim>)
- [func TrimFunc\(s string, f func\(rune\) bool\) string](<#TrimFunc>)
- [func TrimLeft\(s, cutset string\) string](<#TrimLeft>)
- [func TrimLeftFunc\(s string, f func\(rune\) bool\) string](<#TrimLeftFunc>)
- [func TrimPrefix\(s, prefix string\) string](<#TrimPrefix>)
- [func TrimRight\(s, cutset string\) string](<#TrimRight>)
- [func TrimRightFunc\(s string, f func\(rune\) bool\) string](<#TrimRightFunc>)
- [func TrimSpace\(s string\) string](<#TrimSpace>)
- [func TrimSuffix\(s, suffix string\) string](<#TrimSuffix>)
- [type Builder](<#Builder>)
- [type Reader](<#Reader>)
- [type Replacer](<#Replacer>)


<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L20>)

```go
func Clone(s string) string
```



<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L24>)

```go
func Compare(a, b string) int
```



<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L28>)

```go
func Contains(s, substr string) bool
```



<a name="ContainsAny"></a>
## func [ContainsAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L32>)

```go
func ContainsAny(s, chars string) bool
```



<a name="ContainsFunc"></a>
## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L36>)

```go
func ContainsFunc(s string, f func(rune) bool) bool
```



<a name="ContainsRune"></a>
## func [ContainsRune](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L40>)

```go
func ContainsRune(s string, r rune) bool
```



<a name="Count"></a>
## func [Count](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L44>)

```go
func Count(s, substr string) int
```



<a name="Cut"></a>
## func [Cut](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L48>)

```go
func Cut(s, sep string) (before, after string, found bool)
```



<a name="CutPrefix"></a>
## func [CutPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L52>)

```go
func CutPrefix(s, prefix string) (after string, found bool)
```



<a name="CutSuffix"></a>
## func [CutSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L56>)

```go
func CutSuffix(s, suffix string) (before string, found bool)
```



<a name="EqualFold"></a>
## func [EqualFold](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L60>)

```go
func EqualFold(s, t string) bool
```



<a name="Fields"></a>
## func [Fields](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L64>)

```go
func Fields(s string) []string
```



<a name="FieldsFunc"></a>
## func [FieldsFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L68>)

```go
func FieldsFunc(s string, f func(rune) bool) []string
```



<a name="FieldsFuncSeq"></a>
## func [FieldsFuncSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L72>)

```go
func FieldsFuncSeq(s string, f func(rune) bool) iter.Seq[string]
```



<a name="FieldsSeq"></a>
## func [FieldsSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L76>)

```go
func FieldsSeq(s string) iter.Seq[string]
```



<a name="HasPrefix"></a>
## func [HasPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L80>)

```go
func HasPrefix(s, prefix string) bool
```



<a name="HasSuffix"></a>
## func [HasSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L84>)

```go
func HasSuffix(s, suffix string) bool
```



<a name="Index"></a>
## func [Index](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L88>)

```go
func Index(s, substr string) int
```



<a name="IndexAny"></a>
## func [IndexAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L92>)

```go
func IndexAny(s, chars string) int
```



<a name="IndexByte"></a>
## func [IndexByte](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L96>)

```go
func IndexByte(s string, c byte) int
```



<a name="IndexFunc"></a>
## func [IndexFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L100>)

```go
func IndexFunc(s string, f func(rune) bool) int
```



<a name="IndexRune"></a>
## func [IndexRune](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L104>)

```go
func IndexRune(s string, r rune) int
```



<a name="Join"></a>
## func [Join](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L108>)

```go
func Join(elems []string, sep string) string
```



<a name="LastIndex"></a>
## func [LastIndex](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L112>)

```go
func LastIndex(s, substr string) int
```



<a name="LastIndexAny"></a>
## func [LastIndexAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L116>)

```go
func LastIndexAny(s, chars string) int
```



<a name="LastIndexByte"></a>
## func [LastIndexByte](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L120>)

```go
func LastIndexByte(s string, c byte) int
```



<a name="LastIndexFunc"></a>
## func [LastIndexFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L124>)

```go
func LastIndexFunc(s string, f func(rune) bool) int
```



<a name="Lines"></a>
## func [Lines](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L128>)

```go
func Lines(s string) iter.Seq[string]
```



<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L132>)

```go
func Map(mapping func(rune) rune, s string) string
```



<a name="NewReader"></a>
## func [NewReader](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L136>)

```go
func NewReader(s string) *strings.Reader
```



<a name="NewReplacer"></a>
## func [NewReplacer](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L140>)

```go
func NewReplacer(oldnew ...string) *strings.Replacer
```



<a name="ParseOr"></a>
## func [ParseOr](<https://github.com/goexts/generic/blob/main/strings/parse.go#L15>)

```go
func ParseOr[T any](s string, def ...T) T
```

ParseOr converts a string to a specified type, with support for a default value. It supports all basic types \(int/uint variants, float, bool, string\) and JSON\-deserializable types. If parsing fails and a default value is provided, it returns the default value. If parsing fails and no default is provided, it panics.

<a name="Repeat"></a>
## func [Repeat](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L144>)

```go
func Repeat(s string, count int) string
```



<a name="Replace"></a>
## func [Replace](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L148>)

```go
func Replace(s, old, new string, n int) string
```



<a name="ReplaceAll"></a>
## func [ReplaceAll](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L152>)

```go
func ReplaceAll(s, old, new string) string
```



<a name="Split"></a>
## func [Split](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L156>)

```go
func Split(s, sep string) []string
```



<a name="SplitAfter"></a>
## func [SplitAfter](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L160>)

```go
func SplitAfter(s, sep string) []string
```



<a name="SplitAfterN"></a>
## func [SplitAfterN](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L164>)

```go
func SplitAfterN(s, sep string, n int) []string
```



<a name="SplitAfterSeq"></a>
## func [SplitAfterSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L168>)

```go
func SplitAfterSeq(s, sep string) iter.Seq[string]
```



<a name="SplitN"></a>
## func [SplitN](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L172>)

```go
func SplitN(s, sep string, n int) []string
```



<a name="SplitSeq"></a>
## func [SplitSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L176>)

```go
func SplitSeq(s, sep string) iter.Seq[string]
```



<a name="Title"></a>
## func [Title](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L180>)

```go
func Title(s string) string
```



<a name="ToLower"></a>
## func [ToLower](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L184>)

```go
func ToLower(s string) string
```



<a name="ToLowerSpecial"></a>
## func [ToLowerSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L188>)

```go
func ToLowerSpecial(c unicode.SpecialCase, s string) string
```



<a name="ToTitle"></a>
## func [ToTitle](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L192>)

```go
func ToTitle(s string) string
```



<a name="ToTitleSpecial"></a>
## func [ToTitleSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L196>)

```go
func ToTitleSpecial(c unicode.SpecialCase, s string) string
```



<a name="ToUpper"></a>
## func [ToUpper](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L200>)

```go
func ToUpper(s string) string
```



<a name="ToUpperSpecial"></a>
## func [ToUpperSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L204>)

```go
func ToUpperSpecial(c unicode.SpecialCase, s string) string
```



<a name="ToValidUTF8"></a>
## func [ToValidUTF8](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L208>)

```go
func ToValidUTF8(s, replacement string) string
```



<a name="Trim"></a>
## func [Trim](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L212>)

```go
func Trim(s, cutset string) string
```



<a name="TrimFunc"></a>
## func [TrimFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L216>)

```go
func TrimFunc(s string, f func(rune) bool) string
```



<a name="TrimLeft"></a>
## func [TrimLeft](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L220>)

```go
func TrimLeft(s, cutset string) string
```



<a name="TrimLeftFunc"></a>
## func [TrimLeftFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L224>)

```go
func TrimLeftFunc(s string, f func(rune) bool) string
```



<a name="TrimPrefix"></a>
## func [TrimPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L228>)

```go
func TrimPrefix(s, prefix string) string
```



<a name="TrimRight"></a>
## func [TrimRight](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L232>)

```go
func TrimRight(s, cutset string) string
```



<a name="TrimRightFunc"></a>
## func [TrimRightFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L236>)

```go
func TrimRightFunc(s string, f func(rune) bool) string
```



<a name="TrimSpace"></a>
## func [TrimSpace](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L240>)

```go
func TrimSpace(s string) string
```



<a name="TrimSuffix"></a>
## func [TrimSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L244>)

```go
func TrimSuffix(s, suffix string) string
```



<a name="Builder"></a>
## type [Builder](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L15>)



```go
type Builder = strings.Builder
```

<a name="Reader"></a>
## type [Reader](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L16>)



```go
type Reader = strings.Reader
```

<a name="Replacer"></a>
## type [Replacer](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L17>)



```go
type Replacer = strings.Replacer
```

# bytes

```go
import "github.com/goexts/generic/slices/bytes"
```

Package bytes contains generated code by adptool.

Package bytes provides a rich set of functions for the manipulation of byte slices.

This package is a generated adapter and mirrors the public API of the standard Go library's \`bytes\` package. It offers a convenient way to access the rich set of standard byte slice utilities within the generic context of this library.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`bytes\` package.

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Clone\(b \[\]byte\) \[\]byte](<#Clone>)
- [func Compare\(a, b \[\]byte\) int](<#Compare>)
- [func Contains\(b, subslice \[\]byte\) bool](<#Contains>)
- [func ContainsAny\(b \[\]byte, chars string\) bool](<#ContainsAny>)
- [func ContainsFunc\(b \[\]byte, f func\(rune\) bool\) bool](<#ContainsFunc>)
- [func ContainsRune\(b \[\]byte, r rune\) bool](<#ContainsRune>)
- [func Count\(s, sep \[\]byte\) int](<#Count>)
- [func Cut\(s, sep \[\]byte\) \(before, after \[\]byte, found bool\)](<#Cut>)
- [func CutPrefix\(s, prefix \[\]byte\) \(after \[\]byte, found bool\)](<#CutPrefix>)
- [func CutSuffix\(s, suffix \[\]byte\) \(before \[\]byte, found bool\)](<#CutSuffix>)
- [func Equal\(a, b \[\]byte\) bool](<#Equal>)
- [func EqualFold\(s, t \[\]byte\) bool](<#EqualFold>)
- [func Fields\(s \[\]byte\) \[\]\[\]byte](<#Fields>)
- [func FieldsFunc\(s \[\]byte, f func\(rune\) bool\) \[\]\[\]byte](<#FieldsFunc>)
- [func FieldsFuncSeq\(s \[\]byte, f func\(rune\) bool\) iter.Seq\[\[\]byte\]](<#FieldsFuncSeq>)
- [func FieldsSeq\(s \[\]byte\) iter.Seq\[\[\]byte\]](<#FieldsSeq>)
- [func HasPrefix\(s, prefix \[\]byte\) bool](<#HasPrefix>)
- [func HasSuffix\(s, suffix \[\]byte\) bool](<#HasSuffix>)
- [func Index\(s, sep \[\]byte\) int](<#Index>)
- [func IndexAny\(s \[\]byte, chars string\) int](<#IndexAny>)
- [func IndexByte\(b \[\]byte, c byte\) int](<#IndexByte>)
- [func IndexFunc\(s \[\]byte, f func\(r rune\) bool\) int](<#IndexFunc>)
- [func IndexRune\(s \[\]byte, r rune\) int](<#IndexRune>)
- [func Join\(s \[\]\[\]byte, sep \[\]byte\) \[\]byte](<#Join>)
- [func LastIndex\(s, sep \[\]byte\) int](<#LastIndex>)
- [func LastIndexAny\(s \[\]byte, chars string\) int](<#LastIndexAny>)
- [func LastIndexByte\(s \[\]byte, c byte\) int](<#LastIndexByte>)
- [func LastIndexFunc\(s \[\]byte, f func\(r rune\) bool\) int](<#LastIndexFunc>)
- [func Lines\(s \[\]byte\) iter.Seq\[\[\]byte\]](<#Lines>)
- [func Map\(mapping func\(r rune\) rune, s \[\]byte\) \[\]byte](<#Map>)
- [func NewBuffer\(buf \[\]byte\) \*bytes.Buffer](<#NewBuffer>)
- [func NewBufferString\(s string\) \*bytes.Buffer](<#NewBufferString>)
- [func NewReader\(b \[\]byte\) \*bytes.Reader](<#NewReader>)
- [func Repeat\(b \[\]byte, count int\) \[\]byte](<#Repeat>)
- [func Replace\(s, old, new \[\]byte, n int\) \[\]byte](<#Replace>)
- [func ReplaceAll\(s, old, new \[\]byte\) \[\]byte](<#ReplaceAll>)
- [func Runes\(s \[\]byte\) \[\]rune](<#Runes>)
- [func Split\(s, sep \[\]byte\) \[\]\[\]byte](<#Split>)
- [func SplitAfter\(s, sep \[\]byte\) \[\]\[\]byte](<#SplitAfter>)
- [func SplitAfterN\(s, sep \[\]byte, n int\) \[\]\[\]byte](<#SplitAfterN>)
- [func SplitAfterSeq\(s, sep \[\]byte\) iter.Seq\[\[\]byte\]](<#SplitAfterSeq>)
- [func SplitN\(s, sep \[\]byte, n int\) \[\]\[\]byte](<#SplitN>)
- [func SplitSeq\(s, sep \[\]byte\) iter.Seq\[\[\]byte\]](<#SplitSeq>)
- [func Title\(s \[\]byte\) \[\]byte](<#Title>)
- [func ToLower\(s \[\]byte\) \[\]byte](<#ToLower>)
- [func ToLowerSpecial\(c unicode.SpecialCase, s \[\]byte\) \[\]byte](<#ToLowerSpecial>)
- [func ToTitle\(s \[\]byte\) \[\]byte](<#ToTitle>)
- [func ToTitleSpecial\(c unicode.SpecialCase, s \[\]byte\) \[\]byte](<#ToTitleSpecial>)
- [func ToUpper\(s \[\]byte\) \[\]byte](<#ToUpper>)
- [func ToUpperSpecial\(c unicode.SpecialCase, s \[\]byte\) \[\]byte](<#ToUpperSpecial>)
- [func ToValidUTF8\(s, replacement \[\]byte\) \[\]byte](<#ToValidUTF8>)
- [func Trim\(s \[\]byte, cutset string\) \[\]byte](<#Trim>)
- [func TrimFunc\(s \[\]byte, f func\(r rune\) bool\) \[\]byte](<#TrimFunc>)
- [func TrimLeft\(s \[\]byte, cutset string\) \[\]byte](<#TrimLeft>)
- [func TrimLeftFunc\(s \[\]byte, f func\(r rune\) bool\) \[\]byte](<#TrimLeftFunc>)
- [func TrimPrefix\(s, prefix \[\]byte\) \[\]byte](<#TrimPrefix>)
- [func TrimRight\(s \[\]byte, cutset string\) \[\]byte](<#TrimRight>)
- [func TrimRightFunc\(s \[\]byte, f func\(r rune\) bool\) \[\]byte](<#TrimRightFunc>)
- [func TrimSpace\(s \[\]byte\) \[\]byte](<#TrimSpace>)
- [func TrimSuffix\(s, suffix \[\]byte\) \[\]byte](<#TrimSuffix>)
- [type Buffer](<#Buffer>)
- [type Bytes](<#Bytes>)
  - [func FromString\(s string\) Bytes](<#FromString>)
  - [func \(b Bytes\) Clone\(\) Bytes](<#Bytes.Clone>)
  - [func \(b Bytes\) Contains\(sub \[\]byte\) bool](<#Bytes.Contains>)
  - [func \(b Bytes\) FindString\(s string\) int](<#Bytes.FindString>)
  - [func \(b Bytes\) HasPrefix\(prefix \[\]byte\) bool](<#Bytes.HasPrefix>)
  - [func \(b Bytes\) HasSuffix\(suffix \[\]byte\) bool](<#Bytes.HasSuffix>)
  - [func \(b Bytes\) Index\(sub \[\]byte\) int](<#Bytes.Index>)
  - [func \(b Bytes\) Read\(offset int, limit int\) \[\]byte](<#Bytes.Read>)
  - [func \(b Bytes\) ReadString\(offset int, limit int\) string](<#Bytes.ReadString>)
  - [func \(b Bytes\) Replace\(old, replacement \[\]byte, n int\) \[\]byte](<#Bytes.Replace>)
  - [func \(b Bytes\) String\(\) string](<#Bytes.String>)
  - [func \(b Bytes\) Trim\(cutset string\) \[\]byte](<#Bytes.Trim>)
  - [func \(b Bytes\) TrimPrefix\(prefix \[\]byte\) \[\]byte](<#Bytes.TrimPrefix>)
  - [func \(b Bytes\) TrimSpace\(\) \[\]byte](<#Bytes.TrimSpace>)
  - [func \(b Bytes\) TrimSuffix\(suffix \[\]byte\) \[\]byte](<#Bytes.TrimSuffix>)
- [type Reader](<#Reader>)


## Constants

<a name="MinRead"></a>

```go
const MinRead = bytes.MinRead
```

## Variables

<a name="ErrTooLarge"></a>

```go
var ErrTooLarge = bytes.ErrTooLarge
```

<a name="Clone"></a>
## func [Clone](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L23>)

```go
func Clone(b []byte) []byte
```



<a name="Compare"></a>
## func [Compare](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L27>)

```go
func Compare(a, b []byte) int
```



<a name="Contains"></a>
## func [Contains](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L31>)

```go
func Contains(b, subslice []byte) bool
```



<a name="ContainsAny"></a>
## func [ContainsAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L35>)

```go
func ContainsAny(b []byte, chars string) bool
```



<a name="ContainsFunc"></a>
## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L39>)

```go
func ContainsFunc(b []byte, f func(rune) bool) bool
```



<a name="ContainsRune"></a>
## func [ContainsRune](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L43>)

```go
func ContainsRune(b []byte, r rune) bool
```



<a name="Count"></a>
## func [Count](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L47>)

```go
func Count(s, sep []byte) int
```



<a name="Cut"></a>
## func [Cut](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L51>)

```go
func Cut(s, sep []byte) (before, after []byte, found bool)
```



<a name="CutPrefix"></a>
## func [CutPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L55>)

```go
func CutPrefix(s, prefix []byte) (after []byte, found bool)
```



<a name="CutSuffix"></a>
## func [CutSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L59>)

```go
func CutSuffix(s, suffix []byte) (before []byte, found bool)
```



<a name="Equal"></a>
## func [Equal](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L63>)

```go
func Equal(a, b []byte) bool
```



<a name="EqualFold"></a>
## func [EqualFold](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L67>)

```go
func EqualFold(s, t []byte) bool
```



<a name="Fields"></a>
## func [Fields](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L71>)

```go
func Fields(s []byte) [][]byte
```



<a name="FieldsFunc"></a>
## func [FieldsFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L75>)

```go
func FieldsFunc(s []byte, f func(rune) bool) [][]byte
```



<a name="FieldsFuncSeq"></a>
## func [FieldsFuncSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L79>)

```go
func FieldsFuncSeq(s []byte, f func(rune) bool) iter.Seq[[]byte]
```



<a name="FieldsSeq"></a>
## func [FieldsSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L83>)

```go
func FieldsSeq(s []byte) iter.Seq[[]byte]
```



<a name="HasPrefix"></a>
## func [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L87>)

```go
func HasPrefix(s, prefix []byte) bool
```



<a name="HasSuffix"></a>
## func [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L91>)

```go
func HasSuffix(s, suffix []byte) bool
```



<a name="Index"></a>
## func [Index](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L95>)

```go
func Index(s, sep []byte) int
```



<a name="IndexAny"></a>
## func [IndexAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L99>)

```go
func IndexAny(s []byte, chars string) int
```



<a name="IndexByte"></a>
## func [IndexByte](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L103>)

```go
func IndexByte(b []byte, c byte) int
```



<a name="IndexFunc"></a>
## func [IndexFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L107>)

```go
func IndexFunc(s []byte, f func(r rune) bool) int
```



<a name="IndexRune"></a>
## func [IndexRune](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L111>)

```go
func IndexRune(s []byte, r rune) int
```



<a name="Join"></a>
## func [Join](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L115>)

```go
func Join(s [][]byte, sep []byte) []byte
```



<a name="LastIndex"></a>
## func [LastIndex](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L119>)

```go
func LastIndex(s, sep []byte) int
```



<a name="LastIndexAny"></a>
## func [LastIndexAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L123>)

```go
func LastIndexAny(s []byte, chars string) int
```



<a name="LastIndexByte"></a>
## func [LastIndexByte](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L127>)

```go
func LastIndexByte(s []byte, c byte) int
```



<a name="LastIndexFunc"></a>
## func [LastIndexFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L131>)

```go
func LastIndexFunc(s []byte, f func(r rune) bool) int
```



<a name="Lines"></a>
## func [Lines](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L135>)

```go
func Lines(s []byte) iter.Seq[[]byte]
```



<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L139>)

```go
func Map(mapping func(r rune) rune, s []byte) []byte
```



<a name="NewBuffer"></a>
## func [NewBuffer](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L143>)

```go
func NewBuffer(buf []byte) *bytes.Buffer
```



<a name="NewBufferString"></a>
## func [NewBufferString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L147>)

```go
func NewBufferString(s string) *bytes.Buffer
```



<a name="NewReader"></a>
## func [NewReader](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L151>)

```go
func NewReader(b []byte) *bytes.Reader
```



<a name="Repeat"></a>
## func [Repeat](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L155>)

```go
func Repeat(b []byte, count int) []byte
```



<a name="Replace"></a>
## func [Replace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L159>)

```go
func Replace(s, old, new []byte, n int) []byte
```



<a name="ReplaceAll"></a>
## func [ReplaceAll](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L163>)

```go
func ReplaceAll(s, old, new []byte) []byte
```



<a name="Runes"></a>
## func [Runes](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L167>)

```go
func Runes(s []byte) []rune
```



<a name="Split"></a>
## func [Split](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L171>)

```go
func Split(s, sep []byte) [][]byte
```



<a name="SplitAfter"></a>
## func [SplitAfter](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L175>)

```go
func SplitAfter(s, sep []byte) [][]byte
```



<a name="SplitAfterN"></a>
## func [SplitAfterN](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L179>)

```go
func SplitAfterN(s, sep []byte, n int) [][]byte
```



<a name="SplitAfterSeq"></a>
## func [SplitAfterSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L183>)

```go
func SplitAfterSeq(s, sep []byte) iter.Seq[[]byte]
```



<a name="SplitN"></a>
## func [SplitN](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L187>)

```go
func SplitN(s, sep []byte, n int) [][]byte
```



<a name="SplitSeq"></a>
## func [SplitSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L191>)

```go
func SplitSeq(s, sep []byte) iter.Seq[[]byte]
```



<a name="Title"></a>
## func [Title](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L195>)

```go
func Title(s []byte) []byte
```



<a name="ToLower"></a>
## func [ToLower](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L199>)

```go
func ToLower(s []byte) []byte
```



<a name="ToLowerSpecial"></a>
## func [ToLowerSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L203>)

```go
func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte
```



<a name="ToTitle"></a>
## func [ToTitle](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L207>)

```go
func ToTitle(s []byte) []byte
```



<a name="ToTitleSpecial"></a>
## func [ToTitleSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L211>)

```go
func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte
```



<a name="ToUpper"></a>
## func [ToUpper](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L215>)

```go
func ToUpper(s []byte) []byte
```



<a name="ToUpperSpecial"></a>
## func [ToUpperSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L219>)

```go
func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte
```



<a name="ToValidUTF8"></a>
## func [ToValidUTF8](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L223>)

```go
func ToValidUTF8(s, replacement []byte) []byte
```



<a name="Trim"></a>
## func [Trim](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L227>)

```go
func Trim(s []byte, cutset string) []byte
```



<a name="TrimFunc"></a>
## func [TrimFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L231>)

```go
func TrimFunc(s []byte, f func(r rune) bool) []byte
```



<a name="TrimLeft"></a>
## func [TrimLeft](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L235>)

```go
func TrimLeft(s []byte, cutset string) []byte
```



<a name="TrimLeftFunc"></a>
## func [TrimLeftFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L239>)

```go
func TrimLeftFunc(s []byte, f func(r rune) bool) []byte
```



<a name="TrimPrefix"></a>
## func [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L243>)

```go
func TrimPrefix(s, prefix []byte) []byte
```



<a name="TrimRight"></a>
## func [TrimRight](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L247>)

```go
func TrimRight(s []byte, cutset string) []byte
```



<a name="TrimRightFunc"></a>
## func [TrimRightFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L251>)

```go
func TrimRightFunc(s []byte, f func(r rune) bool) []byte
```



<a name="TrimSpace"></a>
## func [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L255>)

```go
func TrimSpace(s []byte) []byte
```



<a name="TrimSuffix"></a>
## func [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L259>)

```go
func TrimSuffix(s, suffix []byte) []byte
```



<a name="Buffer"></a>
## type [Buffer](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L19>)



```go
type Buffer = bytes.Buffer
```

<a name="Bytes"></a>
## type [Bytes](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L11>)

Bytes is a type alias for \[\]byte to provide methods.

```go
type Bytes []byte
```

<a name="FromString"></a>
### func [FromString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L90>)

```go
func FromString(s string) Bytes
```

FromString converts a string to a Bytes slice.

<a name="Bytes.Clone"></a>
### func \(Bytes\) [Clone](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L85>)

```go
func (b Bytes) Clone() Bytes
```

Clone returns a copy of the Bytes slice.

<a name="Bytes.Contains"></a>
### func \(Bytes\) [Contains](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L70>)

```go
func (b Bytes) Contains(sub []byte) bool
```

Contains reports whether sub is within b.

<a name="Bytes.FindString"></a>
### func \(Bytes\) [FindString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L35>)

```go
func (b Bytes) FindString(s string) int
```

FindString returns the index of the first instance of s in b, or \-1 if s is not present in b.

<a name="Bytes.HasPrefix"></a>
### func \(Bytes\) [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L75>)

```go
func (b Bytes) HasPrefix(prefix []byte) bool
```

HasPrefix tests whether the byte slice b begins with prefix.

<a name="Bytes.HasSuffix"></a>
### func \(Bytes\) [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L80>)

```go
func (b Bytes) HasSuffix(suffix []byte) bool
```

HasSuffix tests whether the byte slice b ends with suffix.

<a name="Bytes.Index"></a>
### func \(Bytes\) [Index](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L30>)

```go
func (b Bytes) Index(sub []byte) int
```

Index returns the index of the first instance of sub in b, or \-1 if sub is not present in b.

<a name="Bytes.Read"></a>
### func \(Bytes\) [Read](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L14>)

```go
func (b Bytes) Read(offset int, limit int) []byte
```

Read returns a slice of the Bytes s beginning at offset and length limit.

<a name="Bytes.ReadString"></a>
### func \(Bytes\) [ReadString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L25>)

```go
func (b Bytes) ReadString(offset int, limit int) string
```

ReadString returns a string of the Bytes s beginning at offset and length limit.

<a name="Bytes.Replace"></a>
### func \(Bytes\) [Replace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L65>)

```go
func (b Bytes) Replace(old, replacement []byte, n int) []byte
```

Replace returns a copy of the slice with the first n non\-overlapping instances of old replaced by replacement.

<a name="Bytes.String"></a>
### func \(Bytes\) [String](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L40>)

```go
func (b Bytes) String() string
```

String converts the Bytes slice to a string.

<a name="Bytes.Trim"></a>
### func \(Bytes\) [Trim](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L45>)

```go
func (b Bytes) Trim(cutset string) []byte
```

Trim returns a slice of the bytes, with all leading and trailing bytes contained in cutset removed.

<a name="Bytes.TrimPrefix"></a>
### func \(Bytes\) [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L55>)

```go
func (b Bytes) TrimPrefix(prefix []byte) []byte
```

TrimPrefix returns b without the provided leading prefix.

<a name="Bytes.TrimSpace"></a>
### func \(Bytes\) [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L50>)

```go
func (b Bytes) TrimSpace() []byte
```

TrimSpace returns a slice of the bytes, with all leading and trailing white space removed.

<a name="Bytes.TrimSuffix"></a>
### func \(Bytes\) [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L60>)

```go
func (b Bytes) TrimSuffix(suffix []byte) []byte
```

TrimSuffix returns b without the provided trailing suffix.

<a name="Reader"></a>
## type [Reader](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L20>)



```go
type Reader = bytes.Reader
```

# runes

```go
import "github.com/goexts/generic/slices/runes"
```

Package runes provides a rich set of functions for the manipulation of rune slices \(\`\[\]rune\`\).

This package is essential for correct, Unicode\-aware text processing at the code point level. It is a generated adapter that mirrors the public API of the Go experimental package \`golang.org/x/text/runes\`, offering convenient access to its specialized utilities.

For detailed information on the behavior of specific functions and the underlying Unicode algorithms, please refer to the official documentation for the \`golang.org/x/text/runes\` package.

Package runes contains generated code by adptool.

## Index

- [func Count\(r, sub \[\]rune\) int](<#Count>)
- [func If\(s runes.Set, tIn, tNotIn transform.Transformer\) runes.Transformer](<#If>)
- [func In\(rt \*unicode.RangeTable\) runes.Set](<#In>)
- [func Index\(r, sub \[\]rune\) int](<#Index>)
- [func Map\(mapping func\(rune\) rune\) runes.Transformer](<#Map>)
- [func NotIn\(rt \*unicode.RangeTable\) runes.Set](<#NotIn>)
- [func Predicate\(f func\(rune\) bool\) runes.Set](<#Predicate>)
- [func Remove\(s runes.Set\) runes.Transformer](<#Remove>)
- [func ReplaceIllFormed\(\) runes.Transformer](<#ReplaceIllFormed>)
- [type Runes](<#Runes>)
  - [func FromString\(s string\) Runes](<#FromString>)
  - [func \(r Runes\) Clone\(\) Runes](<#Runes.Clone>)
  - [func \(r Runes\) Contains\(sub \[\]rune\) bool](<#Runes.Contains>)
  - [func \(r Runes\) FindString\(s string\) int](<#Runes.FindString>)
  - [func \(r Runes\) HasPrefix\(prefix \[\]rune\) bool](<#Runes.HasPrefix>)
  - [func \(r Runes\) HasSuffix\(suffix \[\]rune\) bool](<#Runes.HasSuffix>)
  - [func \(r Runes\) Index\(sub \[\]rune\) int](<#Runes.Index>)
  - [func \(r Runes\) Read\(offset int, limit int\) \[\]rune](<#Runes.Read>)
  - [func \(r Runes\) ReadString\(offset int, limit int\) string](<#Runes.ReadString>)
  - [func \(r Runes\) Replace\(old, replacement \[\]rune, n int\) \[\]rune](<#Runes.Replace>)
  - [func \(r Runes\) String\(\) string](<#Runes.String>)
  - [func \(r Runes\) StringArray\(\) \[\]string](<#Runes.StringArray>)
  - [func \(r Runes\) ToBytes\(\) \[\]byte](<#Runes.ToBytes>)
  - [func \(r Runes\) Trim\(cutset string\) \[\]rune](<#Runes.Trim>)
  - [func \(r Runes\) TrimPrefix\(prefix \[\]rune\) \[\]rune](<#Runes.TrimPrefix>)
  - [func \(r Runes\) TrimSpace\(\) \[\]rune](<#Runes.TrimSpace>)
  - [func \(r Runes\) TrimSuffix\(suffix \[\]rune\) \[\]rune](<#Runes.TrimSuffix>)
- [type Set](<#Set>)
- [type Transformer](<#Transformer>)


<a name="Count"></a>
## func [Count](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L225>)

```go
func Count(r, sub []rune) int
```

Count counts the number of non\-overlapping instances of sub in r.

<a name="If"></a>
## func [If](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L20>)

```go
func If(s runes.Set, tIn, tNotIn transform.Transformer) runes.Transformer
```



<a name="In"></a>
## func [In](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L24>)

```go
func In(rt *unicode.RangeTable) runes.Set
```



<a name="Index"></a>
## func [Index](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L173>)

```go
func Index(r, sub []rune) int
```

Index returns the index of the first instance of sub in r, or \-1 if sub is not present in r.

<a name="Map"></a>
## func [Map](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L28>)

```go
func Map(mapping func(rune) rune) runes.Transformer
```



<a name="NotIn"></a>
## func [NotIn](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L32>)

```go
func NotIn(rt *unicode.RangeTable) runes.Set
```



<a name="Predicate"></a>
## func [Predicate](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L36>)

```go
func Predicate(f func(rune) bool) runes.Set
```



<a name="Remove"></a>
## func [Remove](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L40>)

```go
func Remove(s runes.Set) runes.Transformer
```



<a name="ReplaceIllFormed"></a>
## func [ReplaceIllFormed](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L44>)

```go
func ReplaceIllFormed() runes.Transformer
```



<a name="Runes"></a>
## type [Runes](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L12>)

Runes is a type alias for \[\]rune to provide methods.

```go
type Runes []rune
```

<a name="FromString"></a>
### func [FromString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L168>)

```go
func FromString(s string) Runes
```

FromString converts a string to a rune slice \(\[\]rune\). This is a convenience function that is equivalent to \`\[\]rune\(s\)\`.

<a name="Runes.Clone"></a>
### func \(Runes\) [Clone](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L162>)

```go
func (r Runes) Clone() Runes
```

Clone returns a copy of the Runes slice.

<a name="Runes.Contains"></a>
### func \(Runes\) [Contains](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L147>)

```go
func (r Runes) Contains(sub []rune) bool
```

Contains reports whether sub is within r.

<a name="Runes.FindString"></a>
### func \(Runes\) [FindString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L38>)

```go
func (r Runes) FindString(s string) int
```

FindString returns the index of the first instance of s in r, or \-1 if s is not present in r.

<a name="Runes.HasPrefix"></a>
### func \(Runes\) [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L152>)

```go
func (r Runes) HasPrefix(prefix []rune) bool
```

HasPrefix tests whether the Runes slice s begins with prefix.

<a name="Runes.HasSuffix"></a>
### func \(Runes\) [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L157>)

```go
func (r Runes) HasSuffix(suffix []rune) bool
```

HasSuffix tests whether the Runes slice s ends with suffix.

<a name="Runes.Index"></a>
### func \(Runes\) [Index](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L33>)

```go
func (r Runes) Index(sub []rune) int
```

Index returns the index of the first instance of sub in r, or \-1 if sub is not present in r.

<a name="Runes.Read"></a>
### func \(Runes\) [Read](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L15>)

```go
func (r Runes) Read(offset int, limit int) []rune
```

Read returns a slice of the Runes s beginning at offset and length limit.

<a name="Runes.ReadString"></a>
### func \(Runes\) [ReadString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L28>)

```go
func (r Runes) ReadString(offset int, limit int) string
```

ReadString returns a string of the Runes s beginning at offset and length limit.

<a name="Runes.Replace"></a>
### func \(Runes\) [Replace](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L113>)

```go
func (r Runes) Replace(old, replacement []rune, n int) []rune
```

Replace returns a copy of the slice with the first n non\-overlapping instances of old replaced by replacement.

<a name="Runes.String"></a>
### func \(Runes\) [String](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L52>)

```go
func (r Runes) String() string
```

String converts the Runes slice to a string.

<a name="Runes.StringArray"></a>
### func \(Runes\) [StringArray](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L43>)

```go
func (r Runes) StringArray() []string
```

StringArray converts each rune to a string and returns a slice of strings.

<a name="Runes.ToBytes"></a>
### func \(Runes\) [ToBytes](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L57>)

```go
func (r Runes) ToBytes() []byte
```

ToBytes converts the rune slice back to a UTF\-8 encoded byte slice.

<a name="Runes.Trim"></a>
### func \(Runes\) [Trim](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L62>)

```go
func (r Runes) Trim(cutset string) []rune
```

Trim returns a slice of the runes, with all leading and trailing runes contained in cutset removed.

<a name="Runes.TrimPrefix"></a>
### func \(Runes\) [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L97>)

```go
func (r Runes) TrimPrefix(prefix []rune) []rune
```

TrimPrefix returns s without the provided leading prefix.

<a name="Runes.TrimSpace"></a>
### func \(Runes\) [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L80>)

```go
func (r Runes) TrimSpace() []rune
```

TrimSpace returns a slice of the runes, with all leading and trailing white space removed.

<a name="Runes.TrimSuffix"></a>
### func \(Runes\) [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L105>)

```go
func (r Runes) TrimSuffix(suffix []rune) []rune
```

TrimSuffix returns s without the provided trailing suffix.

<a name="Set"></a>
## type [Set](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L16>)



```go
type Set = runes.Set
```

<a name="Transformer"></a>
## type [Transformer](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L17>)



```go
type Transformer = runes.Transformer
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
