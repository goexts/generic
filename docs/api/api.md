<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cmp

```go
import "github.com/goexts/generic/cmp"
```

Package cmp provides generic, type\-safe functions for comparing ordered types.

This package offers fundamental comparison utilities like Min, Max, and Clamp. Its central function, Compare, is designed to be fully compatible with the \`slices.SortFunc\`, making it easy to sort slices of any ordered type.

\# Practical Usage

Stable multi\-level sorting \(Report Q9\):

```
type Employee struct { Department string; Seniority int; Name string }
func SortEmployees(employees []Employee) {
	sort.SliceStable(employees, func(i, j int) bool {
		// Department (A-Z)
		if employees[i].Department != employees[j].Department { return employees[i].Department < employees[j].Department }
		// Seniority (Descending)
		if employees[i].Seniority != employees[j].Seniority { return employees[i].Seniority > employees[j].Seniority }
		// Name (A-Z)
		return employees[i].Name < employees[j].Name
	})
}
```

Example \(Sorting a custom type by a single key\):

```
type Product struct { ID int; Price float64 }
slices.SortFunc(products, func(a, b Product) int { return cmp.Compare(a.Price, b.Price) })
```

See pkg.go.dev for more information.

## Index

- [func Clamp[T constraints.Ordered](v, lo, hi T) T](<#func-clamp>)
- [func Compare[T constraints.Ordered](a, b T) int](<#func-compare>)
- [func IsZero[T comparable](v T) bool](<#func-iszero>)
- [func Max[T constraints.Ordered](a, b T) T](<#func-max>)
- [func Min[T constraints.Ordered](a, b T) T](<#func-min>)


## func [Clamp](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L41>)

```go
func Clamp[T constraints.Ordered](v, lo, hi T) T
```

Clamp returns v clamped to the inclusive range \[lo, hi\]. If v is less than lo, it returns lo. If v is greater than hi, it returns hi. Otherwise, it returns v.

## func [Compare](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L11>)

```go
func Compare[T constraints.Ordered](a, b T) int
```

Compare returns an integer comparing two values. The result will be 0 if a == b, \-1 if a \< b, and \+1 if a \> b.

This function is designed to be fully compatible with the standard library's \`slices.SortFunc\`, making it a convenient tool for sorting slices of any ordered type.

## func [IsZero](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L53>)

```go
func IsZero[T comparable](v T) bool
```

IsZero returns true if v is the zero value for its type. It is a generic\-safe way to check for zero values.

## func [Max](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L30>)

```go
func Max[T constraints.Ordered](a, b T) T
```

Max returns the larger of a or b.

## func [Min](<https://github.com/goexts/generic/blob/main/cmp/cmp.go#L22>)

```go
func Min[T constraints.Ordered](a, b T) T
```

Min returns the smaller of a or b.

# cond

```go
import "github.com/goexts/generic/cond"
```

Package cond provides generic, ternary\-like conditional functions.

This package offers a concise way to express simple conditional logic in a single expression, avoiding the need for a more verbose if\-else block. It provides functions for both eagerly\-evaluated values and lazily\-evaluated functions.

\# Practical Usage

Single\-line status message \(Report Q4\):

```
func Status(err error) string {
	return cond.If(err == nil, "Status: OK", "Status: Failed")
}
```

Example \(Lazy Evaluation\):

```
// The expensive functions are only called when needed.
result := cond.IfFunc(isComplex, doComplexCalculation, doSimpleCalculation)
```

## Index

- [func If[T any](condition bool, trueVal T, falseVal T) T](<#func-if>)
- [func IfFunc[T any](condition bool, trueFn func() T, falseFn func() T) T](<#func-iffunc>)
- [func IfFuncE[T any](condition bool, trueFn func() (T, error), falseFn func() (T, error)) (T, error)](<#func-iffunce>)


## func [If](<https://github.com/goexts/generic/blob/main/cond/cond.go#L8>)

```go
func If[T any](condition bool, trueVal T, falseVal T) T
```

If returns trueVal if the condition is true, and falseVal otherwise. This is a generic, eagerly\-evaluated ternary\-like expression. Both trueVal and falseVal are evaluated before this function is called.

For lazy evaluation where values are expensive to compute, see IfFunc.

## func [IfFunc](<https://github.com/goexts/generic/blob/main/cond/cond.go#L19>)

```go
func IfFunc[T any](condition bool, trueFn func() T, falseFn func() T) T
```

IfFunc returns the result of trueFn if the condition is true, and the result of falseFn otherwise. This is a generic, lazily\-evaluated ternary\-like expression. Only the function corresponding to the condition's outcome is executed.

## func [IfFuncE](<https://github.com/goexts/generic/blob/main/cond/cond.go#L30>)

```go
func IfFuncE[T any](condition bool, trueFn func() (T, error), falseFn func() (T, error)) (T, error)
```

IfFuncE returns the result of trueFn if the condition is true, and the result of falseFn otherwise. It is the error\-returning version of IfFunc. This is a generic, lazily\-evaluated ternary\-like expression. Only the function corresponding to the condition's outcome is executed.

# configure

```go
import "github.com/goexts/generic/configure"
```

Package configure provides utilities for applying functional options to objects.

Package configure provides a robust, type\-safe, and flexible implementation of the Functional Options Pattern for Go. It is designed to handle a wide range of configuration scenarios, from simple object initialization to complex, multi\-stage product compilation.

\# Practical Patterns

1\) Functional options for a Logger \(Report Q5\):

```
type Logger struct{ level string; out io.Writer }
func NewLogger(options ...configure.Option[Logger]) (*Logger, error) {
	l := Logger{level: "info", out: os.Stdout}
	if err := configure.Apply(&l, options...); err != nil { return nil, err }
	if l.level == "" { return nil, fmt.Errorf("invalid level") }
	if l.out == nil { l.out = os.Stdout }
	return &l, nil
}
func WithLevel(level string) configure.Option[Logger] {
	return configure.OptionFunc[Logger](func(l *Logger) error { l.level = level; return nil })
}
func WithOutput(w io.Writer) configure.Option[Logger] {
	return configure.OptionFunc[Logger](func(l *Logger) error { l.out = w; return nil })
}
```

2\) Options with dependency validation \(Report Q10\):

```
type Connection struct{ retries int; delay time.Duration; delaySet bool }
func NewConnection(opts ...configure.Option[Connection]) (*Connection, error) {
	c := Connection{}
	if err := configure.Apply(&c, opts...); err != nil { return nil, err }
	if c.delaySet && c.retries <= 0 { return nil, fmt.Errorf("WithRetryDelay requires Retries > 0") }
	return &c, nil
}
func WithRetries(n int) configure.Option[Connection] {
	return configure.OptionFunc[Connection](func(c *Connection) error { c.retries = n; return nil })
}
func WithRetryDelay(d time.Duration) configure.Option[Connection] {
	return configure.OptionFunc[Connection](func(c *Connection) error { c.delay = d; c.delaySet = true; return nil })
}
```

\# Core Concepts \(Overview\)

\- Type\-Safe Application: \`Apply\`, \`ApplyE\` \- Flexible Application: \`ApplyAny\` \- Stateful Builder: \`Builder\` \- Compilation: \`Compile\`

See pkg.go.dev for comprehensive documentation.

## Index

- [func Apply[T any, O FuncOption[T]](target *T, opts []O) *T](<#func-apply>)
- [func ApplyAny[T any](target *T, opts []any) (*T, error)](<#func-applyany>)
- [func ApplyAnyWith[T any](target *T, opts ...any) (*T, error)](<#func-applyanywith>)
- [func ApplyE[T any, O FuncOptionE[T]](target *T, opts []O) (*T, error)](<#func-applye>)
- [func ApplyWith[T any](target *T, opts ...Option[T]) *T](<#func-applywith>)
- [func ApplyWithE[T any](target *T, opts ...OptionE[T]) (*T, error)](<#func-applywithe>)
- [func Compile[C any, P any](builder *Builder[C], factory func(c *C) (*P, error)) (*P, error)](<#func-compile>)
- [func IsConfigError(err error) bool](<#func-isconfigerror>)
- [func IsEmptyTargetValueError(err error) bool](<#func-isemptytargetvalueerror>)
- [func IsExecutionFailedError(err error) bool](<#func-isexecutionfailederror>)
- [func IsUnsupportedTypeError(err error) bool](<#func-isunsupportedtypeerror>)
- [func New[T any, O FuncOption[T]](opts []O) *T](<#func-new>)
- [func NewAny[T any](opts ...any) (*T, error)](<#func-newany>)
- [func NewE[T any, O FuncOptionE[T]](opts []O) (*T, error)](<#func-newe>)
- [func NewWith[T any](opts ...Option[T]) *T](<#func-newwith>)
- [func NewWithE[T any](opts ...OptionE[T]) (*T, error)](<#func-newwithe>)
- [type Applier](<#type-applier>)
- [type ApplierE](<#type-appliere>)
- [type Builder](<#type-builder>)
  - [func NewBuilder[C any]() *Builder[C]](<#func-newbuilder>)
  - [func (b *Builder[C]) Add(opts ...any) *Builder[C]](<#func-builderc-add>)
  - [func (b *Builder[C]) AddWhen(condition bool, opt any) *Builder[C]](<#func-builderc-addwhen>)
  - [func (b *Builder[C]) Apply(target *C) error](<#func-builderc-apply>)
  - [func (b *Builder[C]) ApplyTo(target *C) (*C, error)](<#func-builderc-applyto>)
  - [func (b *Builder[C]) Build() (*C, error)](<#func-builderc-build>)
- [type ConfigError](<#type-configerror>)
  - [func (e *ConfigError) Error() string](<#func-configerror-error>)
  - [func (e *ConfigError) Unwrap() error](<#func-configerror-unwrap>)
- [type ErrorCode](<#type-errorcode>)
- [type FuncOption](<#type-funcoption>)
- [type FuncOptionAny](<#type-funcoptionany>)
- [type FuncOptionE](<#type-funcoptione>)
- [type Option](<#type-option>)
  - [func OptionSet[T any](opts ...Option[T]) Option[T]](<#func-optionset>)
  - [func (o Option[T]) Apply(target *T)](<#func-optiont-apply>)
- [type OptionE](<#type-optione>)
  - [func OptionSetE[T any](opts ...OptionE[T]) OptionE[T]](<#func-optionsete>)
  - [func WithValidation[T any](validator func(*T) error) OptionE[T]](<#func-withvalidation>)
  - [func (o OptionE[T]) Apply(target *T) error](<#func-optionet-apply>)


## func [Apply](<https://github.com/goexts/generic/blob/main/configure/apply.go#L116>)

```go
func Apply[T any, O FuncOption[T]](target *T, opts []O) *T
```

Apply applies a slice of options to the target. It is the core, high\-performance function for applying a homogeneous set of type\-safe options. Its generic constraint allows for custom\-defined option types, such as \`type MyOption func\(\*T\)\`.

For handling mixed option types, see ApplyAny.

## func [ApplyAny](<https://github.com/goexts/generic/blob/main/configure/apply.go#L160>)

```go
func ApplyAny[T any](target *T, opts []any) (*T, error)
```

ApplyAny applies a slice of options of various types \(any\). This function provides flexibility by using reflection to handle heterogeneous options, at the cost of compile\-time type safety and a minor performance overhead.

For type\-safe, high\-performance application, see Apply or ApplyE.

## func [ApplyAnyWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L173>)

```go
func ApplyAnyWith[T any](target *T, opts ...any) (*T, error)
```

ApplyAnyWith is the variadic convenience wrapper for ApplyAny.

## func [ApplyE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L137>)

```go
func ApplyE[T any, O FuncOptionE[T]](target *T, opts []O) (*T, error)
```

ApplyE applies a slice of error\-returning options to the target. It is the core, high\-performance function for applying a homogeneous set of type\-safe, error\-returning options. Its generic constraint allows for custom\-defined option types.

For handling mixed option types, see ApplyAny.

## func [ApplyWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L127>)

```go
func ApplyWith[T any](target *T, opts ...Option[T]) *T
```

ApplyWith is the variadic convenience wrapper for Apply.

## func [ApplyWithE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L150>)

```go
func ApplyWithE[T any](target *T, opts ...OptionE[T]) (*T, error)
```

ApplyWithE is the variadic convenience wrapper for ApplyE.

## func [Compile](<https://github.com/goexts/generic/blob/main/configure/builder.go#L82>)

```go
func Compile[C any, P any](builder *Builder[C], factory func(c *C) (*P, error)) (*P, error)
```

Compile creates a final product \`P\` by first building a configuration \`C\` using the provided builder, and then passing the result to a factory function. This is the primary top\-level function for the Config \-\> Product workflow, ensuring a clean separation between configuration and compilation.

## func [IsConfigError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L71>)

```go
func IsConfigError(err error) bool
```

IsConfigError checks if the given error is a \*ConfigError.

## func [IsEmptyTargetValueError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L92>)

```go
func IsEmptyTargetValueError(err error) bool
```

IsEmptyTargetValueError checks if the error is a ConfigError with the code ErrEmptyTargetValue.

## func [IsExecutionFailedError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L85>)

```go
func IsExecutionFailedError(err error) bool
```

IsExecutionFailedError checks if the error is a ConfigError with the code ErrExecutionFailed.

## func [IsUnsupportedTypeError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L78>)

```go
func IsUnsupportedTypeError(err error) bool
```

IsUnsupportedTypeError checks if the error is a ConfigError with the code ErrUnsupportedType.

## func [New](<https://github.com/goexts/generic/blob/main/configure/apply.go#L197>)

```go
func New[T any, O FuncOption[T]](opts []O) *T
```

New creates a new instance of T and applies the given options. It is a convenient, type\-safe constructor for creating objects with homogeneous options. For mixed\-type or error\-returning options, see NewAny or NewE.

## func [NewAny](<https://github.com/goexts/generic/blob/main/configure/apply.go#L227>)

```go
func NewAny[T any](opts ...any) (*T, error)
```

NewAny creates a new instance of T, applies the given options of any type, and returns it. It is a convenient top\-level constructor for simple object creation where the configuration type and the product type are the same.

It uses ApplyAny for maximum flexibility in accepting options.

## func [NewE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L211>)

```go
func NewE[T any, O FuncOptionE[T]](opts []O) (*T, error)
```

NewE creates a new instance of T, applies the error\-returning options, and returns the configured instance or an error. It is a convenient, type\-safe constructor for creating objects with homogeneous, error\-returning options.

## func [NewWith](<https://github.com/goexts/generic/blob/main/configure/apply.go#L203>)

```go
func NewWith[T any](opts ...Option[T]) *T
```

NewWith is the variadic convenience wrapper for New.

## func [NewWithE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L217>)

```go
func NewWithE[T any](opts ...OptionE[T]) (*T, error)
```

NewWithE is the variadic convenience wrapper for NewE.

## type [Applier](<https://github.com/goexts/generic/blob/main/configure/apply.go#L10-L12>)

Applier is an interface for types that can apply a configuration to an object. It provides an extension point for ApplyAny, allowing custom types to be used as options without reflection.

```go
type Applier[T any] interface {
    Apply(*T)
}
```

## type [ApplierE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L17-L19>)

ApplierE is an interface for types that can apply a configuration and return an error. It provides an extension point for ApplyAny, allowing custom types to be used as options without reflection.

```go
type ApplierE[T any] interface {
    Apply(*T) error
}
```

## type [Builder](<https://github.com/goexts/generic/blob/main/configure/builder.go#L15-L17>)

Builder provides a fluent interface for collecting and applying options. It is ideal for scenarios where configuration options are gathered progressively from different parts of an application.

The generic type C represents the configuration type being built, and is expected to be a struct type. Using a pointer type for C is not recommended as it can lead to unexpected behavior.

```go
type Builder[C any] struct {
    // contains filtered or unexported fields
}
```

### func [NewBuilder](<https://github.com/goexts/generic/blob/main/configure/builder.go#L20>)

```go
func NewBuilder[C any]() *Builder[C]
```

NewBuilder creates a new, empty configuration builder.

### func \(\*Builder\[C\]\) [Add](<https://github.com/goexts/generic/blob/main/configure/builder.go#L25>)

```go
func (b *Builder[C]) Add(opts ...any) *Builder[C]
```

Add adds one or more options to the builder. It supports a fluent, chainable API.

### func \(\*Builder\[C\]\) [AddWhen](<https://github.com/goexts/generic/blob/main/configure/builder.go#L32>)

```go
func (b *Builder[C]) AddWhen(condition bool, opt any) *Builder[C]
```

AddWhen conditionally adds an option to the builder if the condition is true. It supports a fluent, chainable API.

### func \(\*Builder\[C\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/builder.go#L73>)

```go
func (b *Builder[C]) Apply(target *C) error
```

Apply implements the ApplierE interface. This allows a Builder instance to be passed directly as an option to other functions like New or ApplyAny, acting as a "super option".

### func \(\*Builder\[C\]\) [ApplyTo](<https://github.com/goexts/generic/blob/main/configure/builder.go#L52>)

```go
func (b *Builder[C]) ApplyTo(target *C) (*C, error)
```

ApplyTo applies all collected options to an existing target object.

### func \(\*Builder\[C\]\) [Build](<https://github.com/goexts/generic/blob/main/configure/builder.go#L62>)

```go
func (b *Builder[C]) Build() (*C, error)
```

Build creates a new, zero\-value instance of the configuration object C and applies all collected options to it. The resulting object can then be used directly or passed to a factory.

## type [ConfigError](<https://github.com/goexts/generic/blob/main/configure/errors.go#L29-L36>)

ConfigError is a custom error type for the configure package. It wraps an original error while providing additional context, such as the type of option that caused the failure and a specific error code.

```go
type ConfigError struct {
    // Code is the category of the error.
    Code ErrorCode
    // TypeString is the string representation of the option's type.
    TypeString string
    // Err is the underlying error, if any.
    Err error
}
```

### func \(\*ConfigError\) [Error](<https://github.com/goexts/generic/blob/main/configure/errors.go#L54>)

```go
func (e *ConfigError) Error() string
```

Error implements the standard error interface.

### func \(\*ConfigError\) [Unwrap](<https://github.com/goexts/generic/blob/main/configure/errors.go#L49>)

```go
func (e *ConfigError) Unwrap() error
```

Unwrap makes ConfigError compatible with the standard library's errors.Is and errors.As functions, allowing for proper error chain inspection.

## type [ErrorCode](<https://github.com/goexts/generic/blob/main/configure/errors.go#L9>)

ErrorCode defines the specific category of a configuration error.

```go
type ErrorCode int
```

Error codes for specific configuration failures.

```go
const (
    // ErrUnsupportedType indicates that an option's type is not supported by
    // the ApplyAny function.
    ErrUnsupportedType ErrorCode = iota

    // ErrExecutionFailed indicates that an option function returned an error
    // during its execution.
    ErrExecutionFailed

    // ErrEmptyTargetValue indicates that a nil pointer was passed as the target
    // for configuration.
    ErrEmptyTargetValue
)
```

## type [FuncOption](<https://github.com/goexts/generic/blob/main/configure/options.go#L31-L33>)

FuncOption is a generic constraint that permits any function type whose underlying type is func\(\*T\). This enables the top\-level Apply function to accept custom\-defined option types, such as \`type MyOption func\(\*T\)\`.

```go
type FuncOption[T any] interface {
    // contains filtered or unexported methods
}
```

## type [FuncOptionAny](<https://github.com/goexts/generic/blob/main/configure/options.go#L46-L48>)

FuncOptionAny is a generic constraint that permits any function type whose underlying type is either func\(\*T\) or func\(\*T\) error. This provides a convenient way to create functions that can accept both error\-returning and non\-error\-returning function options.

```go
type FuncOptionAny[T any] interface {
    // contains filtered or unexported methods
}
```

## type [FuncOptionE](<https://github.com/goexts/generic/blob/main/configure/options.go#L38-L40>)

FuncOptionE is a generic constraint that permits any function type whose underlying type is func\(\*T\) error. This enables the top\-level ApplyE function to accept custom\-defined, error\-returning option types.

```go
type FuncOptionE[T any] interface {
    // contains filtered or unexported methods
}
```

## type [Option](<https://github.com/goexts/generic/blob/main/configure/options.go#L5>)

Option represents a function that configures an object of type T. It is the primary, non\-error\-returning type for the Functional Options Pattern.

```go
type Option[T any] func(*T)
```

### func [OptionSet](<https://github.com/goexts/generic/blob/main/configure/apply.go#L179>)

```go
func OptionSet[T any](opts ...Option[T]) Option[T]
```

OptionSet bundles multiple options into a single option. This allows for creating reusable and modular sets of configurations.

### func \(Option\[T\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/options.go#L9>)

```go
func (o Option[T]) Apply(target *T)
```

Apply implements the Applier\[T\] interface, allowing an Option\[T\] to be used as a flexible option type with functions like ApplyAny.

## type [OptionE](<https://github.com/goexts/generic/blob/main/configure/options.go#L17>)

OptionE represents a function that configures an object of type T and may return an error. The 'E' suffix is a convention for "Error".

```go
type OptionE[T any] func(*T) error
```

### func [OptionSetE](<https://github.com/goexts/generic/blob/main/configure/apply.go#L187>)

```go
func OptionSetE[T any](opts ...OptionE[T]) OptionE[T]
```

OptionSetE bundles multiple error\-returning options into a single option. If any option in the set returns an error, the application stops and the error is returned.

### func [WithValidation](<https://github.com/goexts/generic/blob/main/configure/constructors.go#L6>)

```go
func WithValidation[T any](validator func(*T) error) OptionE[T]
```

WithValidation creates an option that validates the target object. If the validator function returns an error, the configuration process will stop.

### func \(OptionE\[T\]\) [Apply](<https://github.com/goexts/generic/blob/main/configure/options.go#L21>)

```go
func (o OptionE[T]) Apply(target *T) error
```

Apply implements the ApplierE\[T\] interface, allowing an OptionE\[T\] to be used as a flexible option type with functions like ApplyAny.

# maps

```go
import "github.com/goexts/generic/maps_test"
```

Package maps provides a set of generic functions for common operations on maps.

This package is a generated adapter and mirrors the public API of the standard Go experimental package \`golang.org/x/exp/maps\`. It offers a convenient way to access these common utilities, such as cloning maps, extracting keys or values, and comparing maps for equality.

\# Practical Usage

Extracting keys and values \(Report Q3\):

```
userPermissions := map[string]string{"admin": "all", "editor": "write", "viewer": "read"}
keys := maps.Keys(userPermissions)     // []string (order not guaranteed)
vals := maps.Values(userPermissions)   // []string (order not guaranteed)
// Optionally sort for deterministic output:
// slices.Sort(keys); slices.Sort(vals)
```

For details, see pkg.go.dev for the \`maps\` package.

Package maps implements the functions, types, and interfaces for the module.

Package maps contains generated code by adptool.

## Index

- [func Clear[M ~map[K]V, K comparable, V any](m M)](<#func-clear>)
- [func Clone[M ~map[K]V, K comparable, V any](m M) M](<#func-clone>)
- [func Concat[M ~map[K]V, K comparable, V any](m M, ms ...M)](<#func-concat>)
- [func ConcatWith[M ~map[K]V, K comparable, V any](merge func(K, V, V) V, m M, ms ...M)](<#func-concatwith>)
- [func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)](<#func-copy>)
- [func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)](<#func-deletefunc>)
- [func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool](<#func-equal>)
- [func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool](<#func-equalfunc>)
- [func Exclude[M ~map[K]V, K comparable, V any](m M, keys ...K)](<#func-exclude>)
- [func Filter[M ~map[K]V, K comparable, V any](m M, f func(K, V) bool)](<#func-filter>)
- [func FromKVs[K comparable, V any, M ~map[K]V](kvs []KeyValue[K, V]) M](<#func-fromkvs>)
- [func FromSlice[T any, M ~map[K]V, K comparable, V any](ts []T, f func(T) (K, V)) M](<#func-fromslice>)
- [func FromSliceWithIndex[T any, M ~map[K]V, K comparable, V any](ts []T, f func(int, T) (K, V)) M](<#func-fromslicewithindex>)
- [func Keys[M ~map[K]V, K comparable, V any](m M) []K](<#func-keys>)
- [func Merge[M ~map[K]V, K comparable, V any](dest M, src M, overlay bool)](<#func-merge>)
- [func MergeWith[M ~map[K]V, K comparable, V any](dest M, src M, cmp func(key K, src V, val V) V)](<#func-mergewith>)
- [func ToSlice[M ~map[K]V, K comparable, V any, T any](m M, f func(K, V) T) []T](<#func-toslice>)
- [func ToSliceWith[M ~map[K]V, K comparable, V any, T any](m M, f func(K, V) (T, bool)) []T](<#func-toslicewith>)
- [func ToStruct[M ~map[K]V, K comparable, V any, S any](m M, f func(*S, K, V) *S) *S](<#func-tostruct>)
- [func Transform[M ~map[K]V, K comparable, V any, TK comparable, TV any](m M, f func(K, V) (TK, TV, bool)) map[TK]TV](<#func-transform>)
- [func Values[M ~map[K]V, K comparable, V any](m M) []V](<#func-values>)
- [type KeyValue](<#type-keyvalue>)
  - [func ToKVs[M ~map[K]V, K comparable, V any](m M) []KeyValue[K, V]](<#func-tokvs>)


## func [Clear](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L12>)

```go
func Clear[M ~map[K]V, K comparable, V any](m M)
```

## func [Clone](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L16>)

```go
func Clone[M ~map[K]V, K comparable, V any](m M) M
```

## func [Concat](<https://github.com/goexts/generic/blob/main/maps/map.go#L32>)

```go
func Concat[M ~map[K]V, K comparable, V any](m M, ms ...M)
```

Concat merges multiple maps into a single map. If a key exists in multiple maps, the value from the last map will be used.

## func [ConcatWith](<https://github.com/goexts/generic/blob/main/maps/map.go#L45>)

```go
func ConcatWith[M ~map[K]V, K comparable, V any](merge func(K, V, V) V, m M, ms ...M)
```

ConcatWith merges multiple maps into a single map using a custom merge function. If a key exists in multiple maps, the merge function will be called to determine the final value.

## func [Copy](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L20>)

```go
func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)
```

## func [DeleteFunc](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L24>)

```go
func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)
```

## func [Equal](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L28>)

```go
func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool
```

## func [EqualFunc](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L32>)

```go
func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool
```

## func [Exclude](<https://github.com/goexts/generic/blob/main/maps/map.go#L57>)

```go
func Exclude[M ~map[K]V, K comparable, V any](m M, keys ...K)
```

Exclude removes all key/value pairs from m for which f returns false.

## func [Filter](<https://github.com/goexts/generic/blob/main/maps/map.go#L64>)

```go
func Filter[M ~map[K]V, K comparable, V any](m M, f func(K, V) bool)
```

Filter keeps only the key\-value pairs in the map for which the provided function returns true.

## func [FromKVs](<https://github.com/goexts/generic/blob/main/maps/map.go#L88>)

```go
func FromKVs[K comparable, V any, M ~map[K]V](kvs []KeyValue[K, V]) M
```

FromKVs converts a slice of key\-value pairs to a map.

## func [FromSlice](<https://github.com/goexts/generic/blob/main/maps/map.go#L117>)

```go
func FromSlice[T any, M ~map[K]V, K comparable, V any](ts []T, f func(T) (K, V)) M
```

FromSlice converts a slice of types to a map.

## func [FromSliceWithIndex](<https://github.com/goexts/generic/blob/main/maps/map.go#L127>)

```go
func FromSliceWithIndex[T any, M ~map[K]V, K comparable, V any](ts []T, f func(int, T) (K, V)) M
```

FromSliceWithIndex converts a slice of types to a map, using the provided function to extract the key and value.

## func [Keys](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L36>)

```go
func Keys[M ~map[K]V, K comparable, V any](m M) []K
```

## func [Merge](<https://github.com/goexts/generic/blob/main/maps/map.go#L10>)

```go
func Merge[M ~map[K]V, K comparable, V any](dest M, src M, overlay bool)
```

Merge merges the values of src into dest. If overlay is true, existing values in dest will be overwritten.

## func [MergeWith](<https://github.com/goexts/generic/blob/main/maps/map.go#L20>)

```go
func MergeWith[M ~map[K]V, K comparable, V any](dest M, src M, cmp func(key K, src V, val V) V)
```

MergeWith merges the values of src into dest using the provided merge function. If a key exists in both maps, the merge function will be called to determine the final value.

## func [ToSlice](<https://github.com/goexts/generic/blob/main/maps/map.go#L97>)

```go
func ToSlice[M ~map[K]V, K comparable, V any, T any](m M, f func(K, V) T) []T
```

ToSlice converts a map to a slice of types.

## func [ToSliceWith](<https://github.com/goexts/generic/blob/main/maps/map.go#L106>)

```go
func ToSliceWith[M ~map[K]V, K comparable, V any, T any](m M, f func(K, V) (T, bool)) []T
```

ToSliceWith converts a map to a slice of types, filtering out values that return false.

## func [ToStruct](<https://github.com/goexts/generic/blob/main/maps/map.go#L137>)

```go
func ToStruct[M ~map[K]V, K comparable, V any, S any](m M, f func(*S, K, V) *S) *S
```

ToStruct converts a map to a struct.

## func [Transform](<https://github.com/goexts/generic/blob/main/maps/map.go#L149>)

```go
func Transform[M ~map[K]V, K comparable, V any, TK comparable, TV any](m M, f func(K, V) (TK, TV, bool)) map[TK]TV
```

Transform remaps the keys and values of a map using a custom transformation function. The transformation function is called for each key\-value pair in the original map. If the transformation function returns false as its third return value, the key\-value pair is skipped. Otherwise, the transformed key\-value pair is added to the new map.

## func [Values](<https://github.com/goexts/generic/blob/main/maps/maps.adapter.go#L40>)

```go
func Values[M ~map[K]V, K comparable, V any](m M) []V
```

## type [KeyValue](<https://github.com/goexts/generic/blob/main/maps/map.go#L73-L76>)

KeyValue is a key\-value pair.

```go
type KeyValue[K comparable, V any] struct {
    Key K
    Val V
}
```

### func [ToKVs](<https://github.com/goexts/generic/blob/main/maps/map.go#L79>)

```go
func ToKVs[M ~map[K]V, K comparable, V any](m M) []KeyValue[K, V]
```

ToKVs converts a map to a slice of key\-value pairs.

# must

```go
import "github.com/goexts/generic/must"
```

Package must provides helper functions that wrap calls returning an error and panic if the error is non\-nil. This is intended to reduce boilerplate in specific, controlled contexts.

WARNING: The functions in this package should be used with extreme care. They intentionally convert a recoverable error into a non\-recoverable panic. This is only appropriate in specific situations where an error is considered a bug in the program, not a predictable runtime failure.

Appropriate Use Cases:

```
- Program initialization (e.g., in `init` functions or `main`):
  parsing hardcoded configuration, compiling essential regular expressions,
  or setting up database connections that are required for the application
  to start.

- Test setup: When setting up test fixtures where a failure indicates a
  broken test, not a feature to be tested.
```

Example:

```
// Instead of:
// re, err := regexp.Compile(`\w+`)
// if err != nil {
// 	panic(err)
// }

// Use must.Must for cleaner initialization code:
re := must.Must(regexp.Compile(`\w+`))
```

DO NOT use these functions for regular application logic where errors are expected \(e.g., handling user input, network requests, file I/O\).

## Index

- [func Cast[T any](v any) T](<#func-cast>)
- [func Do[T any](v T, err error) T](<#func-do>)
- [func Do2[T any, U any](v1 T, v2 U, err error) (T, U)](<#func-do2>)


## func [Cast](<https://github.com/goexts/generic/blob/main/must/must.go#L25>)

```go
func Cast[T any](v any) T
```

Cast performs a type assertion and panics if it fails. It provides a more informative panic message than a raw type assertion.

## func [Do](<https://github.com/goexts/generic/blob/main/must/must.go#L8>)

```go
func Do[T any](v T, err error) T
```

Do panics if err is not nil, otherwise it returns the value v. It is useful for wrapping function calls that return a value and an error, where the error is not expected.

## func [Do2](<https://github.com/goexts/generic/blob/main/must/must.go#L16>)

```go
func Do2[T any, U any](v1 T, v2 U, err error) (T, U)
```

Do2 is similar to Do, but for functions that return two values and an error.

# promise

```go
import "github.com/goexts/generic/promise"
```

Package promise provides a generic, type\-safe implementation of Promises, inspired by the JavaScript Promise API. It is designed to simplify the management of asynchronous operations and avoid complex callback chains \("callback hell"\).

\# Core Concepts

A Promise represents the eventual completion \(or failure\) of an asynchronous operation and its resulting value. A Promise is in one of three states:

```
- pending: the initial state; neither fulfilled nor rejected.
- fulfilled: the operation completed successfully, resulting in a value.
- rejected: the operation failed, resulting in an error.
```

\# Basic Usage

The primary way to create a promise is with the \`New\` function, which takes an \`executor\` function. The executor is run in a new goroutine and receives \`resolve\` and \`reject\` functions to control the promise's outcome.

Example:

```
// Create a promise that resolves after a delay.
p := promise.New(func(resolve func(string), reject func(error)) {
	time.Sleep(100 * time.Millisecond)
	resolve("Hello, World!")
})

// The Await method blocks until the promise is settled.
val, err := p.Await()
// val is "Hello, World!", err is nil.
```

\# Chaining

Promises can be chained together using methods like \`Then\`, \`Catch\`, and \`Finally\` to create a clean, linear asynchronous workflow.

```
resultPromise := promise.Async(func() (int, error) {
	// Simulate an API call
	return 42, nil
}).Then(func(val int) int {
	// Transform the result
	return val * 2
}).Catch(func(err error) (int, error) {
	// Handle any previous errors and potentially recover.
	fmt.Printf("An error occurred: %v\n", err)
	return 0, nil // Recover with a default value
})

finalResult, _ := resultPromise.Await() // finalResult is 84
```

## Index

- [func Await[T any](p *Promise[T]) (T, error)](<#func-await>)
- [type Promise](<#type-promise>)
  - [func Async[T any](f func() (T, error)) *Promise[T]](<#func-async>)
  - [func New[T any](executor func(resolve func(T), reject func(error))) *Promise[T]](<#func-new>)
  - [func (p *Promise[T]) Await() (T, error)](<#func-promiset-await>)
  - [func (p *Promise[T]) Catch(onRejected func(error) (T, error)) *Promise[T]](<#func-promiset-catch>)
  - [func (p *Promise[T]) Finally(onFinally func()) *Promise[T]](<#func-promiset-finally>)
  - [func (p *Promise[T]) Reject(err error)](<#func-promiset-reject>)
  - [func (p *Promise[T]) Resolve(value T)](<#func-promiset-resolve>)
  - [func (p *Promise[T]) Then(onFulfilled func(T) T) *Promise[T]](<#func-promiset-then>)
  - [func (p *Promise[T]) ThenWithPromise(onFulfilled func(T) *Promise[T]) *Promise[T]](<#func-promiset-thenwithpromise>)


## func [Await](<https://github.com/goexts/generic/blob/main/promise/promise.go#L192>)

```go
func Await[T any](p *Promise[T]) (T, error)
```

Await is a standalone function that waits for a promise to be settled. It is a functional equivalent of the p.Await\(\) method.

## type [Promise](<https://github.com/goexts/generic/blob/main/promise/promise.go#L11-L17>)

Promise represents the eventual completion \(or failure\) of an asynchronous operation and its resulting value. It is a generic, type\-safe implementation inspired by the JavaScript Promise API.

```go
type Promise[T any] struct {
    // contains filtered or unexported fields
}
```

### func [Async](<https://github.com/goexts/generic/blob/main/promise/promise.go#L179>)

```go
func Async[T any](f func() (T, error)) *Promise[T]
```

Async is a helper function that wraps a function returning \(T, error\) into a new Promise. This is useful for converting existing functions into promise\-based asynchronous operations.

### func [New](<https://github.com/goexts/generic/blob/main/promise/promise.go#L22>)

```go
func New[T any](executor func(resolve func(T), reject func(error))) *Promise[T]
```

New creates a new Promise. The provided executor function is executed in a new goroutine. The executor receives \`resolve\` and \`reject\` functions to control the promise's outcome.

### func \(\*Promise\[T\]\) [Await](<https://github.com/goexts/generic/blob/main/promise/promise.go#L72>)

```go
func (p *Promise[T]) Await() (T, error)
```

Await blocks until the promise is settled and returns the resulting value and error. It is the primary way to get the result of a promise.

### func \(\*Promise\[T\]\) [Catch](<https://github.com/goexts/generic/blob/main/promise/promise.go#L124>)

```go
func (p *Promise[T]) Catch(onRejected func(error) (T, error)) *Promise[T]
```

Catch attaches a callback that executes when the promise is rejected. It allows for error handling and recovery. The onRejected callback can return a new value to fulfill the promise, or a new error to continue the rejection chain.

### func \(\*Promise\[T\]\) [Finally](<https://github.com/goexts/generic/blob/main/promise/promise.go#L149>)

```go
func (p *Promise[T]) Finally(onFinally func()) *Promise[T]
```

Finally attaches a callback that executes when the promise is settled \(either fulfilled or rejected\). It is useful for cleanup logic. The returned promise will be settled with the same value or error as the original promise, after onFinally has completed.

### func \(\*Promise\[T\]\) [Reject](<https://github.com/goexts/generic/blob/main/promise/promise.go#L57>)

```go
func (p *Promise[T]) Reject(err error)
```

Reject rejects the promise with an error. If the promise is already settled, this call is ignored.

### func \(\*Promise\[T\]\) [Resolve](<https://github.com/goexts/generic/blob/main/promise/promise.go#L42>)

```go
func (p *Promise[T]) Resolve(value T)
```

Resolve fulfills the promise with a value. If the promise is already settled, this call is ignored.

### func \(\*Promise\[T\]\) [Then](<https://github.com/goexts/generic/blob/main/promise/promise.go#L80>)

```go
func (p *Promise[T]) Then(onFulfilled func(T) T) *Promise[T]
```

Then attaches a callback that executes when the promise is fulfilled. It returns a new promise that resolves with the result of the onFulfilled callback. If the original promise is rejected, the new promise is rejected with the same error.

### func \(\*Promise\[T\]\) [ThenWithPromise](<https://github.com/goexts/generic/blob/main/promise/promise.go#L98>)

```go
func (p *Promise[T]) ThenWithPromise(onFulfilled func(T) *Promise[T]) *Promise[T]
```

ThenWithPromise is like Then, but the callback returns a new Promise. This allows for chaining of asynchronous operations.

# ptr

```go
import "github.com/goexts/generic/ptr"
```

Package ptr provides generic utility functions for working with pointers. It simplifies common operations such as creating a pointer from a literal value or safely dereferencing a pointer that might be nil.

This package is particularly useful in contexts where you need to assign a pointer to a struct field, but you only have a literal value \(e.g., a string, an integer, or a boolean\).

Example:

```
// Without ptr package
port := 8080
config := &ServerConfig{
	Port: &port,
}

// With ptr package
config := &ServerConfig{
	Port: ptr.Of(8080), // Cleaner and more concise
}
```

## Index

- [func Of[T any](v T) *T](<#func-of>)
- [func To[T any](v any) *T](<#func-to>)
- [func ToVal[T any](v any) T](<#func-toval>)
- [func Val[T any](v *T) T](<#func-val>)


## func [Of](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L10>)

```go
func Of[T any](v T) *T
```

Of returns a pointer to the given value v. This is a convenient helper for creating a pointer to a literal or a variable in a single expression, often used for struct field initialization.

Example:

```
config := &MyConfig{ Timeout: ptr.Of(5*time.Second) }
```

## func [To](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L30>)

```go
func To[T any](v any) *T
```

To converts an \`any\` value to a pointer of type \*T. It handles three cases: 1. If v is of type T, it returns a pointer to it \(&v\). 2. If v is already of type \*T, it returns v directly. 3. Otherwise, it returns a new pointer to a zero value of T.

## func [ToVal](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L47>)

```go
func ToVal[T any](v any) T
```

ToVal converts an \`any\` value to a value of type T. It handles three cases: 1. If v is a non\-nil pointer of type \*T, it returns the dereferenced value. 2. If v is of type T, it returns v directly. 3. Otherwise, it returns the zero value of T.

## func [Val](<https://github.com/goexts/generic/blob/main/ptr/ptr.go#L17>)

```go
func Val[T any](v *T) T
```

Val returns the value that the pointer v points to. If the pointer is nil, it safely returns the zero value of the type T. This avoids a panic when dereferencing a nil pointer.

# res

```go
import "github.com/goexts/generic/res"
```

Package res provides a generic, Rust\-inspired \`Result\[T\]\` type for expressive error handling.

\# Core Concept

A \`Result\[T\]\` is a type that represents either a success \(containing a value of type T\) or a failure \(containing an error\). It is a monadic type that allows for chaining operations in a clean, readable way, especially in data processing pipelines where each step can fail.

This pattern provides an alternative to returning \`\(value, error\)\` pairs at each step. Instead of checking for an error after every call, you can chain methods and handle the final result once.

\# Warning: Paradigm and Trade\-offs

While powerful, the \`Result\` type introduces a paradigm that is not idiomatic Go. Standard Go error handling \(returning \`\(T, error\)\`\) is simpler and more direct for most use cases. The \`Result\` type is best suited for specific scenarios like complex data transformation chains.

Be especially cautious with methods like \`Unwrap\` and \`Expect\`, which panic on an \`Err\` value. They should only be used when an error is considered a fatal, unrecoverable bug, similar to the \`must\` package.

\# Example

```
// A function that returns a Result
func ParseInt(s string) res.Result[int] {
	n, err := strconv.Atoi(s)
	return res.Of(n, err)
}

// Chaining operations
result := ParseInt("123").Unwrap() // result is 123

// Safely handling the result
val, ok := ParseInt("not-a-number").Ok()
// val is 0, ok is false
```

## Index

- [func Or[T any](v T, err error, defaultValue T) T](<#func-or>)
- [func OrZero[T any](v T, err error) T](<#func-orzero>)
- [type Result](<#type-result>)
  - [func Err[T any](err error) Result[T]](<#func-err>)
  - [func Of[T any](value T, err error) Result[T]](<#func-of>)
  - [func Ok[T any](value T) Result[T]](<#func-ok>)
  - [func (r Result[T]) Err() error](<#func-resultt-err>)
  - [func (r Result[T]) Expect(message string) T](<#func-resultt-expect>)
  - [func (r Result[T]) IsErr() bool](<#func-resultt-iserr>)
  - [func (r Result[T]) IsOk() bool](<#func-resultt-isok>)
  - [func (r Result[T]) Ok() (T, bool)](<#func-resultt-ok>)
  - [func (r Result[T]) Unwrap() T](<#func-resultt-unwrap>)
  - [func (r Result[T]) UnwrapOr(defaultValue T) T](<#func-resultt-unwrapor>)


## func [Or](<https://github.com/goexts/generic/blob/main/res/res.go#L87>)

```go
func Or[T any](v T, err error, defaultValue T) T
```

Or is a utility function that simplifies handling of \(value, error\) returns. It returns the value if err is nil, otherwise it returns the provided default value.

## func [OrZero](<https://github.com/goexts/generic/blob/main/res/res.go#L96>)

```go
func OrZero[T any](v T, err error) T
```

OrZero is a utility function that simplifies handling of \(value, error\) returns. It returns the value if err is nil, otherwise it returns the zero value of the type.

## type [Result](<https://github.com/goexts/generic/blob/main/res/res.go#L9-L12>)

Result is a type that represents either a success \(containing a value of type T\) or a failure \(containing an error\). It is a monadic type that allows for chaining operations in a clean, readable way. See the package documentation for more details and usage examples.

```go
type Result[T any] struct {
    // contains filtered or unexported fields
}
```

### func [Err](<https://github.com/goexts/generic/blob/main/res/res.go#L20>)

```go
func Err[T any](err error) Result[T]
```

Err creates a new failed Result containing the given error.

### func [Of](<https://github.com/goexts/generic/blob/main/res/res.go#L27>)

```go
func Of[T any](value T, err error) Result[T]
```

Of converts a standard Go \(value, error\) pair into a Result. If err is not nil, it returns an Err result; otherwise, it returns an Ok result.

### func [Ok](<https://github.com/goexts/generic/blob/main/res/res.go#L15>)

```go
func Ok[T any](value T) Result[T]
```

Ok creates a new successful Result containing the given value.

### func \(Result\[T\]\) [Err](<https://github.com/goexts/generic/blob/main/res/res.go#L81>)

```go
func (r Result[T]) Err() error
```

Err returns the contained error, or nil if the result is Ok.

### func \(Result\[T\]\) [Expect](<https://github.com/goexts/generic/blob/main/res/res.go#L67>)

```go
func (r Result[T]) Expect(message string) T
```

Expect returns the contained Ok value. It panics with a custom message if the result is an Err. This is similar to Unwrap but provides a more context\-specific panic message.

### func \(Result\[T\]\) [IsErr](<https://github.com/goexts/generic/blob/main/res/res.go#L40>)

```go
func (r Result[T]) IsErr() bool
```

IsErr returns true if the result is an Err \(i.e., contains an error\).

### func \(Result\[T\]\) [IsOk](<https://github.com/goexts/generic/blob/main/res/res.go#L35>)

```go
func (r Result[T]) IsOk() bool
```

IsOk returns true if the result is Ok \(i.e., does not contain an error\).

### func \(Result\[T\]\) [Ok](<https://github.com/goexts/generic/blob/main/res/res.go#L76>)

```go
func (r Result[T]) Ok() (T, bool)
```

Ok returns the contained value and a boolean indicating if the result was Ok. This provides a safe, idiomatic Go way to access the value.

### func \(Result\[T\]\) [Unwrap](<https://github.com/goexts/generic/blob/main/res/res.go#L48>)

```go
func (r Result[T]) Unwrap() T
```

Unwrap returns the contained Ok value. It panics if the result is an Err. Because this function may panic, it should only be used when the caller is certain that the result is Ok, or when a panic is the desired behavior. See also: Expect, UnwrapOr.

### func \(Result\[T\]\) [UnwrapOr](<https://github.com/goexts/generic/blob/main/res/res.go#L57>)

```go
func (r Result[T]) UnwrapOr(defaultValue T) T
```

UnwrapOr returns the contained Ok value or a provided default value. It is a safe way to access the value without panicking.

# set

```go
import "github.com/goexts/generic/set"
```

Package set provides a collection of generic, stateless functions for performing set\-like operations on standard Go slices.

\# Core Philosophy

Instead of introducing a new \`Set\` data structure, this package provides utilities that treat slices as sets. This approach offers several advantages:

```
- It is lightweight and requires no new types to learn.
- It integrates seamlessly with the rest of the Go ecosystem, which heavily
  relies on slices.
- It promotes a functional style of programming.
```

The functions in this package operate on slices of any \`comparable\` type.

\# Example

```
setA := []int{1, 2, 3, 4}
setB := []int{3, 4, 5, 6}

// Calculate the union of the two sets
union := set.Union(setA, setB) // Result (order not guaranteed): [1, 2, 3, 4, 5, 6]

// Calculate the intersection of the two sets
intersection := set.Intersection(setA, setB) // Result (order not guaranteed): [3, 4]

// Calculate the difference (elements in B but not in A)
difference := set.Difference(setA, setB) // Result (order not guaranteed): [5, 6]

// Remove duplicates from a slice
unique := set.Unique([]string{"a", "b", "a", "c", "b"}) // Result (order not guaranteed): ["a", "b", "c"]
```

## Index

- [func Contains[T comparable](s []T, e T) bool](<#func-contains>)
- [func Difference[T comparable](s1, s2 []T) []T](<#func-difference>)
- [func Exists[T any](s []T, f func(T) bool) bool](<#func-exists>)
- [func Intersection[T comparable](s1, s2 []T) []T](<#func-intersection>)
- [func Union[T comparable](s1, s2 []T) []T](<#func-union>)
- [func Unique[T comparable](s []T) []T](<#func-unique>)


## func [Contains](<https://github.com/goexts/generic/blob/main/set/set.go#L5>)

```go
func Contains[T comparable](s []T, e T) bool
```

Contains checks if a slice \`s\` contains the element \`e\`. The check is performed using the equality operator \(==\).

## func [Difference](<https://github.com/goexts/generic/blob/main/set/set.go#L77>)

```go
func Difference[T comparable](s1, s2 []T) []T
```

Difference returns a new slice containing the elements from s2 that are not present in s1 \(s2 \- s1\). The order of elements in the returned slice is not guaranteed.

## func [Exists](<https://github.com/goexts/generic/blob/main/set/set.go#L15>)

```go
func Exists[T any](s []T, f func(T) bool) bool
```

Exists checks if at least one element in a slice \`s\` satisfies the predicate \`f\`.

## func [Intersection](<https://github.com/goexts/generic/blob/main/set/set.go#L59>)

```go
func Intersection[T comparable](s1, s2 []T) []T
```

Intersection returns a new slice containing only the elements that exist in both s1 and s2. The order of elements in the returned slice is not guaranteed.

## func [Union](<https://github.com/goexts/generic/blob/main/set/set.go#L41>)

```go
func Union[T comparable](s1, s2 []T) []T
```

Union returns a new slice containing the unique elements present in either s1 or s2. The order of elements in the returned slice is not guaranteed.

## func [Unique](<https://github.com/goexts/generic/blob/main/set/set.go#L26>)

```go
func Unique[T comparable](s []T) []T
```

Unique returns a new slice containing only the unique elements of the input slice \`s\`. The order of elements in the returned slice is not guaranteed.

# strings

```go
import "github.com/goexts/generic/strings"
```

Package strings provides a collection of functions for string manipulation.

This package is a generated adapter and mirrors the public API of the standard Go library's \`strings\` package. It offers a convenient way to access the rich set of standard string utilities.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`strings\` package.

Example:

```
addr := "[INFO] This is a log message."

// Check for a prefix
_ = strings.HasPrefix(addr, "[INFO]") // true

// Trim the prefix
msg := strings.TrimPrefix(addr, "[INFO] ")
// msg is "This is a log message."
```

Package strings implements the functions, types, and interfaces for the module.

Package strings contains generated code by adptool.

Package strings implements the functions, types, and interfaces for the module.

## Index

- [func Clone(s string) string](<#func-clone>)
- [func Compare(a, b string) int](<#func-compare>)
- [func Contains(s, substr string) bool](<#func-contains>)
- [func ContainsAny(s, chars string) bool](<#func-containsany>)
- [func ContainsFunc(s string, f func(rune) bool) bool](<#func-containsfunc>)
- [func ContainsRune(s string, r rune) bool](<#func-containsrune>)
- [func Count(s, substr string) int](<#func-count>)
- [func Cut(s, sep string) (before, after string, found bool)](<#func-cut>)
- [func CutPrefix(s, prefix string) (after string, found bool)](<#func-cutprefix>)
- [func CutSuffix(s, suffix string) (before string, found bool)](<#func-cutsuffix>)
- [func EqualFold(s, t string) bool](<#func-equalfold>)
- [func Fields(s string) []string](<#func-fields>)
- [func FieldsFunc(s string, f func(rune) bool) []string](<#func-fieldsfunc>)
- [func FieldsFuncSeq(s string, f func(rune) bool) iter.Seq[string]](<#func-fieldsfuncseq>)
- [func FieldsSeq(s string) iter.Seq[string]](<#func-fieldsseq>)
- [func HasPrefix(s, prefix string) bool](<#func-hasprefix>)
- [func HasSuffix(s, suffix string) bool](<#func-hassuffix>)
- [func Index(s, substr string) int](<#func-index>)
- [func IndexAny(s, chars string) int](<#func-indexany>)
- [func IndexByte(s string, c byte) int](<#func-indexbyte>)
- [func IndexFunc(s string, f func(rune) bool) int](<#func-indexfunc>)
- [func IndexRune(s string, r rune) int](<#func-indexrune>)
- [func Join(elems []string, sep string) string](<#func-join>)
- [func LastIndex(s, substr string) int](<#func-lastindex>)
- [func LastIndexAny(s, chars string) int](<#func-lastindexany>)
- [func LastIndexByte(s string, c byte) int](<#func-lastindexbyte>)
- [func LastIndexFunc(s string, f func(rune) bool) int](<#func-lastindexfunc>)
- [func Lines(s string) iter.Seq[string]](<#func-lines>)
- [func Map(mapping func(rune) rune, s string) string](<#func-map>)
- [func NewReader(s string) *strings.Reader](<#func-newreader>)
- [func NewReplacer(oldnew ...string) *strings.Replacer](<#func-newreplacer>)
- [func ParseOr[T any](s string, def ...T) T](<#func-parseor>)
- [func Repeat(s string, count int) string](<#func-repeat>)
- [func Replace(s, old, new string, n int) string](<#func-replace>)
- [func ReplaceAll(s, old, new string) string](<#func-replaceall>)
- [func Split(s, sep string) []string](<#func-split>)
- [func SplitAfter(s, sep string) []string](<#func-splitafter>)
- [func SplitAfterN(s, sep string, n int) []string](<#func-splitaftern>)
- [func SplitAfterSeq(s, sep string) iter.Seq[string]](<#func-splitafterseq>)
- [func SplitN(s, sep string, n int) []string](<#func-splitn>)
- [func SplitSeq(s, sep string) iter.Seq[string]](<#func-splitseq>)
- [func Title(s string) string](<#func-title>)
- [func ToLower(s string) string](<#func-tolower>)
- [func ToLowerSpecial(c unicode.SpecialCase, s string) string](<#func-tolowerspecial>)
- [func ToTitle(s string) string](<#func-totitle>)
- [func ToTitleSpecial(c unicode.SpecialCase, s string) string](<#func-totitlespecial>)
- [func ToUpper(s string) string](<#func-toupper>)
- [func ToUpperSpecial(c unicode.SpecialCase, s string) string](<#func-toupperspecial>)
- [func ToValidUTF8(s, replacement string) string](<#func-tovalidutf8>)
- [func Trim(s, cutset string) string](<#func-trim>)
- [func TrimFunc(s string, f func(rune) bool) string](<#func-trimfunc>)
- [func TrimLeft(s, cutset string) string](<#func-trimleft>)
- [func TrimLeftFunc(s string, f func(rune) bool) string](<#func-trimleftfunc>)
- [func TrimPrefix(s, prefix string) string](<#func-trimprefix>)
- [func TrimRight(s, cutset string) string](<#func-trimright>)
- [func TrimRightFunc(s string, f func(rune) bool) string](<#func-trimrightfunc>)
- [func TrimSpace(s string) string](<#func-trimspace>)
- [func TrimSuffix(s, suffix string) string](<#func-trimsuffix>)
- [type Builder](<#type-builder>)
- [type Reader](<#type-reader>)
- [type Replacer](<#type-replacer>)


## func [Clone](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L20>)

```go
func Clone(s string) string
```

## func [Compare](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L24>)

```go
func Compare(a, b string) int
```

## func [Contains](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L28>)

```go
func Contains(s, substr string) bool
```

## func [ContainsAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L32>)

```go
func ContainsAny(s, chars string) bool
```

## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L36>)

```go
func ContainsFunc(s string, f func(rune) bool) bool
```

## func [ContainsRune](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L40>)

```go
func ContainsRune(s string, r rune) bool
```

## func [Count](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L44>)

```go
func Count(s, substr string) int
```

## func [Cut](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L48>)

```go
func Cut(s, sep string) (before, after string, found bool)
```

## func [CutPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L52>)

```go
func CutPrefix(s, prefix string) (after string, found bool)
```

## func [CutSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L56>)

```go
func CutSuffix(s, suffix string) (before string, found bool)
```

## func [EqualFold](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L60>)

```go
func EqualFold(s, t string) bool
```

## func [Fields](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L64>)

```go
func Fields(s string) []string
```

## func [FieldsFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L68>)

```go
func FieldsFunc(s string, f func(rune) bool) []string
```

## func [FieldsFuncSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L72>)

```go
func FieldsFuncSeq(s string, f func(rune) bool) iter.Seq[string]
```

## func [FieldsSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L76>)

```go
func FieldsSeq(s string) iter.Seq[string]
```

## func [HasPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L80>)

```go
func HasPrefix(s, prefix string) bool
```

## func [HasSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L84>)

```go
func HasSuffix(s, suffix string) bool
```

## func [Index](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L88>)

```go
func Index(s, substr string) int
```

## func [IndexAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L92>)

```go
func IndexAny(s, chars string) int
```

## func [IndexByte](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L96>)

```go
func IndexByte(s string, c byte) int
```

## func [IndexFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L100>)

```go
func IndexFunc(s string, f func(rune) bool) int
```

## func [IndexRune](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L104>)

```go
func IndexRune(s string, r rune) int
```

## func [Join](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L108>)

```go
func Join(elems []string, sep string) string
```

## func [LastIndex](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L112>)

```go
func LastIndex(s, substr string) int
```

## func [LastIndexAny](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L116>)

```go
func LastIndexAny(s, chars string) int
```

## func [LastIndexByte](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L120>)

```go
func LastIndexByte(s string, c byte) int
```

## func [LastIndexFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L124>)

```go
func LastIndexFunc(s string, f func(rune) bool) int
```

## func [Lines](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L128>)

```go
func Lines(s string) iter.Seq[string]
```

## func [Map](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L132>)

```go
func Map(mapping func(rune) rune, s string) string
```

## func [NewReader](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L136>)

```go
func NewReader(s string) *strings.Reader
```

## func [NewReplacer](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L140>)

```go
func NewReplacer(oldnew ...string) *strings.Replacer
```

## func [ParseOr](<https://github.com/goexts/generic/blob/main/strings/parse.go#L15>)

```go
func ParseOr[T any](s string, def ...T) T
```

ParseOr converts a string to a specified type, with support for a default value. It supports all basic types \(int/uint variants, float, bool, string\) and JSON\-deserializable types. If parsing fails and a default value is provided, it returns the default value. If parsing fails and no default is provided, it panics.

## func [Repeat](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L144>)

```go
func Repeat(s string, count int) string
```

## func [Replace](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L148>)

```go
func Replace(s, old, new string, n int) string
```

## func [ReplaceAll](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L152>)

```go
func ReplaceAll(s, old, new string) string
```

## func [Split](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L156>)

```go
func Split(s, sep string) []string
```

## func [SplitAfter](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L160>)

```go
func SplitAfter(s, sep string) []string
```

## func [SplitAfterN](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L164>)

```go
func SplitAfterN(s, sep string, n int) []string
```

## func [SplitAfterSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L168>)

```go
func SplitAfterSeq(s, sep string) iter.Seq[string]
```

## func [SplitN](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L172>)

```go
func SplitN(s, sep string, n int) []string
```

## func [SplitSeq](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L176>)

```go
func SplitSeq(s, sep string) iter.Seq[string]
```

## func [Title](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L180>)

```go
func Title(s string) string
```

## func [ToLower](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L184>)

```go
func ToLower(s string) string
```

## func [ToLowerSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L188>)

```go
func ToLowerSpecial(c unicode.SpecialCase, s string) string
```

## func [ToTitle](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L192>)

```go
func ToTitle(s string) string
```

## func [ToTitleSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L196>)

```go
func ToTitleSpecial(c unicode.SpecialCase, s string) string
```

## func [ToUpper](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L200>)

```go
func ToUpper(s string) string
```

## func [ToUpperSpecial](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L204>)

```go
func ToUpperSpecial(c unicode.SpecialCase, s string) string
```

## func [ToValidUTF8](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L208>)

```go
func ToValidUTF8(s, replacement string) string
```

## func [Trim](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L212>)

```go
func Trim(s, cutset string) string
```

## func [TrimFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L216>)

```go
func TrimFunc(s string, f func(rune) bool) string
```

## func [TrimLeft](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L220>)

```go
func TrimLeft(s, cutset string) string
```

## func [TrimLeftFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L224>)

```go
func TrimLeftFunc(s string, f func(rune) bool) string
```

## func [TrimPrefix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L228>)

```go
func TrimPrefix(s, prefix string) string
```

## func [TrimRight](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L232>)

```go
func TrimRight(s, cutset string) string
```

## func [TrimRightFunc](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L236>)

```go
func TrimRightFunc(s string, f func(rune) bool) string
```

## func [TrimSpace](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L240>)

```go
func TrimSpace(s string) string
```

## func [TrimSuffix](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L244>)

```go
func TrimSuffix(s, suffix string) string
```

## type [Builder](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L15>)

```go
type Builder = strings.Builder
```

## type [Reader](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L16>)

```go
type Reader = strings.Reader
```

## type [Replacer](<https://github.com/goexts/generic/blob/main/strings/strings.adapter.go#L17>)

```go
type Replacer = strings.Replacer
```

# examples

```go
import "github.com/goexts/generic/docs/examples"
```

Package main provides examples for using the slices package. These examples demonstrate common operations like mapping, filtering, and reducing slices.

## Index



# bytes

```go
import "github.com/goexts/generic/slices/bytes"
```

Package bytes contains generated code by adptool.

Package bytes provides a rich set of functions for the manipulation of byte slices.

This package is a generated adapter and mirrors the public API of the standard Go library's \`bytes\` package. It offers a convenient way to access the rich set of standard byte slice utilities within the generic context of this library.

For detailed information on the behavior of specific functions, please refer to the official Go documentation for the \`bytes\` package.

Example:

```
data := []byte("  [INFO] message  ")

// Trim whitespace
trimmed := bytes.TrimSpace(data)
// trimmed is "[INFO] message"

// Check for a prefix
_ = bytes.HasPrefix(trimmed, []byte("[INFO]")) // true
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Clone(b []byte) []byte](<#func-clone>)
- [func Compare(a, b []byte) int](<#func-compare>)
- [func Contains(b, subslice []byte) bool](<#func-contains>)
- [func ContainsAny(b []byte, chars string) bool](<#func-containsany>)
- [func ContainsFunc(b []byte, f func(rune) bool) bool](<#func-containsfunc>)
- [func ContainsRune(b []byte, r rune) bool](<#func-containsrune>)
- [func Count(s, sep []byte) int](<#func-count>)
- [func Cut(s, sep []byte) (before, after []byte, found bool)](<#func-cut>)
- [func CutPrefix(s, prefix []byte) (after []byte, found bool)](<#func-cutprefix>)
- [func CutSuffix(s, suffix []byte) (before []byte, found bool)](<#func-cutsuffix>)
- [func Equal(a, b []byte) bool](<#func-equal>)
- [func EqualFold(s, t []byte) bool](<#func-equalfold>)
- [func Fields(s []byte) [][]byte](<#func-fields>)
- [func FieldsFunc(s []byte, f func(rune) bool) [][]byte](<#func-fieldsfunc>)
- [func FieldsFuncSeq(s []byte, f func(rune) bool) iter.Seq[[]byte]](<#func-fieldsfuncseq>)
- [func FieldsSeq(s []byte) iter.Seq[[]byte]](<#func-fieldsseq>)
- [func HasPrefix(s, prefix []byte) bool](<#func-hasprefix>)
- [func HasSuffix(s, suffix []byte) bool](<#func-hassuffix>)
- [func Index(s, sep []byte) int](<#func-index>)
- [func IndexAny(s []byte, chars string) int](<#func-indexany>)
- [func IndexByte(b []byte, c byte) int](<#func-indexbyte>)
- [func IndexFunc(s []byte, f func(r rune) bool) int](<#func-indexfunc>)
- [func IndexRune(s []byte, r rune) int](<#func-indexrune>)
- [func Join(s [][]byte, sep []byte) []byte](<#func-join>)
- [func LastIndex(s, sep []byte) int](<#func-lastindex>)
- [func LastIndexAny(s []byte, chars string) int](<#func-lastindexany>)
- [func LastIndexByte(s []byte, c byte) int](<#func-lastindexbyte>)
- [func LastIndexFunc(s []byte, f func(r rune) bool) int](<#func-lastindexfunc>)
- [func Lines(s []byte) iter.Seq[[]byte]](<#func-lines>)
- [func Map(mapping func(r rune) rune, s []byte) []byte](<#func-map>)
- [func NewBuffer(buf []byte) *bytes.Buffer](<#func-newbuffer>)
- [func NewBufferString(s string) *bytes.Buffer](<#func-newbufferstring>)
- [func NewReader(b []byte) *bytes.Reader](<#func-newreader>)
- [func Repeat(b []byte, count int) []byte](<#func-repeat>)
- [func Replace(s, old, new []byte, n int) []byte](<#func-replace>)
- [func ReplaceAll(s, old, new []byte) []byte](<#func-replaceall>)
- [func Runes(s []byte) []rune](<#func-runes>)
- [func Split(s, sep []byte) [][]byte](<#func-split>)
- [func SplitAfter(s, sep []byte) [][]byte](<#func-splitafter>)
- [func SplitAfterN(s, sep []byte, n int) [][]byte](<#func-splitaftern>)
- [func SplitAfterSeq(s, sep []byte) iter.Seq[[]byte]](<#func-splitafterseq>)
- [func SplitN(s, sep []byte, n int) [][]byte](<#func-splitn>)
- [func SplitSeq(s, sep []byte) iter.Seq[[]byte]](<#func-splitseq>)
- [func Title(s []byte) []byte](<#func-title>)
- [func ToLower(s []byte) []byte](<#func-tolower>)
- [func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte](<#func-tolowerspecial>)
- [func ToTitle(s []byte) []byte](<#func-totitle>)
- [func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte](<#func-totitlespecial>)
- [func ToUpper(s []byte) []byte](<#func-toupper>)
- [func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte](<#func-toupperspecial>)
- [func ToValidUTF8(s, replacement []byte) []byte](<#func-tovalidutf8>)
- [func Trim(s []byte, cutset string) []byte](<#func-trim>)
- [func TrimFunc(s []byte, f func(r rune) bool) []byte](<#func-trimfunc>)
- [func TrimLeft(s []byte, cutset string) []byte](<#func-trimleft>)
- [func TrimLeftFunc(s []byte, f func(r rune) bool) []byte](<#func-trimleftfunc>)
- [func TrimPrefix(s, prefix []byte) []byte](<#func-trimprefix>)
- [func TrimRight(s []byte, cutset string) []byte](<#func-trimright>)
- [func TrimRightFunc(s []byte, f func(r rune) bool) []byte](<#func-trimrightfunc>)
- [func TrimSpace(s []byte) []byte](<#func-trimspace>)
- [func TrimSuffix(s, suffix []byte) []byte](<#func-trimsuffix>)
- [type Buffer](<#type-buffer>)
- [type Bytes](<#type-bytes>)
  - [func FromString(s string) Bytes](<#func-fromstring>)
  - [func (b Bytes) Contains(sub []byte) bool](<#func-bytes-contains>)
  - [func (b Bytes) FindString(s string) int](<#func-bytes-findstring>)
  - [func (b Bytes) HasPrefix(prefix []byte) bool](<#func-bytes-hasprefix>)
  - [func (b Bytes) HasSuffix(suffix []byte) bool](<#func-bytes-hassuffix>)
  - [func (b Bytes) Index(sub []byte) int](<#func-bytes-index>)
  - [func (b Bytes) Read(offset int, limit int) []byte](<#func-bytes-read>)
  - [func (b Bytes) ReadString(offset int, limit int) string](<#func-bytes-readstring>)
  - [func (b Bytes) Replace(old, replacement []byte, n int) []byte](<#func-bytes-replace>)
  - [func (b Bytes) String() string](<#func-bytes-string>)
  - [func (b Bytes) Trim(cutset string) []byte](<#func-bytes-trim>)
  - [func (b Bytes) TrimPrefix(prefix []byte) []byte](<#func-bytes-trimprefix>)
  - [func (b Bytes) TrimSpace() []byte](<#func-bytes-trimspace>)
  - [func (b Bytes) TrimSuffix(suffix []byte) []byte](<#func-bytes-trimsuffix>)
- [type Reader](<#type-reader>)


## Constants

```go
const MinRead = bytes.MinRead
```

## Variables

```go
var ErrTooLarge = bytes.ErrTooLarge
```

## func [Clone](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L23>)

```go
func Clone(b []byte) []byte
```

## func [Compare](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L27>)

```go
func Compare(a, b []byte) int
```

## func [Contains](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L31>)

```go
func Contains(b, subslice []byte) bool
```

## func [ContainsAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L35>)

```go
func ContainsAny(b []byte, chars string) bool
```

## func [ContainsFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L39>)

```go
func ContainsFunc(b []byte, f func(rune) bool) bool
```

## func [ContainsRune](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L43>)

```go
func ContainsRune(b []byte, r rune) bool
```

## func [Count](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L47>)

```go
func Count(s, sep []byte) int
```

## func [Cut](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L51>)

```go
func Cut(s, sep []byte) (before, after []byte, found bool)
```

## func [CutPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L55>)

```go
func CutPrefix(s, prefix []byte) (after []byte, found bool)
```

## func [CutSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L59>)

```go
func CutSuffix(s, suffix []byte) (before []byte, found bool)
```

## func [Equal](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L63>)

```go
func Equal(a, b []byte) bool
```

## func [EqualFold](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L67>)

```go
func EqualFold(s, t []byte) bool
```

## func [Fields](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L71>)

```go
func Fields(s []byte) [][]byte
```

## func [FieldsFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L75>)

```go
func FieldsFunc(s []byte, f func(rune) bool) [][]byte
```

## func [FieldsFuncSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L79>)

```go
func FieldsFuncSeq(s []byte, f func(rune) bool) iter.Seq[[]byte]
```

## func [FieldsSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L83>)

```go
func FieldsSeq(s []byte) iter.Seq[[]byte]
```

## func [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L87>)

```go
func HasPrefix(s, prefix []byte) bool
```

## func [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L91>)

```go
func HasSuffix(s, suffix []byte) bool
```

## func [Index](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L95>)

```go
func Index(s, sep []byte) int
```

## func [IndexAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L99>)

```go
func IndexAny(s []byte, chars string) int
```

## func [IndexByte](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L103>)

```go
func IndexByte(b []byte, c byte) int
```

## func [IndexFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L107>)

```go
func IndexFunc(s []byte, f func(r rune) bool) int
```

## func [IndexRune](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L111>)

```go
func IndexRune(s []byte, r rune) int
```

## func [Join](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L115>)

```go
func Join(s [][]byte, sep []byte) []byte
```

## func [LastIndex](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L119>)

```go
func LastIndex(s, sep []byte) int
```

## func [LastIndexAny](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L123>)

```go
func LastIndexAny(s []byte, chars string) int
```

## func [LastIndexByte](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L127>)

```go
func LastIndexByte(s []byte, c byte) int
```

## func [LastIndexFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L131>)

```go
func LastIndexFunc(s []byte, f func(r rune) bool) int
```

## func [Lines](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L135>)

```go
func Lines(s []byte) iter.Seq[[]byte]
```

## func [Map](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L139>)

```go
func Map(mapping func(r rune) rune, s []byte) []byte
```

## func [NewBuffer](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L143>)

```go
func NewBuffer(buf []byte) *bytes.Buffer
```

## func [NewBufferString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L147>)

```go
func NewBufferString(s string) *bytes.Buffer
```

## func [NewReader](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L151>)

```go
func NewReader(b []byte) *bytes.Reader
```

## func [Repeat](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L155>)

```go
func Repeat(b []byte, count int) []byte
```

## func [Replace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L159>)

```go
func Replace(s, old, new []byte, n int) []byte
```

## func [ReplaceAll](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L163>)

```go
func ReplaceAll(s, old, new []byte) []byte
```

## func [Runes](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L167>)

```go
func Runes(s []byte) []rune
```

## func [Split](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L171>)

```go
func Split(s, sep []byte) [][]byte
```

## func [SplitAfter](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L175>)

```go
func SplitAfter(s, sep []byte) [][]byte
```

## func [SplitAfterN](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L179>)

```go
func SplitAfterN(s, sep []byte, n int) [][]byte
```

## func [SplitAfterSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L183>)

```go
func SplitAfterSeq(s, sep []byte) iter.Seq[[]byte]
```

## func [SplitN](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L187>)

```go
func SplitN(s, sep []byte, n int) [][]byte
```

## func [SplitSeq](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L191>)

```go
func SplitSeq(s, sep []byte) iter.Seq[[]byte]
```

## func [Title](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L195>)

```go
func Title(s []byte) []byte
```

## func [ToLower](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L199>)

```go
func ToLower(s []byte) []byte
```

## func [ToLowerSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L203>)

```go
func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte
```

## func [ToTitle](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L207>)

```go
func ToTitle(s []byte) []byte
```

## func [ToTitleSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L211>)

```go
func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte
```

## func [ToUpper](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L215>)

```go
func ToUpper(s []byte) []byte
```

## func [ToUpperSpecial](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L219>)

```go
func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte
```

## func [ToValidUTF8](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L223>)

```go
func ToValidUTF8(s, replacement []byte) []byte
```

## func [Trim](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L227>)

```go
func Trim(s []byte, cutset string) []byte
```

## func [TrimFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L231>)

```go
func TrimFunc(s []byte, f func(r rune) bool) []byte
```

## func [TrimLeft](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L235>)

```go
func TrimLeft(s []byte, cutset string) []byte
```

## func [TrimLeftFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L239>)

```go
func TrimLeftFunc(s []byte, f func(r rune) bool) []byte
```

## func [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L243>)

```go
func TrimPrefix(s, prefix []byte) []byte
```

## func [TrimRight](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L247>)

```go
func TrimRight(s []byte, cutset string) []byte
```

## func [TrimRightFunc](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L251>)

```go
func TrimRightFunc(s []byte, f func(r rune) bool) []byte
```

## func [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L255>)

```go
func TrimSpace(s []byte) []byte
```

## func [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L259>)

```go
func TrimSuffix(s, suffix []byte) []byte
```

## type [Buffer](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L19>)

```go
type Buffer = bytes.Buffer
```

## type [Bytes](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L11>)

Bytes is a type alias for \[\]byte to provide methods.

```go
type Bytes []byte
```

### func [FromString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L85>)

```go
func FromString(s string) Bytes
```

FromString converts a string to a Bytes slice.

### func \(Bytes\) [Contains](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L70>)

```go
func (b Bytes) Contains(sub []byte) bool
```

Contains reports whether sub is within b.

### func \(Bytes\) [FindString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L35>)

```go
func (b Bytes) FindString(s string) int
```

FindString returns the index of the first instance of s in b, or \-1 if s is not present in b.

### func \(Bytes\) [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L75>)

```go
func (b Bytes) HasPrefix(prefix []byte) bool
```

HasPrefix tests whether the byte slice b begins with prefix.

### func \(Bytes\) [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L80>)

```go
func (b Bytes) HasSuffix(suffix []byte) bool
```

HasSuffix tests whether the byte slice b ends with suffix.

### func \(Bytes\) [Index](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L30>)

```go
func (b Bytes) Index(sub []byte) int
```

Index returns the index of the first instance of sub in b, or \-1 if sub is not present in b.

### func \(Bytes\) [Read](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L14>)

```go
func (b Bytes) Read(offset int, limit int) []byte
```

Read returns a slice of the Bytes s beginning at offset and length limit.

### func \(Bytes\) [ReadString](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L25>)

```go
func (b Bytes) ReadString(offset int, limit int) string
```

ReadString returns a string of the Bytes s beginning at offset and length limit.

### func \(Bytes\) [Replace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L65>)

```go
func (b Bytes) Replace(old, replacement []byte, n int) []byte
```

Replace returns a copy of the slice with the first n non\-overlapping instances of old replaced by replacement.

### func \(Bytes\) [String](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L40>)

```go
func (b Bytes) String() string
```

String converts the Bytes slice to a string.

### func \(Bytes\) [Trim](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L45>)

```go
func (b Bytes) Trim(cutset string) []byte
```

Trim returns a slice of the bytes, with all leading and trailing bytes contained in cutset removed.

### func \(Bytes\) [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L55>)

```go
func (b Bytes) TrimPrefix(prefix []byte) []byte
```

TrimPrefix returns b without the provided leading prefix.

### func \(Bytes\) [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L50>)

```go
func (b Bytes) TrimSpace() []byte
```

TrimSpace returns a slice of the bytes, with all leading and trailing white space removed.

### func \(Bytes\) [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.go#L60>)

```go
func (b Bytes) TrimSuffix(suffix []byte) []byte
```

TrimSuffix returns b without the provided trailing suffix.

## type [Reader](<https://github.com/goexts/generic/blob/main/slices/bytes/bytes.adapter.go#L20>)

```go
type Reader = bytes.Reader
```

# runes

```go
import "github.com/goexts/generic/slices/runes"
```

Package runes provides a rich set of functions for the manipulation of rune slices \(\`\[\]rune\`\).

This package is essential for correct, Unicode\-aware text processing at the code point level.

This package is a generated adapter and mirrors the public API of the Go experimental package \`golang.org/x/text/runes\`. It offers a convenient way to access these specialized utilities within the generic context of this library.

For detailed information on the behavior of specific functions and the underlying Unicode algorithms, please refer to the official documentation for the \`golang.org/x/text/runes\` package.

Example:

```
text := []rune("  Hello, !  ")

// Trim whitespace using Unicode-aware functions
trimmed := runes.TrimSpace(text)
// trimmed is "Hello, !"
```

Package runes contains generated code by adptool.

## Index

- [func If(s runes.Set, tIn, tNotIn transform.Transformer) runes.Transformer](<#func-if>)
- [func In(rt *unicode.RangeTable) runes.Set](<#func-in>)
- [func Map(mapping func(rune) rune) runes.Transformer](<#func-map>)
- [func NotIn(rt *unicode.RangeTable) runes.Set](<#func-notin>)
- [func Predicate(f func(rune) bool) runes.Set](<#func-predicate>)
- [func Remove(s runes.Set) runes.Transformer](<#func-remove>)
- [func ReplaceIllFormed() runes.Transformer](<#func-replaceillformed>)
- [type Runes](<#type-runes>)
  - [func FromString(s string) Runes](<#func-fromstring>)
  - [func (r Runes) Contains(sub []rune) bool](<#func-runes-contains>)
  - [func (r Runes) FindString(s string) int](<#func-runes-findstring>)
  - [func (r Runes) HasPrefix(prefix []rune) bool](<#func-runes-hasprefix>)
  - [func (r Runes) HasSuffix(suffix []rune) bool](<#func-runes-hassuffix>)
  - [func (r Runes) Index(sub []rune) int](<#func-runes-index>)
  - [func (r Runes) Read(offset int, limit int) []rune](<#func-runes-read>)
  - [func (r Runes) ReadString(offset int, limit int) string](<#func-runes-readstring>)
  - [func (r Runes) Replace(old, replacement []rune, n int) []rune](<#func-runes-replace>)
  - [func (r Runes) String() string](<#func-runes-string>)
  - [func (r Runes) StringArray() []string](<#func-runes-stringarray>)
  - [func (r Runes) ToBytes() []byte](<#func-runes-tobytes>)
  - [func (r Runes) Trim(cutset string) []rune](<#func-runes-trim>)
  - [func (r Runes) TrimPrefix(prefix []rune) []rune](<#func-runes-trimprefix>)
  - [func (r Runes) TrimSpace() []rune](<#func-runes-trimspace>)
  - [func (r Runes) TrimSuffix(suffix []rune) []rune](<#func-runes-trimsuffix>)
- [type Set](<#type-set>)
- [type Transformer](<#type-transformer>)


## func [If](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L20>)

```go
func If(s runes.Set, tIn, tNotIn transform.Transformer) runes.Transformer
```

## func [In](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L24>)

```go
func In(rt *unicode.RangeTable) runes.Set
```

## func [Map](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L28>)

```go
func Map(mapping func(rune) rune) runes.Transformer
```

## func [NotIn](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L32>)

```go
func NotIn(rt *unicode.RangeTable) runes.Set
```

## func [Predicate](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L36>)

```go
func Predicate(f func(rune) bool) runes.Set
```

## func [Remove](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L40>)

```go
func Remove(s runes.Set) runes.Transformer
```

## func [ReplaceIllFormed](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L44>)

```go
func ReplaceIllFormed() runes.Transformer
```

## type [Runes](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L13>)

Runes is a type alias for \[\]rune to provide methods.

```go
type Runes []rune
```

### func [FromString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L164>)

```go
func FromString(s string) Runes
```

FromString converts a string to a rune slice \(\[\]rune\). This is a convenience function that is equivalent to \`\[\]rune\(s\)\`.

### func \(Runes\) [Contains](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L148>)

```go
func (r Runes) Contains(sub []rune) bool
```

Contains reports whether sub is within r.

### func \(Runes\) [FindString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L39>)

```go
func (r Runes) FindString(s string) int
```

FindString returns the index of the first instance of s in r, or \-1 if s is not present in r.

### func \(Runes\) [HasPrefix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L153>)

```go
func (r Runes) HasPrefix(prefix []rune) bool
```

HasPrefix tests whether the Runes slice s begins with prefix.

### func \(Runes\) [HasSuffix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L158>)

```go
func (r Runes) HasSuffix(suffix []rune) bool
```

HasSuffix tests whether the Runes slice s ends with suffix.

### func \(Runes\) [Index](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L34>)

```go
func (r Runes) Index(sub []rune) int
```

Index returns the index of the first instance of sub in r, or \-1 if sub is not present in r.

### func \(Runes\) [Read](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L16>)

```go
func (r Runes) Read(offset int, limit int) []rune
```

Read returns a slice of the Runes s beginning at offset and length limit.

### func \(Runes\) [ReadString](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L29>)

```go
func (r Runes) ReadString(offset int, limit int) string
```

ReadString returns a string of the Runes s beginning at offset and length limit.

### func \(Runes\) [Replace](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L114>)

```go
func (r Runes) Replace(old, replacement []rune, n int) []rune
```

Replace returns a copy of the slice with the first n non\-overlapping instances of old replaced by replacement.

### func \(Runes\) [String](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L53>)

```go
func (r Runes) String() string
```

String converts the Runes slice to a string.

### func \(Runes\) [StringArray](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L44>)

```go
func (r Runes) StringArray() []string
```

StringArray converts each rune to a string and returns a slice of strings.

### func \(Runes\) [ToBytes](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L58>)

```go
func (r Runes) ToBytes() []byte
```

ToBytes converts the rune slice back to a UTF\-8 encoded byte slice.

### func \(Runes\) [Trim](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L63>)

```go
func (r Runes) Trim(cutset string) []rune
```

Trim returns a slice of the runes, with all leading and trailing runes contained in cutset removed.

### func \(Runes\) [TrimPrefix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L98>)

```go
func (r Runes) TrimPrefix(prefix []rune) []rune
```

TrimPrefix returns s without the provided leading prefix.

### func \(Runes\) [TrimSpace](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L81>)

```go
func (r Runes) TrimSpace() []rune
```

TrimSpace returns a slice of the runes, with all leading and trailing white space removed.

### func \(Runes\) [TrimSuffix](<https://github.com/goexts/generic/blob/main/slices/runes/runes.go#L106>)

```go
func (r Runes) TrimSuffix(suffix []rune) []rune
```

TrimSuffix returns s without the provided trailing suffix.

## type [Set](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L16>)

```go
type Set = runes.Set
```

## type [Transformer](<https://github.com/goexts/generic/blob/main/slices/runes/runes.adapter.go#L17>)

```go
type Transformer = runes.Transformer
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
